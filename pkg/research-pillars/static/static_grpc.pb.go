// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: research-pillars/static/static.proto

package static

import (
	context "context"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Programs_GetPrograms_FullMethodName         = "/proto.static.Programs/GetPrograms"
	Programs_GetProgram_FullMethodName          = "/proto.static.Programs/GetProgram"
	Programs_GetProgramData_FullMethodName      = "/proto.static.Programs/GetProgramData"
	Programs_GetProgramUpdatedAt_FullMethodName = "/proto.static.Programs/GetProgramUpdatedAt"
)

// ProgramsClient is the client API for Programs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProgramsClient interface {
	GetPrograms(ctx context.Context, in *GetProgramsRequest, opts ...grpc.CallOption) (*GetProgramsResponse, error)
	GetProgram(ctx context.Context, in *GetProgramRequest, opts ...grpc.CallOption) (*GetProgramResponse, error)
	GetProgramData(ctx context.Context, in *GetProgramDataRequest, opts ...grpc.CallOption) (*GetProgramDataResponse, error)
	GetProgramUpdatedAt(ctx context.Context, in *GetProgramUpdatedAtRequest, opts ...grpc.CallOption) (*GetProgramUpdatedAtResponse, error)
}

type programsClient struct {
	cc grpc.ClientConnInterface
}

func NewProgramsClient(cc grpc.ClientConnInterface) ProgramsClient {
	return &programsClient{cc}
}

func (c *programsClient) GetPrograms(ctx context.Context, in *GetProgramsRequest, opts ...grpc.CallOption) (*GetProgramsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramsResponse)
	err := c.cc.Invoke(ctx, Programs_GetPrograms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgram(ctx context.Context, in *GetProgramRequest, opts ...grpc.CallOption) (*GetProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgramData(ctx context.Context, in *GetProgramDataRequest, opts ...grpc.CallOption) (*GetProgramDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramDataResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgramData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgramUpdatedAt(ctx context.Context, in *GetProgramUpdatedAtRequest, opts ...grpc.CallOption) (*GetProgramUpdatedAtResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramUpdatedAtResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgramUpdatedAt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProgramsServer is the server API for Programs service.
// All implementations must embed UnimplementedProgramsServer
// for forward compatibility.
type ProgramsServer interface {
	GetPrograms(context.Context, *GetProgramsRequest) (*GetProgramsResponse, error)
	GetProgram(context.Context, *GetProgramRequest) (*GetProgramResponse, error)
	GetProgramData(context.Context, *GetProgramDataRequest) (*GetProgramDataResponse, error)
	GetProgramUpdatedAt(context.Context, *GetProgramUpdatedAtRequest) (*GetProgramUpdatedAtResponse, error)
	mustEmbedUnimplementedProgramsServer()
}

// UnimplementedProgramsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProgramsServer struct{}

func (UnimplementedProgramsServer) GetPrograms(context.Context, *GetProgramsRequest) (*GetProgramsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrograms not implemented")
}
func (UnimplementedProgramsServer) GetProgram(context.Context, *GetProgramRequest) (*GetProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgram not implemented")
}
func (UnimplementedProgramsServer) GetProgramData(context.Context, *GetProgramDataRequest) (*GetProgramDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramData not implemented")
}
func (UnimplementedProgramsServer) GetProgramUpdatedAt(context.Context, *GetProgramUpdatedAtRequest) (*GetProgramUpdatedAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramUpdatedAt not implemented")
}
func (UnimplementedProgramsServer) mustEmbedUnimplementedProgramsServer() {}
func (UnimplementedProgramsServer) testEmbeddedByValue()                  {}

// UnsafeProgramsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProgramsServer will
// result in compilation errors.
type UnsafeProgramsServer interface {
	mustEmbedUnimplementedProgramsServer()
}

func RegisterProgramsServer(s grpc.ServiceRegistrar, srv ProgramsServer) {
	// If the following call pancis, it indicates UnimplementedProgramsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Programs_ServiceDesc, srv)
}

func _Programs_GetPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetPrograms(ctx, req.(*GetProgramsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgram(ctx, req.(*GetProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgramData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgramData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgramData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgramData(ctx, req.(*GetProgramDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgramUpdatedAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramUpdatedAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgramUpdatedAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgramUpdatedAt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgramUpdatedAt(ctx, req.(*GetProgramUpdatedAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Programs_ServiceDesc is the grpc.ServiceDesc for Programs service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Programs_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Programs",
	HandlerType: (*ProgramsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrograms",
			Handler:    _Programs_GetPrograms_Handler,
		},
		{
			MethodName: "GetProgram",
			Handler:    _Programs_GetProgram_Handler,
		},
		{
			MethodName: "GetProgramData",
			Handler:    _Programs_GetProgramData_Handler,
		},
		{
			MethodName: "GetProgramUpdatedAt",
			Handler:    _Programs_GetProgramUpdatedAt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Surveys_GetSurveys_FullMethodName = "/proto.static.Surveys/GetSurveys"
	Surveys_GetSurvey_FullMethodName  = "/proto.static.Surveys/GetSurvey"
)

// SurveysClient is the client API for Surveys service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SurveysClient interface {
	GetSurveys(ctx context.Context, in *GetSurveysRequest, opts ...grpc.CallOption) (*GetSurveysResponse, error)
	GetSurvey(ctx context.Context, in *GetSurveyRequest, opts ...grpc.CallOption) (*GetSurveyResponse, error)
}

type surveysClient struct {
	cc grpc.ClientConnInterface
}

func NewSurveysClient(cc grpc.ClientConnInterface) SurveysClient {
	return &surveysClient{cc}
}

func (c *surveysClient) GetSurveys(ctx context.Context, in *GetSurveysRequest, opts ...grpc.CallOption) (*GetSurveysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSurveysResponse)
	err := c.cc.Invoke(ctx, Surveys_GetSurveys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *surveysClient) GetSurvey(ctx context.Context, in *GetSurveyRequest, opts ...grpc.CallOption) (*GetSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSurveyResponse)
	err := c.cc.Invoke(ctx, Surveys_GetSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SurveysServer is the server API for Surveys service.
// All implementations must embed UnimplementedSurveysServer
// for forward compatibility.
type SurveysServer interface {
	GetSurveys(context.Context, *GetSurveysRequest) (*GetSurveysResponse, error)
	GetSurvey(context.Context, *GetSurveyRequest) (*GetSurveyResponse, error)
	mustEmbedUnimplementedSurveysServer()
}

// UnimplementedSurveysServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSurveysServer struct{}

func (UnimplementedSurveysServer) GetSurveys(context.Context, *GetSurveysRequest) (*GetSurveysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSurveys not implemented")
}
func (UnimplementedSurveysServer) GetSurvey(context.Context, *GetSurveyRequest) (*GetSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSurvey not implemented")
}
func (UnimplementedSurveysServer) mustEmbedUnimplementedSurveysServer() {}
func (UnimplementedSurveysServer) testEmbeddedByValue()                 {}

// UnsafeSurveysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SurveysServer will
// result in compilation errors.
type UnsafeSurveysServer interface {
	mustEmbedUnimplementedSurveysServer()
}

func RegisterSurveysServer(s grpc.ServiceRegistrar, srv SurveysServer) {
	// If the following call pancis, it indicates UnimplementedSurveysServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Surveys_ServiceDesc, srv)
}

func _Surveys_GetSurveys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSurveysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).GetSurveys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_GetSurveys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).GetSurveys(ctx, req.(*GetSurveysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Surveys_GetSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).GetSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_GetSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).GetSurvey(ctx, req.(*GetSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Surveys_ServiceDesc is the grpc.ServiceDesc for Surveys service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Surveys_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Surveys",
	HandlerType: (*SurveysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSurveys",
			Handler:    _Surveys_GetSurveys_Handler,
		},
		{
			MethodName: "GetSurvey",
			Handler:    _Surveys_GetSurvey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Questionnaires_GetQuestionnaires_FullMethodName = "/proto.static.Questionnaires/GetQuestionnaires"
	Questionnaires_GetQuestionnaire_FullMethodName  = "/proto.static.Questionnaires/GetQuestionnaire"
)

// QuestionnairesClient is the client API for Questionnaires service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuestionnairesClient interface {
	GetQuestionnaires(ctx context.Context, in *GetQuestionnairesRequest, opts ...grpc.CallOption) (*GetQuestionnairesResponse, error)
	GetQuestionnaire(ctx context.Context, in *GetQuestionnaireRequest, opts ...grpc.CallOption) (*GetQuestionnaireResponse, error)
}

type questionnairesClient struct {
	cc grpc.ClientConnInterface
}

func NewQuestionnairesClient(cc grpc.ClientConnInterface) QuestionnairesClient {
	return &questionnairesClient{cc}
}

func (c *questionnairesClient) GetQuestionnaires(ctx context.Context, in *GetQuestionnairesRequest, opts ...grpc.CallOption) (*GetQuestionnairesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionnairesResponse)
	err := c.cc.Invoke(ctx, Questionnaires_GetQuestionnaires_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionnairesClient) GetQuestionnaire(ctx context.Context, in *GetQuestionnaireRequest, opts ...grpc.CallOption) (*GetQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionnaireResponse)
	err := c.cc.Invoke(ctx, Questionnaires_GetQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuestionnairesServer is the server API for Questionnaires service.
// All implementations must embed UnimplementedQuestionnairesServer
// for forward compatibility.
type QuestionnairesServer interface {
	GetQuestionnaires(context.Context, *GetQuestionnairesRequest) (*GetQuestionnairesResponse, error)
	GetQuestionnaire(context.Context, *GetQuestionnaireRequest) (*GetQuestionnaireResponse, error)
	mustEmbedUnimplementedQuestionnairesServer()
}

// UnimplementedQuestionnairesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQuestionnairesServer struct{}

func (UnimplementedQuestionnairesServer) GetQuestionnaires(context.Context, *GetQuestionnairesRequest) (*GetQuestionnairesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionnaires not implemented")
}
func (UnimplementedQuestionnairesServer) GetQuestionnaire(context.Context, *GetQuestionnaireRequest) (*GetQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionnaire not implemented")
}
func (UnimplementedQuestionnairesServer) mustEmbedUnimplementedQuestionnairesServer() {}
func (UnimplementedQuestionnairesServer) testEmbeddedByValue()                        {}

// UnsafeQuestionnairesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuestionnairesServer will
// result in compilation errors.
type UnsafeQuestionnairesServer interface {
	mustEmbedUnimplementedQuestionnairesServer()
}

func RegisterQuestionnairesServer(s grpc.ServiceRegistrar, srv QuestionnairesServer) {
	// If the following call pancis, it indicates UnimplementedQuestionnairesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Questionnaires_ServiceDesc, srv)
}

func _Questionnaires_GetQuestionnaires_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionnairesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).GetQuestionnaires(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_GetQuestionnaires_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).GetQuestionnaires(ctx, req.(*GetQuestionnairesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Questionnaires_GetQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).GetQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_GetQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).GetQuestionnaire(ctx, req.(*GetQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Questionnaires_ServiceDesc is the grpc.ServiceDesc for Questionnaires service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Questionnaires_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Questionnaires",
	HandlerType: (*QuestionnairesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetQuestionnaires",
			Handler:    _Questionnaires_GetQuestionnaires_Handler,
		},
		{
			MethodName: "GetQuestionnaire",
			Handler:    _Questionnaires_GetQuestionnaire_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Routines_GetRoutines_FullMethodName = "/proto.static.Routines/GetRoutines"
	Routines_GetRoutine_FullMethodName  = "/proto.static.Routines/GetRoutine"
)

// RoutinesClient is the client API for Routines service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutinesClient interface {
	GetRoutines(ctx context.Context, in *GetRoutinesRequest, opts ...grpc.CallOption) (*GetRoutinesResponse, error)
	GetRoutine(ctx context.Context, in *GetRoutineRequest, opts ...grpc.CallOption) (*GetRoutineResponse, error)
}

type routinesClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutinesClient(cc grpc.ClientConnInterface) RoutinesClient {
	return &routinesClient{cc}
}

func (c *routinesClient) GetRoutines(ctx context.Context, in *GetRoutinesRequest, opts ...grpc.CallOption) (*GetRoutinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoutinesResponse)
	err := c.cc.Invoke(ctx, Routines_GetRoutines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routinesClient) GetRoutine(ctx context.Context, in *GetRoutineRequest, opts ...grpc.CallOption) (*GetRoutineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoutineResponse)
	err := c.cc.Invoke(ctx, Routines_GetRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutinesServer is the server API for Routines service.
// All implementations must embed UnimplementedRoutinesServer
// for forward compatibility.
type RoutinesServer interface {
	GetRoutines(context.Context, *GetRoutinesRequest) (*GetRoutinesResponse, error)
	GetRoutine(context.Context, *GetRoutineRequest) (*GetRoutineResponse, error)
	mustEmbedUnimplementedRoutinesServer()
}

// UnimplementedRoutinesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoutinesServer struct{}

func (UnimplementedRoutinesServer) GetRoutines(context.Context, *GetRoutinesRequest) (*GetRoutinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutines not implemented")
}
func (UnimplementedRoutinesServer) GetRoutine(context.Context, *GetRoutineRequest) (*GetRoutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutine not implemented")
}
func (UnimplementedRoutinesServer) mustEmbedUnimplementedRoutinesServer() {}
func (UnimplementedRoutinesServer) testEmbeddedByValue()                  {}

// UnsafeRoutinesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutinesServer will
// result in compilation errors.
type UnsafeRoutinesServer interface {
	mustEmbedUnimplementedRoutinesServer()
}

func RegisterRoutinesServer(s grpc.ServiceRegistrar, srv RoutinesServer) {
	// If the following call pancis, it indicates UnimplementedRoutinesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Routines_ServiceDesc, srv)
}

func _Routines_GetRoutines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).GetRoutines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_GetRoutines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).GetRoutines(ctx, req.(*GetRoutinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routines_GetRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).GetRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_GetRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).GetRoutine(ctx, req.(*GetRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Routines_ServiceDesc is the grpc.ServiceDesc for Routines service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Routines_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Routines",
	HandlerType: (*RoutinesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRoutines",
			Handler:    _Routines_GetRoutines_Handler,
		},
		{
			MethodName: "GetRoutine",
			Handler:    _Routines_GetRoutine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Displays_GetDisplays_FullMethodName = "/proto.static.Displays/GetDisplays"
	Displays_GetDisplay_FullMethodName  = "/proto.static.Displays/GetDisplay"
)

// DisplaysClient is the client API for Displays service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DisplaysClient interface {
	GetDisplays(ctx context.Context, in *GetDisplaysRequest, opts ...grpc.CallOption) (*GetDisplaysResponse, error)
	GetDisplay(ctx context.Context, in *GetDisplayRequest, opts ...grpc.CallOption) (*GetDisplayResponse, error)
}

type displaysClient struct {
	cc grpc.ClientConnInterface
}

func NewDisplaysClient(cc grpc.ClientConnInterface) DisplaysClient {
	return &displaysClient{cc}
}

func (c *displaysClient) GetDisplays(ctx context.Context, in *GetDisplaysRequest, opts ...grpc.CallOption) (*GetDisplaysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDisplaysResponse)
	err := c.cc.Invoke(ctx, Displays_GetDisplays_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *displaysClient) GetDisplay(ctx context.Context, in *GetDisplayRequest, opts ...grpc.CallOption) (*GetDisplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDisplayResponse)
	err := c.cc.Invoke(ctx, Displays_GetDisplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DisplaysServer is the server API for Displays service.
// All implementations must embed UnimplementedDisplaysServer
// for forward compatibility.
type DisplaysServer interface {
	GetDisplays(context.Context, *GetDisplaysRequest) (*GetDisplaysResponse, error)
	GetDisplay(context.Context, *GetDisplayRequest) (*GetDisplayResponse, error)
	mustEmbedUnimplementedDisplaysServer()
}

// UnimplementedDisplaysServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDisplaysServer struct{}

func (UnimplementedDisplaysServer) GetDisplays(context.Context, *GetDisplaysRequest) (*GetDisplaysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDisplays not implemented")
}
func (UnimplementedDisplaysServer) GetDisplay(context.Context, *GetDisplayRequest) (*GetDisplayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDisplay not implemented")
}
func (UnimplementedDisplaysServer) mustEmbedUnimplementedDisplaysServer() {}
func (UnimplementedDisplaysServer) testEmbeddedByValue()                  {}

// UnsafeDisplaysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DisplaysServer will
// result in compilation errors.
type UnsafeDisplaysServer interface {
	mustEmbedUnimplementedDisplaysServer()
}

func RegisterDisplaysServer(s grpc.ServiceRegistrar, srv DisplaysServer) {
	// If the following call pancis, it indicates UnimplementedDisplaysServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Displays_ServiceDesc, srv)
}

func _Displays_GetDisplays_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDisplaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).GetDisplays(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_GetDisplays_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).GetDisplays(ctx, req.(*GetDisplaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Displays_GetDisplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDisplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).GetDisplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_GetDisplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).GetDisplay(ctx, req.(*GetDisplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Displays_ServiceDesc is the grpc.ServiceDesc for Displays service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Displays_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Displays",
	HandlerType: (*DisplaysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDisplays",
			Handler:    _Displays_GetDisplays_Handler,
		},
		{
			MethodName: "GetDisplay",
			Handler:    _Displays_GetDisplay_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Consents_GetConsents_FullMethodName       = "/proto.static.Consents/GetConsents"
	Consents_GetConsent_FullMethodName        = "/proto.static.Consents/GetConsent"
	Consents_GetConsentVersion_FullMethodName = "/proto.static.Consents/GetConsentVersion"
)

// ConsentsClient is the client API for Consents service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsentsClient interface {
	GetConsents(ctx context.Context, in *GetConsentsRequest, opts ...grpc.CallOption) (*GetConsentsResponse, error)
	GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error)
	GetConsentVersion(ctx context.Context, in *GetConsentVersionRequest, opts ...grpc.CallOption) (*GetConsentVersionResponse, error)
}

type consentsClient struct {
	cc grpc.ClientConnInterface
}

func NewConsentsClient(cc grpc.ClientConnInterface) ConsentsClient {
	return &consentsClient{cc}
}

func (c *consentsClient) GetConsents(ctx context.Context, in *GetConsentsRequest, opts ...grpc.CallOption) (*GetConsentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsentsResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsentResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) GetConsentVersion(ctx context.Context, in *GetConsentVersionRequest, opts ...grpc.CallOption) (*GetConsentVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsentVersionResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsentVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsentsServer is the server API for Consents service.
// All implementations must embed UnimplementedConsentsServer
// for forward compatibility.
type ConsentsServer interface {
	GetConsents(context.Context, *GetConsentsRequest) (*GetConsentsResponse, error)
	GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error)
	GetConsentVersion(context.Context, *GetConsentVersionRequest) (*GetConsentVersionResponse, error)
	mustEmbedUnimplementedConsentsServer()
}

// UnimplementedConsentsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConsentsServer struct{}

func (UnimplementedConsentsServer) GetConsents(context.Context, *GetConsentsRequest) (*GetConsentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsents not implemented")
}
func (UnimplementedConsentsServer) GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsent not implemented")
}
func (UnimplementedConsentsServer) GetConsentVersion(context.Context, *GetConsentVersionRequest) (*GetConsentVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsentVersion not implemented")
}
func (UnimplementedConsentsServer) mustEmbedUnimplementedConsentsServer() {}
func (UnimplementedConsentsServer) testEmbeddedByValue()                  {}

// UnsafeConsentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsentsServer will
// result in compilation errors.
type UnsafeConsentsServer interface {
	mustEmbedUnimplementedConsentsServer()
}

func RegisterConsentsServer(s grpc.ServiceRegistrar, srv ConsentsServer) {
	// If the following call pancis, it indicates UnimplementedConsentsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Consents_ServiceDesc, srv)
}

func _Consents_GetConsents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsents(ctx, req.(*GetConsentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_GetConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsent(ctx, req.(*GetConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_GetConsentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsentVersion(ctx, req.(*GetConsentVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Consents_ServiceDesc is the grpc.ServiceDesc for Consents service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Consents_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Consents",
	HandlerType: (*ConsentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConsents",
			Handler:    _Consents_GetConsents_Handler,
		},
		{
			MethodName: "GetConsent",
			Handler:    _Consents_GetConsent_Handler,
		},
		{
			MethodName: "GetConsentVersion",
			Handler:    _Consents_GetConsentVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Utilities_Proxy_FullMethodName = "/proto.static.Utilities/Proxy"
)

// UtilitiesClient is the client API for Utilities service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UtilitiesClient interface {
	Proxy(ctx context.Context, in *ProxyRequest, opts ...grpc.CallOption) (*ProxyResponse, error)
}

type utilitiesClient struct {
	cc grpc.ClientConnInterface
}

func NewUtilitiesClient(cc grpc.ClientConnInterface) UtilitiesClient {
	return &utilitiesClient{cc}
}

func (c *utilitiesClient) Proxy(ctx context.Context, in *ProxyRequest, opts ...grpc.CallOption) (*ProxyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProxyResponse)
	err := c.cc.Invoke(ctx, Utilities_Proxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UtilitiesServer is the server API for Utilities service.
// All implementations must embed UnimplementedUtilitiesServer
// for forward compatibility.
type UtilitiesServer interface {
	Proxy(context.Context, *ProxyRequest) (*ProxyResponse, error)
	mustEmbedUnimplementedUtilitiesServer()
}

// UnimplementedUtilitiesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUtilitiesServer struct{}

func (UnimplementedUtilitiesServer) Proxy(context.Context, *ProxyRequest) (*ProxyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Proxy not implemented")
}
func (UnimplementedUtilitiesServer) mustEmbedUnimplementedUtilitiesServer() {}
func (UnimplementedUtilitiesServer) testEmbeddedByValue()                   {}

// UnsafeUtilitiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UtilitiesServer will
// result in compilation errors.
type UnsafeUtilitiesServer interface {
	mustEmbedUnimplementedUtilitiesServer()
}

func RegisterUtilitiesServer(s grpc.ServiceRegistrar, srv UtilitiesServer) {
	// If the following call pancis, it indicates UnimplementedUtilitiesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Utilities_ServiceDesc, srv)
}

func _Utilities_Proxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilitiesServer).Proxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utilities_Proxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilitiesServer).Proxy(ctx, req.(*ProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Utilities_ServiceDesc is the grpc.ServiceDesc for Utilities service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Utilities_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Utilities",
	HandlerType: (*UtilitiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Proxy",
			Handler:    _Utilities_Proxy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Images_GetImage_FullMethodName = "/proto.static.Images/GetImage"
)

// ImagesClient is the client API for Images service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImagesClient interface {
	GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error)
}

type imagesClient struct {
	cc grpc.ClientConnInterface
}

func NewImagesClient(cc grpc.ClientConnInterface) ImagesClient {
	return &imagesClient{cc}
}

func (c *imagesClient) GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(httpbody.HttpBody)
	err := c.cc.Invoke(ctx, Images_GetImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImagesServer is the server API for Images service.
// All implementations must embed UnimplementedImagesServer
// for forward compatibility.
type ImagesServer interface {
	GetImage(context.Context, *GetImageRequest) (*httpbody.HttpBody, error)
	mustEmbedUnimplementedImagesServer()
}

// UnimplementedImagesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImagesServer struct{}

func (UnimplementedImagesServer) GetImage(context.Context, *GetImageRequest) (*httpbody.HttpBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImage not implemented")
}
func (UnimplementedImagesServer) mustEmbedUnimplementedImagesServer() {}
func (UnimplementedImagesServer) testEmbeddedByValue()                {}

// UnsafeImagesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImagesServer will
// result in compilation errors.
type UnsafeImagesServer interface {
	mustEmbedUnimplementedImagesServer()
}

func RegisterImagesServer(s grpc.ServiceRegistrar, srv ImagesServer) {
	// If the following call pancis, it indicates UnimplementedImagesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Images_ServiceDesc, srv)
}

func _Images_GetImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_GetImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetImage(ctx, req.(*GetImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Images_ServiceDesc is the grpc.ServiceDesc for Images service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Images_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Images",
	HandlerType: (*ImagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetImage",
			Handler:    _Images_GetImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Checks_Liveness_FullMethodName  = "/proto.static.Checks/Liveness"
	Checks_Readiness_FullMethodName = "/proto.static.Checks/Readiness"
)

// ChecksClient is the client API for Checks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChecksClient interface {
	Liveness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error)
	Readiness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error)
}

type checksClient struct {
	cc grpc.ClientConnInterface
}

func NewChecksClient(cc grpc.ClientConnInterface) ChecksClient {
	return &checksClient{cc}
}

func (c *checksClient) Liveness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChecksResponse)
	err := c.cc.Invoke(ctx, Checks_Liveness_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checksClient) Readiness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChecksResponse)
	err := c.cc.Invoke(ctx, Checks_Readiness_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChecksServer is the server API for Checks service.
// All implementations must embed UnimplementedChecksServer
// for forward compatibility.
type ChecksServer interface {
	Liveness(context.Context, *ChecksRequest) (*ChecksResponse, error)
	Readiness(context.Context, *ChecksRequest) (*ChecksResponse, error)
	mustEmbedUnimplementedChecksServer()
}

// UnimplementedChecksServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChecksServer struct{}

func (UnimplementedChecksServer) Liveness(context.Context, *ChecksRequest) (*ChecksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Liveness not implemented")
}
func (UnimplementedChecksServer) Readiness(context.Context, *ChecksRequest) (*ChecksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Readiness not implemented")
}
func (UnimplementedChecksServer) mustEmbedUnimplementedChecksServer() {}
func (UnimplementedChecksServer) testEmbeddedByValue()                {}

// UnsafeChecksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChecksServer will
// result in compilation errors.
type UnsafeChecksServer interface {
	mustEmbedUnimplementedChecksServer()
}

func RegisterChecksServer(s grpc.ServiceRegistrar, srv ChecksServer) {
	// If the following call pancis, it indicates UnimplementedChecksServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Checks_ServiceDesc, srv)
}

func _Checks_Liveness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).Liveness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Checks_Liveness_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).Liveness(ctx, req.(*ChecksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Checks_Readiness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).Readiness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Checks_Readiness_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).Readiness(ctx, req.(*ChecksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Checks_ServiceDesc is the grpc.ServiceDesc for Checks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Checks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Checks",
	HandlerType: (*ChecksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Liveness",
			Handler:    _Checks_Liveness_Handler,
		},
		{
			MethodName: "Readiness",
			Handler:    _Checks_Readiness_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}
