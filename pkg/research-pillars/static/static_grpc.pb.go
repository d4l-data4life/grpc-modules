// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: research-pillars/static/static.proto

package static

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Programs_GetPrograms_FullMethodName         = "/proto.static.Programs/GetPrograms"
	Programs_GetProgram_FullMethodName          = "/proto.static.Programs/GetProgram"
	Programs_GetProgramData_FullMethodName      = "/proto.static.Programs/GetProgramData"
	Programs_GetProgramUpdatedAt_FullMethodName = "/proto.static.Programs/GetProgramUpdatedAt"
)

// ProgramsClient is the client API for Programs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProgramsClient interface {
	GetPrograms(ctx context.Context, in *GetProgramsRequest, opts ...grpc.CallOption) (*GetProgramsResponse, error)
	GetProgram(ctx context.Context, in *GetProgramRequest, opts ...grpc.CallOption) (*GetProgramResponse, error)
	GetProgramData(ctx context.Context, in *GetProgramDataRequest, opts ...grpc.CallOption) (*GetProgramDataResponse, error)
	GetProgramUpdatedAt(ctx context.Context, in *GetProgramUpdatedAtRequest, opts ...grpc.CallOption) (*GetProgramUpdatedAtResponse, error)
}

type programsClient struct {
	cc grpc.ClientConnInterface
}

func NewProgramsClient(cc grpc.ClientConnInterface) ProgramsClient {
	return &programsClient{cc}
}

func (c *programsClient) GetPrograms(ctx context.Context, in *GetProgramsRequest, opts ...grpc.CallOption) (*GetProgramsResponse, error) {
	out := new(GetProgramsResponse)
	err := c.cc.Invoke(ctx, Programs_GetPrograms_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgram(ctx context.Context, in *GetProgramRequest, opts ...grpc.CallOption) (*GetProgramResponse, error) {
	out := new(GetProgramResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgram_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgramData(ctx context.Context, in *GetProgramDataRequest, opts ...grpc.CallOption) (*GetProgramDataResponse, error) {
	out := new(GetProgramDataResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgramData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgramUpdatedAt(ctx context.Context, in *GetProgramUpdatedAtRequest, opts ...grpc.CallOption) (*GetProgramUpdatedAtResponse, error) {
	out := new(GetProgramUpdatedAtResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgramUpdatedAt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProgramsServer is the server API for Programs service.
// All implementations must embed UnimplementedProgramsServer
// for forward compatibility
type ProgramsServer interface {
	GetPrograms(context.Context, *GetProgramsRequest) (*GetProgramsResponse, error)
	GetProgram(context.Context, *GetProgramRequest) (*GetProgramResponse, error)
	GetProgramData(context.Context, *GetProgramDataRequest) (*GetProgramDataResponse, error)
	GetProgramUpdatedAt(context.Context, *GetProgramUpdatedAtRequest) (*GetProgramUpdatedAtResponse, error)
	mustEmbedUnimplementedProgramsServer()
}

// UnimplementedProgramsServer must be embedded to have forward compatible implementations.
type UnimplementedProgramsServer struct {
}

func (UnimplementedProgramsServer) GetPrograms(context.Context, *GetProgramsRequest) (*GetProgramsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrograms not implemented")
}
func (UnimplementedProgramsServer) GetProgram(context.Context, *GetProgramRequest) (*GetProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgram not implemented")
}
func (UnimplementedProgramsServer) GetProgramData(context.Context, *GetProgramDataRequest) (*GetProgramDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramData not implemented")
}
func (UnimplementedProgramsServer) GetProgramUpdatedAt(context.Context, *GetProgramUpdatedAtRequest) (*GetProgramUpdatedAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramUpdatedAt not implemented")
}
func (UnimplementedProgramsServer) mustEmbedUnimplementedProgramsServer() {}

// UnsafeProgramsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProgramsServer will
// result in compilation errors.
type UnsafeProgramsServer interface {
	mustEmbedUnimplementedProgramsServer()
}

func RegisterProgramsServer(s grpc.ServiceRegistrar, srv ProgramsServer) {
	s.RegisterService(&Programs_ServiceDesc, srv)
}

func _Programs_GetPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetPrograms(ctx, req.(*GetProgramsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgram(ctx, req.(*GetProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgramData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgramData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgramData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgramData(ctx, req.(*GetProgramDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgramUpdatedAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramUpdatedAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgramUpdatedAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgramUpdatedAt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgramUpdatedAt(ctx, req.(*GetProgramUpdatedAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Programs_ServiceDesc is the grpc.ServiceDesc for Programs service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Programs_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Programs",
	HandlerType: (*ProgramsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrograms",
			Handler:    _Programs_GetPrograms_Handler,
		},
		{
			MethodName: "GetProgram",
			Handler:    _Programs_GetProgram_Handler,
		},
		{
			MethodName: "GetProgramData",
			Handler:    _Programs_GetProgramData_Handler,
		},
		{
			MethodName: "GetProgramUpdatedAt",
			Handler:    _Programs_GetProgramUpdatedAt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Surveys_GetSurveys_FullMethodName = "/proto.static.Surveys/GetSurveys"
	Surveys_GetSurvey_FullMethodName  = "/proto.static.Surveys/GetSurvey"
)

// SurveysClient is the client API for Surveys service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SurveysClient interface {
	GetSurveys(ctx context.Context, in *GetSurveysRequest, opts ...grpc.CallOption) (*GetSurveysResponse, error)
	GetSurvey(ctx context.Context, in *GetSurveyRequest, opts ...grpc.CallOption) (*GetSurveyResponse, error)
}

type surveysClient struct {
	cc grpc.ClientConnInterface
}

func NewSurveysClient(cc grpc.ClientConnInterface) SurveysClient {
	return &surveysClient{cc}
}

func (c *surveysClient) GetSurveys(ctx context.Context, in *GetSurveysRequest, opts ...grpc.CallOption) (*GetSurveysResponse, error) {
	out := new(GetSurveysResponse)
	err := c.cc.Invoke(ctx, Surveys_GetSurveys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *surveysClient) GetSurvey(ctx context.Context, in *GetSurveyRequest, opts ...grpc.CallOption) (*GetSurveyResponse, error) {
	out := new(GetSurveyResponse)
	err := c.cc.Invoke(ctx, Surveys_GetSurvey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SurveysServer is the server API for Surveys service.
// All implementations must embed UnimplementedSurveysServer
// for forward compatibility
type SurveysServer interface {
	GetSurveys(context.Context, *GetSurveysRequest) (*GetSurveysResponse, error)
	GetSurvey(context.Context, *GetSurveyRequest) (*GetSurveyResponse, error)
	mustEmbedUnimplementedSurveysServer()
}

// UnimplementedSurveysServer must be embedded to have forward compatible implementations.
type UnimplementedSurveysServer struct {
}

func (UnimplementedSurveysServer) GetSurveys(context.Context, *GetSurveysRequest) (*GetSurveysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSurveys not implemented")
}
func (UnimplementedSurveysServer) GetSurvey(context.Context, *GetSurveyRequest) (*GetSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSurvey not implemented")
}
func (UnimplementedSurveysServer) mustEmbedUnimplementedSurveysServer() {}

// UnsafeSurveysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SurveysServer will
// result in compilation errors.
type UnsafeSurveysServer interface {
	mustEmbedUnimplementedSurveysServer()
}

func RegisterSurveysServer(s grpc.ServiceRegistrar, srv SurveysServer) {
	s.RegisterService(&Surveys_ServiceDesc, srv)
}

func _Surveys_GetSurveys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSurveysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).GetSurveys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_GetSurveys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).GetSurveys(ctx, req.(*GetSurveysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Surveys_GetSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).GetSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_GetSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).GetSurvey(ctx, req.(*GetSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Surveys_ServiceDesc is the grpc.ServiceDesc for Surveys service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Surveys_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Surveys",
	HandlerType: (*SurveysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSurveys",
			Handler:    _Surveys_GetSurveys_Handler,
		},
		{
			MethodName: "GetSurvey",
			Handler:    _Surveys_GetSurvey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Questionnaires_GetQuestionnaires_FullMethodName = "/proto.static.Questionnaires/GetQuestionnaires"
	Questionnaires_GetQuestionnaire_FullMethodName  = "/proto.static.Questionnaires/GetQuestionnaire"
)

// QuestionnairesClient is the client API for Questionnaires service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuestionnairesClient interface {
	GetQuestionnaires(ctx context.Context, in *GetQuestionnairesRequest, opts ...grpc.CallOption) (*GetQuestionnairesResponse, error)
	GetQuestionnaire(ctx context.Context, in *GetQuestionnaireRequest, opts ...grpc.CallOption) (*GetQuestionnaireResponse, error)
}

type questionnairesClient struct {
	cc grpc.ClientConnInterface
}

func NewQuestionnairesClient(cc grpc.ClientConnInterface) QuestionnairesClient {
	return &questionnairesClient{cc}
}

func (c *questionnairesClient) GetQuestionnaires(ctx context.Context, in *GetQuestionnairesRequest, opts ...grpc.CallOption) (*GetQuestionnairesResponse, error) {
	out := new(GetQuestionnairesResponse)
	err := c.cc.Invoke(ctx, Questionnaires_GetQuestionnaires_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionnairesClient) GetQuestionnaire(ctx context.Context, in *GetQuestionnaireRequest, opts ...grpc.CallOption) (*GetQuestionnaireResponse, error) {
	out := new(GetQuestionnaireResponse)
	err := c.cc.Invoke(ctx, Questionnaires_GetQuestionnaire_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuestionnairesServer is the server API for Questionnaires service.
// All implementations must embed UnimplementedQuestionnairesServer
// for forward compatibility
type QuestionnairesServer interface {
	GetQuestionnaires(context.Context, *GetQuestionnairesRequest) (*GetQuestionnairesResponse, error)
	GetQuestionnaire(context.Context, *GetQuestionnaireRequest) (*GetQuestionnaireResponse, error)
	mustEmbedUnimplementedQuestionnairesServer()
}

// UnimplementedQuestionnairesServer must be embedded to have forward compatible implementations.
type UnimplementedQuestionnairesServer struct {
}

func (UnimplementedQuestionnairesServer) GetQuestionnaires(context.Context, *GetQuestionnairesRequest) (*GetQuestionnairesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionnaires not implemented")
}
func (UnimplementedQuestionnairesServer) GetQuestionnaire(context.Context, *GetQuestionnaireRequest) (*GetQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionnaire not implemented")
}
func (UnimplementedQuestionnairesServer) mustEmbedUnimplementedQuestionnairesServer() {}

// UnsafeQuestionnairesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuestionnairesServer will
// result in compilation errors.
type UnsafeQuestionnairesServer interface {
	mustEmbedUnimplementedQuestionnairesServer()
}

func RegisterQuestionnairesServer(s grpc.ServiceRegistrar, srv QuestionnairesServer) {
	s.RegisterService(&Questionnaires_ServiceDesc, srv)
}

func _Questionnaires_GetQuestionnaires_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionnairesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).GetQuestionnaires(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_GetQuestionnaires_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).GetQuestionnaires(ctx, req.(*GetQuestionnairesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Questionnaires_GetQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).GetQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_GetQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).GetQuestionnaire(ctx, req.(*GetQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Questionnaires_ServiceDesc is the grpc.ServiceDesc for Questionnaires service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Questionnaires_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Questionnaires",
	HandlerType: (*QuestionnairesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetQuestionnaires",
			Handler:    _Questionnaires_GetQuestionnaires_Handler,
		},
		{
			MethodName: "GetQuestionnaire",
			Handler:    _Questionnaires_GetQuestionnaire_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}

const (
	Consents_GetConsents_FullMethodName       = "/proto.static.Consents/GetConsents"
	Consents_GetConsent_FullMethodName        = "/proto.static.Consents/GetConsent"
	Consents_GetConsentVersion_FullMethodName = "/proto.static.Consents/GetConsentVersion"
)

// ConsentsClient is the client API for Consents service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsentsClient interface {
	GetConsents(ctx context.Context, in *GetConsentsRequest, opts ...grpc.CallOption) (*GetConsentsResponse, error)
	GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error)
	GetConsentVersion(ctx context.Context, in *GetConsentVersionRequest, opts ...grpc.CallOption) (*GetConsentVersionResponse, error)
}

type consentsClient struct {
	cc grpc.ClientConnInterface
}

func NewConsentsClient(cc grpc.ClientConnInterface) ConsentsClient {
	return &consentsClient{cc}
}

func (c *consentsClient) GetConsents(ctx context.Context, in *GetConsentsRequest, opts ...grpc.CallOption) (*GetConsentsResponse, error) {
	out := new(GetConsentsResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsents_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error) {
	out := new(GetConsentResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) GetConsentVersion(ctx context.Context, in *GetConsentVersionRequest, opts ...grpc.CallOption) (*GetConsentVersionResponse, error) {
	out := new(GetConsentVersionResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsentVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsentsServer is the server API for Consents service.
// All implementations must embed UnimplementedConsentsServer
// for forward compatibility
type ConsentsServer interface {
	GetConsents(context.Context, *GetConsentsRequest) (*GetConsentsResponse, error)
	GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error)
	GetConsentVersion(context.Context, *GetConsentVersionRequest) (*GetConsentVersionResponse, error)
	mustEmbedUnimplementedConsentsServer()
}

// UnimplementedConsentsServer must be embedded to have forward compatible implementations.
type UnimplementedConsentsServer struct {
}

func (UnimplementedConsentsServer) GetConsents(context.Context, *GetConsentsRequest) (*GetConsentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsents not implemented")
}
func (UnimplementedConsentsServer) GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsent not implemented")
}
func (UnimplementedConsentsServer) GetConsentVersion(context.Context, *GetConsentVersionRequest) (*GetConsentVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsentVersion not implemented")
}
func (UnimplementedConsentsServer) mustEmbedUnimplementedConsentsServer() {}

// UnsafeConsentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsentsServer will
// result in compilation errors.
type UnsafeConsentsServer interface {
	mustEmbedUnimplementedConsentsServer()
}

func RegisterConsentsServer(s grpc.ServiceRegistrar, srv ConsentsServer) {
	s.RegisterService(&Consents_ServiceDesc, srv)
}

func _Consents_GetConsents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsents(ctx, req.(*GetConsentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_GetConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsent(ctx, req.(*GetConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_GetConsentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsentVersion(ctx, req.(*GetConsentVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Consents_ServiceDesc is the grpc.ServiceDesc for Consents service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Consents_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.static.Consents",
	HandlerType: (*ConsentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConsents",
			Handler:    _Consents_GetConsents_Handler,
		},
		{
			MethodName: "GetConsent",
			Handler:    _Consents_GetConsent_Handler,
		},
		{
			MethodName: "GetConsentVersion",
			Handler:    _Consents_GetConsentVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/static/static.proto",
}
