// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.4
// source: research-pillars/api/api.proto

package api

import (
	context "context"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Users_GetSelf_FullMethodName            = "/proto.api.Users/GetSelf"
	Users_GetUsers_FullMethodName           = "/proto.api.Users/GetUsers"
	Users_DeleteUser_FullMethodName         = "/proto.api.Users/DeleteUser"
	Users_UpsertProgramRole_FullMethodName  = "/proto.api.Users/UpsertProgramRole"
	Users_DeleteProgramRole_FullMethodName  = "/proto.api.Users/DeleteProgramRole"
	Users_GetBlockedPrograms_FullMethodName = "/proto.api.Users/GetBlockedPrograms"
	Users_BlockProgram_FullMethodName       = "/proto.api.Users/BlockProgram"
	Users_UnblockProgram_FullMethodName     = "/proto.api.Users/UnblockProgram"
)

// UsersClient is the client API for Users service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UsersClient interface {
	GetSelf(ctx context.Context, in *GetSelfRequest, opts ...grpc.CallOption) (*GetSelfResponse, error)
	GetUsers(ctx context.Context, in *GetUsersRequest, opts ...grpc.CallOption) (*GetUsersResponse, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	UpsertProgramRole(ctx context.Context, in *UpsertProgramRoleRequest, opts ...grpc.CallOption) (*UpsertProgramRoleResponse, error)
	DeleteProgramRole(ctx context.Context, in *DeleteProgramRoleRequest, opts ...grpc.CallOption) (*DeleteProgramRoleResponse, error)
	GetBlockedPrograms(ctx context.Context, in *GetBlockedProgramsRequest, opts ...grpc.CallOption) (*GetBlockedProgramsResponse, error)
	BlockProgram(ctx context.Context, in *BlockProgramRequest, opts ...grpc.CallOption) (*BlockProgramResponse, error)
	UnblockProgram(ctx context.Context, in *UnblockProgramRequest, opts ...grpc.CallOption) (*UnblockProgramResponse, error)
}

type usersClient struct {
	cc grpc.ClientConnInterface
}

func NewUsersClient(cc grpc.ClientConnInterface) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) GetSelf(ctx context.Context, in *GetSelfRequest, opts ...grpc.CallOption) (*GetSelfResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSelfResponse)
	err := c.cc.Invoke(ctx, Users_GetSelf_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetUsers(ctx context.Context, in *GetUsersRequest, opts ...grpc.CallOption) (*GetUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsersResponse)
	err := c.cc.Invoke(ctx, Users_GetUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, Users_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UpsertProgramRole(ctx context.Context, in *UpsertProgramRoleRequest, opts ...grpc.CallOption) (*UpsertProgramRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertProgramRoleResponse)
	err := c.cc.Invoke(ctx, Users_UpsertProgramRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) DeleteProgramRole(ctx context.Context, in *DeleteProgramRoleRequest, opts ...grpc.CallOption) (*DeleteProgramRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProgramRoleResponse)
	err := c.cc.Invoke(ctx, Users_DeleteProgramRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetBlockedPrograms(ctx context.Context, in *GetBlockedProgramsRequest, opts ...grpc.CallOption) (*GetBlockedProgramsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockedProgramsResponse)
	err := c.cc.Invoke(ctx, Users_GetBlockedPrograms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) BlockProgram(ctx context.Context, in *BlockProgramRequest, opts ...grpc.CallOption) (*BlockProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockProgramResponse)
	err := c.cc.Invoke(ctx, Users_BlockProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UnblockProgram(ctx context.Context, in *UnblockProgramRequest, opts ...grpc.CallOption) (*UnblockProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnblockProgramResponse)
	err := c.cc.Invoke(ctx, Users_UnblockProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsersServer is the server API for Users service.
// All implementations must embed UnimplementedUsersServer
// for forward compatibility.
type UsersServer interface {
	GetSelf(context.Context, *GetSelfRequest) (*GetSelfResponse, error)
	GetUsers(context.Context, *GetUsersRequest) (*GetUsersResponse, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	UpsertProgramRole(context.Context, *UpsertProgramRoleRequest) (*UpsertProgramRoleResponse, error)
	DeleteProgramRole(context.Context, *DeleteProgramRoleRequest) (*DeleteProgramRoleResponse, error)
	GetBlockedPrograms(context.Context, *GetBlockedProgramsRequest) (*GetBlockedProgramsResponse, error)
	BlockProgram(context.Context, *BlockProgramRequest) (*BlockProgramResponse, error)
	UnblockProgram(context.Context, *UnblockProgramRequest) (*UnblockProgramResponse, error)
	mustEmbedUnimplementedUsersServer()
}

// UnimplementedUsersServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUsersServer struct{}

func (UnimplementedUsersServer) GetSelf(context.Context, *GetSelfRequest) (*GetSelfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSelf not implemented")
}
func (UnimplementedUsersServer) GetUsers(context.Context, *GetUsersRequest) (*GetUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedUsersServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUsersServer) UpsertProgramRole(context.Context, *UpsertProgramRoleRequest) (*UpsertProgramRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertProgramRole not implemented")
}
func (UnimplementedUsersServer) DeleteProgramRole(context.Context, *DeleteProgramRoleRequest) (*DeleteProgramRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProgramRole not implemented")
}
func (UnimplementedUsersServer) GetBlockedPrograms(context.Context, *GetBlockedProgramsRequest) (*GetBlockedProgramsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockedPrograms not implemented")
}
func (UnimplementedUsersServer) BlockProgram(context.Context, *BlockProgramRequest) (*BlockProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockProgram not implemented")
}
func (UnimplementedUsersServer) UnblockProgram(context.Context, *UnblockProgramRequest) (*UnblockProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnblockProgram not implemented")
}
func (UnimplementedUsersServer) mustEmbedUnimplementedUsersServer() {}
func (UnimplementedUsersServer) testEmbeddedByValue()               {}

// UnsafeUsersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsersServer will
// result in compilation errors.
type UnsafeUsersServer interface {
	mustEmbedUnimplementedUsersServer()
}

func RegisterUsersServer(s grpc.ServiceRegistrar, srv UsersServer) {
	// If the following call pancis, it indicates UnimplementedUsersServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Users_ServiceDesc, srv)
}

func _Users_GetSelf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSelfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetSelf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetSelf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetSelf(ctx, req.(*GetSelfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetUsers(ctx, req.(*GetUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UpsertProgramRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertProgramRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UpsertProgramRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_UpsertProgramRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UpsertProgramRole(ctx, req.(*UpsertProgramRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_DeleteProgramRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProgramRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).DeleteProgramRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_DeleteProgramRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).DeleteProgramRole(ctx, req.(*DeleteProgramRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetBlockedPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockedProgramsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetBlockedPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetBlockedPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetBlockedPrograms(ctx, req.(*GetBlockedProgramsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_BlockProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).BlockProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_BlockProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).BlockProgram(ctx, req.(*BlockProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UnblockProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnblockProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UnblockProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_UnblockProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UnblockProgram(ctx, req.(*UnblockProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Users_ServiceDesc is the grpc.ServiceDesc for Users service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Users_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSelf",
			Handler:    _Users_GetSelf_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _Users_GetUsers_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _Users_DeleteUser_Handler,
		},
		{
			MethodName: "UpsertProgramRole",
			Handler:    _Users_UpsertProgramRole_Handler,
		},
		{
			MethodName: "DeleteProgramRole",
			Handler:    _Users_DeleteProgramRole_Handler,
		},
		{
			MethodName: "GetBlockedPrograms",
			Handler:    _Users_GetBlockedPrograms_Handler,
		},
		{
			MethodName: "BlockProgram",
			Handler:    _Users_BlockProgram_Handler,
		},
		{
			MethodName: "UnblockProgram",
			Handler:    _Users_UnblockProgram_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Programs_GetPrograms_FullMethodName     = "/proto.api.Programs/GetPrograms"
	Programs_GetProgramsList_FullMethodName = "/proto.api.Programs/GetProgramsList"
	Programs_IsNameAvailable_FullMethodName = "/proto.api.Programs/IsNameAvailable"
	Programs_GetProgram_FullMethodName      = "/proto.api.Programs/GetProgram"
	Programs_GetProgramData_FullMethodName  = "/proto.api.Programs/GetProgramData"
	Programs_GetProgramDiffs_FullMethodName = "/proto.api.Programs/GetProgramDiffs"
	Programs_UpsertProgram_FullMethodName   = "/proto.api.Programs/UpsertProgram"
	Programs_DeleteProgram_FullMethodName   = "/proto.api.Programs/DeleteProgram"
	Programs_PublishProgram_FullMethodName  = "/proto.api.Programs/PublishProgram"
	Programs_LoadProgram_FullMethodName     = "/proto.api.Programs/LoadProgram"
)

// ProgramsClient is the client API for Programs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProgramsClient interface {
	GetPrograms(ctx context.Context, in *GetProgramsRequest, opts ...grpc.CallOption) (*GetProgramsResponse, error)
	GetProgramsList(ctx context.Context, in *GetProgramsListRequest, opts ...grpc.CallOption) (*GetProgramsListResponse, error)
	IsNameAvailable(ctx context.Context, in *IsNameAvailableRequest, opts ...grpc.CallOption) (*IsNameAvailableResponse, error)
	GetProgram(ctx context.Context, in *GetProgramRequest, opts ...grpc.CallOption) (*GetProgramResponse, error)
	GetProgramData(ctx context.Context, in *GetProgramDataRequest, opts ...grpc.CallOption) (*GetProgramDataResponse, error)
	GetProgramDiffs(ctx context.Context, in *GetProgramDiffsRequest, opts ...grpc.CallOption) (*GetProgramDiffsResponse, error)
	UpsertProgram(ctx context.Context, in *UpsertProgramRequest, opts ...grpc.CallOption) (*UpsertProgramResponse, error)
	DeleteProgram(ctx context.Context, in *DeleteProgramRequest, opts ...grpc.CallOption) (*DeleteProgramResponse, error)
	PublishProgram(ctx context.Context, in *PublishProgramRequest, opts ...grpc.CallOption) (*PublishProgramResponse, error)
	LoadProgram(ctx context.Context, in *LoadProgramRequest, opts ...grpc.CallOption) (*LoadProgramResponse, error)
}

type programsClient struct {
	cc grpc.ClientConnInterface
}

func NewProgramsClient(cc grpc.ClientConnInterface) ProgramsClient {
	return &programsClient{cc}
}

func (c *programsClient) GetPrograms(ctx context.Context, in *GetProgramsRequest, opts ...grpc.CallOption) (*GetProgramsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramsResponse)
	err := c.cc.Invoke(ctx, Programs_GetPrograms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgramsList(ctx context.Context, in *GetProgramsListRequest, opts ...grpc.CallOption) (*GetProgramsListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramsListResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgramsList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) IsNameAvailable(ctx context.Context, in *IsNameAvailableRequest, opts ...grpc.CallOption) (*IsNameAvailableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsNameAvailableResponse)
	err := c.cc.Invoke(ctx, Programs_IsNameAvailable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgram(ctx context.Context, in *GetProgramRequest, opts ...grpc.CallOption) (*GetProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgramData(ctx context.Context, in *GetProgramDataRequest, opts ...grpc.CallOption) (*GetProgramDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramDataResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgramData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) GetProgramDiffs(ctx context.Context, in *GetProgramDiffsRequest, opts ...grpc.CallOption) (*GetProgramDiffsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramDiffsResponse)
	err := c.cc.Invoke(ctx, Programs_GetProgramDiffs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) UpsertProgram(ctx context.Context, in *UpsertProgramRequest, opts ...grpc.CallOption) (*UpsertProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertProgramResponse)
	err := c.cc.Invoke(ctx, Programs_UpsertProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) DeleteProgram(ctx context.Context, in *DeleteProgramRequest, opts ...grpc.CallOption) (*DeleteProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProgramResponse)
	err := c.cc.Invoke(ctx, Programs_DeleteProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) PublishProgram(ctx context.Context, in *PublishProgramRequest, opts ...grpc.CallOption) (*PublishProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishProgramResponse)
	err := c.cc.Invoke(ctx, Programs_PublishProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programsClient) LoadProgram(ctx context.Context, in *LoadProgramRequest, opts ...grpc.CallOption) (*LoadProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadProgramResponse)
	err := c.cc.Invoke(ctx, Programs_LoadProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProgramsServer is the server API for Programs service.
// All implementations must embed UnimplementedProgramsServer
// for forward compatibility.
type ProgramsServer interface {
	GetPrograms(context.Context, *GetProgramsRequest) (*GetProgramsResponse, error)
	GetProgramsList(context.Context, *GetProgramsListRequest) (*GetProgramsListResponse, error)
	IsNameAvailable(context.Context, *IsNameAvailableRequest) (*IsNameAvailableResponse, error)
	GetProgram(context.Context, *GetProgramRequest) (*GetProgramResponse, error)
	GetProgramData(context.Context, *GetProgramDataRequest) (*GetProgramDataResponse, error)
	GetProgramDiffs(context.Context, *GetProgramDiffsRequest) (*GetProgramDiffsResponse, error)
	UpsertProgram(context.Context, *UpsertProgramRequest) (*UpsertProgramResponse, error)
	DeleteProgram(context.Context, *DeleteProgramRequest) (*DeleteProgramResponse, error)
	PublishProgram(context.Context, *PublishProgramRequest) (*PublishProgramResponse, error)
	LoadProgram(context.Context, *LoadProgramRequest) (*LoadProgramResponse, error)
	mustEmbedUnimplementedProgramsServer()
}

// UnimplementedProgramsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProgramsServer struct{}

func (UnimplementedProgramsServer) GetPrograms(context.Context, *GetProgramsRequest) (*GetProgramsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrograms not implemented")
}
func (UnimplementedProgramsServer) GetProgramsList(context.Context, *GetProgramsListRequest) (*GetProgramsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramsList not implemented")
}
func (UnimplementedProgramsServer) IsNameAvailable(context.Context, *IsNameAvailableRequest) (*IsNameAvailableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsNameAvailable not implemented")
}
func (UnimplementedProgramsServer) GetProgram(context.Context, *GetProgramRequest) (*GetProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgram not implemented")
}
func (UnimplementedProgramsServer) GetProgramData(context.Context, *GetProgramDataRequest) (*GetProgramDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramData not implemented")
}
func (UnimplementedProgramsServer) GetProgramDiffs(context.Context, *GetProgramDiffsRequest) (*GetProgramDiffsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramDiffs not implemented")
}
func (UnimplementedProgramsServer) UpsertProgram(context.Context, *UpsertProgramRequest) (*UpsertProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertProgram not implemented")
}
func (UnimplementedProgramsServer) DeleteProgram(context.Context, *DeleteProgramRequest) (*DeleteProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProgram not implemented")
}
func (UnimplementedProgramsServer) PublishProgram(context.Context, *PublishProgramRequest) (*PublishProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishProgram not implemented")
}
func (UnimplementedProgramsServer) LoadProgram(context.Context, *LoadProgramRequest) (*LoadProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadProgram not implemented")
}
func (UnimplementedProgramsServer) mustEmbedUnimplementedProgramsServer() {}
func (UnimplementedProgramsServer) testEmbeddedByValue()                  {}

// UnsafeProgramsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProgramsServer will
// result in compilation errors.
type UnsafeProgramsServer interface {
	mustEmbedUnimplementedProgramsServer()
}

func RegisterProgramsServer(s grpc.ServiceRegistrar, srv ProgramsServer) {
	// If the following call pancis, it indicates UnimplementedProgramsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Programs_ServiceDesc, srv)
}

func _Programs_GetPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetPrograms(ctx, req.(*GetProgramsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgramsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramsListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgramsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgramsList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgramsList(ctx, req.(*GetProgramsListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_IsNameAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsNameAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).IsNameAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_IsNameAvailable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).IsNameAvailable(ctx, req.(*IsNameAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgram(ctx, req.(*GetProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgramData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgramData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgramData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgramData(ctx, req.(*GetProgramDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_GetProgramDiffs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramDiffsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).GetProgramDiffs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_GetProgramDiffs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).GetProgramDiffs(ctx, req.(*GetProgramDiffsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_UpsertProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).UpsertProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_UpsertProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).UpsertProgram(ctx, req.(*UpsertProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_DeleteProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).DeleteProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_DeleteProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).DeleteProgram(ctx, req.(*DeleteProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_PublishProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).PublishProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_PublishProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).PublishProgram(ctx, req.(*PublishProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Programs_LoadProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramsServer).LoadProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Programs_LoadProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramsServer).LoadProgram(ctx, req.(*LoadProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Programs_ServiceDesc is the grpc.ServiceDesc for Programs service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Programs_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Programs",
	HandlerType: (*ProgramsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrograms",
			Handler:    _Programs_GetPrograms_Handler,
		},
		{
			MethodName: "GetProgramsList",
			Handler:    _Programs_GetProgramsList_Handler,
		},
		{
			MethodName: "IsNameAvailable",
			Handler:    _Programs_IsNameAvailable_Handler,
		},
		{
			MethodName: "GetProgram",
			Handler:    _Programs_GetProgram_Handler,
		},
		{
			MethodName: "GetProgramData",
			Handler:    _Programs_GetProgramData_Handler,
		},
		{
			MethodName: "GetProgramDiffs",
			Handler:    _Programs_GetProgramDiffs_Handler,
		},
		{
			MethodName: "UpsertProgram",
			Handler:    _Programs_UpsertProgram_Handler,
		},
		{
			MethodName: "DeleteProgram",
			Handler:    _Programs_DeleteProgram_Handler,
		},
		{
			MethodName: "PublishProgram",
			Handler:    _Programs_PublishProgram_Handler,
		},
		{
			MethodName: "LoadProgram",
			Handler:    _Programs_LoadProgram_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Surveys_GetSurveys_FullMethodName    = "/proto.api.Surveys/GetSurveys"
	Surveys_GetSurvey_FullMethodName     = "/proto.api.Surveys/GetSurvey"
	Surveys_UpsertSurvey_FullMethodName  = "/proto.api.Surveys/UpsertSurvey"
	Surveys_DeleteSurvey_FullMethodName  = "/proto.api.Surveys/DeleteSurvey"
	Surveys_PublishSurvey_FullMethodName = "/proto.api.Surveys/PublishSurvey"
	Surveys_LoadSurvey_FullMethodName    = "/proto.api.Surveys/LoadSurvey"
)

// SurveysClient is the client API for Surveys service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SurveysClient interface {
	GetSurveys(ctx context.Context, in *GetSurveysRequest, opts ...grpc.CallOption) (*GetSurveysResponse, error)
	GetSurvey(ctx context.Context, in *GetSurveyRequest, opts ...grpc.CallOption) (*GetSurveyResponse, error)
	UpsertSurvey(ctx context.Context, in *UpsertSurveyRequest, opts ...grpc.CallOption) (*UpsertSurveyResponse, error)
	DeleteSurvey(ctx context.Context, in *DeleteSurveyRequest, opts ...grpc.CallOption) (*DeleteSurveyResponse, error)
	PublishSurvey(ctx context.Context, in *PublishSurveyRequest, opts ...grpc.CallOption) (*PublishSurveyResponse, error)
	LoadSurvey(ctx context.Context, in *LoadSurveyRequest, opts ...grpc.CallOption) (*LoadSurveyResponse, error)
}

type surveysClient struct {
	cc grpc.ClientConnInterface
}

func NewSurveysClient(cc grpc.ClientConnInterface) SurveysClient {
	return &surveysClient{cc}
}

func (c *surveysClient) GetSurveys(ctx context.Context, in *GetSurveysRequest, opts ...grpc.CallOption) (*GetSurveysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSurveysResponse)
	err := c.cc.Invoke(ctx, Surveys_GetSurveys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *surveysClient) GetSurvey(ctx context.Context, in *GetSurveyRequest, opts ...grpc.CallOption) (*GetSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSurveyResponse)
	err := c.cc.Invoke(ctx, Surveys_GetSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *surveysClient) UpsertSurvey(ctx context.Context, in *UpsertSurveyRequest, opts ...grpc.CallOption) (*UpsertSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertSurveyResponse)
	err := c.cc.Invoke(ctx, Surveys_UpsertSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *surveysClient) DeleteSurvey(ctx context.Context, in *DeleteSurveyRequest, opts ...grpc.CallOption) (*DeleteSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSurveyResponse)
	err := c.cc.Invoke(ctx, Surveys_DeleteSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *surveysClient) PublishSurvey(ctx context.Context, in *PublishSurveyRequest, opts ...grpc.CallOption) (*PublishSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishSurveyResponse)
	err := c.cc.Invoke(ctx, Surveys_PublishSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *surveysClient) LoadSurvey(ctx context.Context, in *LoadSurveyRequest, opts ...grpc.CallOption) (*LoadSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadSurveyResponse)
	err := c.cc.Invoke(ctx, Surveys_LoadSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SurveysServer is the server API for Surveys service.
// All implementations must embed UnimplementedSurveysServer
// for forward compatibility.
type SurveysServer interface {
	GetSurveys(context.Context, *GetSurveysRequest) (*GetSurveysResponse, error)
	GetSurvey(context.Context, *GetSurveyRequest) (*GetSurveyResponse, error)
	UpsertSurvey(context.Context, *UpsertSurveyRequest) (*UpsertSurveyResponse, error)
	DeleteSurvey(context.Context, *DeleteSurveyRequest) (*DeleteSurveyResponse, error)
	PublishSurvey(context.Context, *PublishSurveyRequest) (*PublishSurveyResponse, error)
	LoadSurvey(context.Context, *LoadSurveyRequest) (*LoadSurveyResponse, error)
	mustEmbedUnimplementedSurveysServer()
}

// UnimplementedSurveysServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSurveysServer struct{}

func (UnimplementedSurveysServer) GetSurveys(context.Context, *GetSurveysRequest) (*GetSurveysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSurveys not implemented")
}
func (UnimplementedSurveysServer) GetSurvey(context.Context, *GetSurveyRequest) (*GetSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSurvey not implemented")
}
func (UnimplementedSurveysServer) UpsertSurvey(context.Context, *UpsertSurveyRequest) (*UpsertSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertSurvey not implemented")
}
func (UnimplementedSurveysServer) DeleteSurvey(context.Context, *DeleteSurveyRequest) (*DeleteSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSurvey not implemented")
}
func (UnimplementedSurveysServer) PublishSurvey(context.Context, *PublishSurveyRequest) (*PublishSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishSurvey not implemented")
}
func (UnimplementedSurveysServer) LoadSurvey(context.Context, *LoadSurveyRequest) (*LoadSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadSurvey not implemented")
}
func (UnimplementedSurveysServer) mustEmbedUnimplementedSurveysServer() {}
func (UnimplementedSurveysServer) testEmbeddedByValue()                 {}

// UnsafeSurveysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SurveysServer will
// result in compilation errors.
type UnsafeSurveysServer interface {
	mustEmbedUnimplementedSurveysServer()
}

func RegisterSurveysServer(s grpc.ServiceRegistrar, srv SurveysServer) {
	// If the following call pancis, it indicates UnimplementedSurveysServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Surveys_ServiceDesc, srv)
}

func _Surveys_GetSurveys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSurveysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).GetSurveys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_GetSurveys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).GetSurveys(ctx, req.(*GetSurveysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Surveys_GetSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).GetSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_GetSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).GetSurvey(ctx, req.(*GetSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Surveys_UpsertSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).UpsertSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_UpsertSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).UpsertSurvey(ctx, req.(*UpsertSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Surveys_DeleteSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).DeleteSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_DeleteSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).DeleteSurvey(ctx, req.(*DeleteSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Surveys_PublishSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).PublishSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_PublishSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).PublishSurvey(ctx, req.(*PublishSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Surveys_LoadSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SurveysServer).LoadSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Surveys_LoadSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SurveysServer).LoadSurvey(ctx, req.(*LoadSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Surveys_ServiceDesc is the grpc.ServiceDesc for Surveys service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Surveys_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Surveys",
	HandlerType: (*SurveysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSurveys",
			Handler:    _Surveys_GetSurveys_Handler,
		},
		{
			MethodName: "GetSurvey",
			Handler:    _Surveys_GetSurvey_Handler,
		},
		{
			MethodName: "UpsertSurvey",
			Handler:    _Surveys_UpsertSurvey_Handler,
		},
		{
			MethodName: "DeleteSurvey",
			Handler:    _Surveys_DeleteSurvey_Handler,
		},
		{
			MethodName: "PublishSurvey",
			Handler:    _Surveys_PublishSurvey_Handler,
		},
		{
			MethodName: "LoadSurvey",
			Handler:    _Surveys_LoadSurvey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Questionnaires_GetQuestionnaires_FullMethodName    = "/proto.api.Questionnaires/GetQuestionnaires"
	Questionnaires_GetQuestionnaire_FullMethodName     = "/proto.api.Questionnaires/GetQuestionnaire"
	Questionnaires_UpsertQuestionnaire_FullMethodName  = "/proto.api.Questionnaires/UpsertQuestionnaire"
	Questionnaires_DeleteQuestionnaire_FullMethodName  = "/proto.api.Questionnaires/DeleteQuestionnaire"
	Questionnaires_PublishQuestionnaire_FullMethodName = "/proto.api.Questionnaires/PublishQuestionnaire"
	Questionnaires_LoadQuestionnaire_FullMethodName    = "/proto.api.Questionnaires/LoadQuestionnaire"
)

// QuestionnairesClient is the client API for Questionnaires service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuestionnairesClient interface {
	GetQuestionnaires(ctx context.Context, in *GetQuestionnairesRequest, opts ...grpc.CallOption) (*GetQuestionnairesResponse, error)
	GetQuestionnaire(ctx context.Context, in *GetQuestionnaireRequest, opts ...grpc.CallOption) (*GetQuestionnaireResponse, error)
	UpsertQuestionnaire(ctx context.Context, in *UpsertQuestionnaireRequest, opts ...grpc.CallOption) (*UpsertQuestionnaireResponse, error)
	DeleteQuestionnaire(ctx context.Context, in *DeleteQuestionnaireRequest, opts ...grpc.CallOption) (*DeleteQuestionnaireResponse, error)
	PublishQuestionnaire(ctx context.Context, in *PublishQuestionnaireRequest, opts ...grpc.CallOption) (*PublishQuestionnaireResponse, error)
	LoadQuestionnaire(ctx context.Context, in *LoadQuestionnaireRequest, opts ...grpc.CallOption) (*LoadQuestionnaireResponse, error)
}

type questionnairesClient struct {
	cc grpc.ClientConnInterface
}

func NewQuestionnairesClient(cc grpc.ClientConnInterface) QuestionnairesClient {
	return &questionnairesClient{cc}
}

func (c *questionnairesClient) GetQuestionnaires(ctx context.Context, in *GetQuestionnairesRequest, opts ...grpc.CallOption) (*GetQuestionnairesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionnairesResponse)
	err := c.cc.Invoke(ctx, Questionnaires_GetQuestionnaires_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionnairesClient) GetQuestionnaire(ctx context.Context, in *GetQuestionnaireRequest, opts ...grpc.CallOption) (*GetQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionnaireResponse)
	err := c.cc.Invoke(ctx, Questionnaires_GetQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionnairesClient) UpsertQuestionnaire(ctx context.Context, in *UpsertQuestionnaireRequest, opts ...grpc.CallOption) (*UpsertQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertQuestionnaireResponse)
	err := c.cc.Invoke(ctx, Questionnaires_UpsertQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionnairesClient) DeleteQuestionnaire(ctx context.Context, in *DeleteQuestionnaireRequest, opts ...grpc.CallOption) (*DeleteQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteQuestionnaireResponse)
	err := c.cc.Invoke(ctx, Questionnaires_DeleteQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionnairesClient) PublishQuestionnaire(ctx context.Context, in *PublishQuestionnaireRequest, opts ...grpc.CallOption) (*PublishQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishQuestionnaireResponse)
	err := c.cc.Invoke(ctx, Questionnaires_PublishQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionnairesClient) LoadQuestionnaire(ctx context.Context, in *LoadQuestionnaireRequest, opts ...grpc.CallOption) (*LoadQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadQuestionnaireResponse)
	err := c.cc.Invoke(ctx, Questionnaires_LoadQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuestionnairesServer is the server API for Questionnaires service.
// All implementations must embed UnimplementedQuestionnairesServer
// for forward compatibility.
type QuestionnairesServer interface {
	GetQuestionnaires(context.Context, *GetQuestionnairesRequest) (*GetQuestionnairesResponse, error)
	GetQuestionnaire(context.Context, *GetQuestionnaireRequest) (*GetQuestionnaireResponse, error)
	UpsertQuestionnaire(context.Context, *UpsertQuestionnaireRequest) (*UpsertQuestionnaireResponse, error)
	DeleteQuestionnaire(context.Context, *DeleteQuestionnaireRequest) (*DeleteQuestionnaireResponse, error)
	PublishQuestionnaire(context.Context, *PublishQuestionnaireRequest) (*PublishQuestionnaireResponse, error)
	LoadQuestionnaire(context.Context, *LoadQuestionnaireRequest) (*LoadQuestionnaireResponse, error)
	mustEmbedUnimplementedQuestionnairesServer()
}

// UnimplementedQuestionnairesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQuestionnairesServer struct{}

func (UnimplementedQuestionnairesServer) GetQuestionnaires(context.Context, *GetQuestionnairesRequest) (*GetQuestionnairesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionnaires not implemented")
}
func (UnimplementedQuestionnairesServer) GetQuestionnaire(context.Context, *GetQuestionnaireRequest) (*GetQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionnaire not implemented")
}
func (UnimplementedQuestionnairesServer) UpsertQuestionnaire(context.Context, *UpsertQuestionnaireRequest) (*UpsertQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertQuestionnaire not implemented")
}
func (UnimplementedQuestionnairesServer) DeleteQuestionnaire(context.Context, *DeleteQuestionnaireRequest) (*DeleteQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuestionnaire not implemented")
}
func (UnimplementedQuestionnairesServer) PublishQuestionnaire(context.Context, *PublishQuestionnaireRequest) (*PublishQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishQuestionnaire not implemented")
}
func (UnimplementedQuestionnairesServer) LoadQuestionnaire(context.Context, *LoadQuestionnaireRequest) (*LoadQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadQuestionnaire not implemented")
}
func (UnimplementedQuestionnairesServer) mustEmbedUnimplementedQuestionnairesServer() {}
func (UnimplementedQuestionnairesServer) testEmbeddedByValue()                        {}

// UnsafeQuestionnairesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuestionnairesServer will
// result in compilation errors.
type UnsafeQuestionnairesServer interface {
	mustEmbedUnimplementedQuestionnairesServer()
}

func RegisterQuestionnairesServer(s grpc.ServiceRegistrar, srv QuestionnairesServer) {
	// If the following call pancis, it indicates UnimplementedQuestionnairesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Questionnaires_ServiceDesc, srv)
}

func _Questionnaires_GetQuestionnaires_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionnairesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).GetQuestionnaires(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_GetQuestionnaires_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).GetQuestionnaires(ctx, req.(*GetQuestionnairesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Questionnaires_GetQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).GetQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_GetQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).GetQuestionnaire(ctx, req.(*GetQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Questionnaires_UpsertQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).UpsertQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_UpsertQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).UpsertQuestionnaire(ctx, req.(*UpsertQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Questionnaires_DeleteQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).DeleteQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_DeleteQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).DeleteQuestionnaire(ctx, req.(*DeleteQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Questionnaires_PublishQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).PublishQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_PublishQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).PublishQuestionnaire(ctx, req.(*PublishQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Questionnaires_LoadQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionnairesServer).LoadQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Questionnaires_LoadQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionnairesServer).LoadQuestionnaire(ctx, req.(*LoadQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Questionnaires_ServiceDesc is the grpc.ServiceDesc for Questionnaires service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Questionnaires_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Questionnaires",
	HandlerType: (*QuestionnairesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetQuestionnaires",
			Handler:    _Questionnaires_GetQuestionnaires_Handler,
		},
		{
			MethodName: "GetQuestionnaire",
			Handler:    _Questionnaires_GetQuestionnaire_Handler,
		},
		{
			MethodName: "UpsertQuestionnaire",
			Handler:    _Questionnaires_UpsertQuestionnaire_Handler,
		},
		{
			MethodName: "DeleteQuestionnaire",
			Handler:    _Questionnaires_DeleteQuestionnaire_Handler,
		},
		{
			MethodName: "PublishQuestionnaire",
			Handler:    _Questionnaires_PublishQuestionnaire_Handler,
		},
		{
			MethodName: "LoadQuestionnaire",
			Handler:    _Questionnaires_LoadQuestionnaire_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Routines_GetRoutines_FullMethodName    = "/proto.api.Routines/GetRoutines"
	Routines_GetRoutine_FullMethodName     = "/proto.api.Routines/GetRoutine"
	Routines_UpsertRoutine_FullMethodName  = "/proto.api.Routines/UpsertRoutine"
	Routines_DeleteRoutine_FullMethodName  = "/proto.api.Routines/DeleteRoutine"
	Routines_PublishRoutine_FullMethodName = "/proto.api.Routines/PublishRoutine"
	Routines_LoadRoutine_FullMethodName    = "/proto.api.Routines/LoadRoutine"
)

// RoutinesClient is the client API for Routines service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutinesClient interface {
	GetRoutines(ctx context.Context, in *GetRoutinesRequest, opts ...grpc.CallOption) (*GetRoutinesResponse, error)
	GetRoutine(ctx context.Context, in *GetRoutineRequest, opts ...grpc.CallOption) (*GetRoutineResponse, error)
	UpsertRoutine(ctx context.Context, in *UpsertRoutineRequest, opts ...grpc.CallOption) (*UpsertRoutineResponse, error)
	DeleteRoutine(ctx context.Context, in *DeleteRoutineRequest, opts ...grpc.CallOption) (*DeleteRoutineResponse, error)
	PublishRoutine(ctx context.Context, in *PublishRoutineRequest, opts ...grpc.CallOption) (*PublishRoutineResponse, error)
	LoadRoutine(ctx context.Context, in *LoadRoutineRequest, opts ...grpc.CallOption) (*LoadRoutineResponse, error)
}

type routinesClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutinesClient(cc grpc.ClientConnInterface) RoutinesClient {
	return &routinesClient{cc}
}

func (c *routinesClient) GetRoutines(ctx context.Context, in *GetRoutinesRequest, opts ...grpc.CallOption) (*GetRoutinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoutinesResponse)
	err := c.cc.Invoke(ctx, Routines_GetRoutines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routinesClient) GetRoutine(ctx context.Context, in *GetRoutineRequest, opts ...grpc.CallOption) (*GetRoutineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoutineResponse)
	err := c.cc.Invoke(ctx, Routines_GetRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routinesClient) UpsertRoutine(ctx context.Context, in *UpsertRoutineRequest, opts ...grpc.CallOption) (*UpsertRoutineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertRoutineResponse)
	err := c.cc.Invoke(ctx, Routines_UpsertRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routinesClient) DeleteRoutine(ctx context.Context, in *DeleteRoutineRequest, opts ...grpc.CallOption) (*DeleteRoutineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRoutineResponse)
	err := c.cc.Invoke(ctx, Routines_DeleteRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routinesClient) PublishRoutine(ctx context.Context, in *PublishRoutineRequest, opts ...grpc.CallOption) (*PublishRoutineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishRoutineResponse)
	err := c.cc.Invoke(ctx, Routines_PublishRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routinesClient) LoadRoutine(ctx context.Context, in *LoadRoutineRequest, opts ...grpc.CallOption) (*LoadRoutineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadRoutineResponse)
	err := c.cc.Invoke(ctx, Routines_LoadRoutine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutinesServer is the server API for Routines service.
// All implementations must embed UnimplementedRoutinesServer
// for forward compatibility.
type RoutinesServer interface {
	GetRoutines(context.Context, *GetRoutinesRequest) (*GetRoutinesResponse, error)
	GetRoutine(context.Context, *GetRoutineRequest) (*GetRoutineResponse, error)
	UpsertRoutine(context.Context, *UpsertRoutineRequest) (*UpsertRoutineResponse, error)
	DeleteRoutine(context.Context, *DeleteRoutineRequest) (*DeleteRoutineResponse, error)
	PublishRoutine(context.Context, *PublishRoutineRequest) (*PublishRoutineResponse, error)
	LoadRoutine(context.Context, *LoadRoutineRequest) (*LoadRoutineResponse, error)
	mustEmbedUnimplementedRoutinesServer()
}

// UnimplementedRoutinesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoutinesServer struct{}

func (UnimplementedRoutinesServer) GetRoutines(context.Context, *GetRoutinesRequest) (*GetRoutinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutines not implemented")
}
func (UnimplementedRoutinesServer) GetRoutine(context.Context, *GetRoutineRequest) (*GetRoutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutine not implemented")
}
func (UnimplementedRoutinesServer) UpsertRoutine(context.Context, *UpsertRoutineRequest) (*UpsertRoutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertRoutine not implemented")
}
func (UnimplementedRoutinesServer) DeleteRoutine(context.Context, *DeleteRoutineRequest) (*DeleteRoutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoutine not implemented")
}
func (UnimplementedRoutinesServer) PublishRoutine(context.Context, *PublishRoutineRequest) (*PublishRoutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishRoutine not implemented")
}
func (UnimplementedRoutinesServer) LoadRoutine(context.Context, *LoadRoutineRequest) (*LoadRoutineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadRoutine not implemented")
}
func (UnimplementedRoutinesServer) mustEmbedUnimplementedRoutinesServer() {}
func (UnimplementedRoutinesServer) testEmbeddedByValue()                  {}

// UnsafeRoutinesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutinesServer will
// result in compilation errors.
type UnsafeRoutinesServer interface {
	mustEmbedUnimplementedRoutinesServer()
}

func RegisterRoutinesServer(s grpc.ServiceRegistrar, srv RoutinesServer) {
	// If the following call pancis, it indicates UnimplementedRoutinesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Routines_ServiceDesc, srv)
}

func _Routines_GetRoutines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).GetRoutines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_GetRoutines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).GetRoutines(ctx, req.(*GetRoutinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routines_GetRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).GetRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_GetRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).GetRoutine(ctx, req.(*GetRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routines_UpsertRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).UpsertRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_UpsertRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).UpsertRoutine(ctx, req.(*UpsertRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routines_DeleteRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).DeleteRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_DeleteRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).DeleteRoutine(ctx, req.(*DeleteRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routines_PublishRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).PublishRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_PublishRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).PublishRoutine(ctx, req.(*PublishRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routines_LoadRoutine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadRoutineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutinesServer).LoadRoutine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routines_LoadRoutine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutinesServer).LoadRoutine(ctx, req.(*LoadRoutineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Routines_ServiceDesc is the grpc.ServiceDesc for Routines service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Routines_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Routines",
	HandlerType: (*RoutinesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRoutines",
			Handler:    _Routines_GetRoutines_Handler,
		},
		{
			MethodName: "GetRoutine",
			Handler:    _Routines_GetRoutine_Handler,
		},
		{
			MethodName: "UpsertRoutine",
			Handler:    _Routines_UpsertRoutine_Handler,
		},
		{
			MethodName: "DeleteRoutine",
			Handler:    _Routines_DeleteRoutine_Handler,
		},
		{
			MethodName: "PublishRoutine",
			Handler:    _Routines_PublishRoutine_Handler,
		},
		{
			MethodName: "LoadRoutine",
			Handler:    _Routines_LoadRoutine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Displays_GetDisplays_FullMethodName    = "/proto.api.Displays/GetDisplays"
	Displays_GetDisplay_FullMethodName     = "/proto.api.Displays/GetDisplay"
	Displays_UpsertDisplay_FullMethodName  = "/proto.api.Displays/UpsertDisplay"
	Displays_DeleteDisplay_FullMethodName  = "/proto.api.Displays/DeleteDisplay"
	Displays_PublishDisplay_FullMethodName = "/proto.api.Displays/PublishDisplay"
	Displays_LoadDisplay_FullMethodName    = "/proto.api.Displays/LoadDisplay"
)

// DisplaysClient is the client API for Displays service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DisplaysClient interface {
	GetDisplays(ctx context.Context, in *GetDisplaysRequest, opts ...grpc.CallOption) (*GetDisplaysResponse, error)
	GetDisplay(ctx context.Context, in *GetDisplayRequest, opts ...grpc.CallOption) (*GetDisplayResponse, error)
	UpsertDisplay(ctx context.Context, in *UpsertDisplayRequest, opts ...grpc.CallOption) (*UpsertDisplayResponse, error)
	DeleteDisplay(ctx context.Context, in *DeleteDisplayRequest, opts ...grpc.CallOption) (*DeleteDisplayResponse, error)
	PublishDisplay(ctx context.Context, in *PublishDisplayRequest, opts ...grpc.CallOption) (*PublishDisplayResponse, error)
	LoadDisplay(ctx context.Context, in *LoadDisplayRequest, opts ...grpc.CallOption) (*LoadDisplayResponse, error)
}

type displaysClient struct {
	cc grpc.ClientConnInterface
}

func NewDisplaysClient(cc grpc.ClientConnInterface) DisplaysClient {
	return &displaysClient{cc}
}

func (c *displaysClient) GetDisplays(ctx context.Context, in *GetDisplaysRequest, opts ...grpc.CallOption) (*GetDisplaysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDisplaysResponse)
	err := c.cc.Invoke(ctx, Displays_GetDisplays_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *displaysClient) GetDisplay(ctx context.Context, in *GetDisplayRequest, opts ...grpc.CallOption) (*GetDisplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDisplayResponse)
	err := c.cc.Invoke(ctx, Displays_GetDisplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *displaysClient) UpsertDisplay(ctx context.Context, in *UpsertDisplayRequest, opts ...grpc.CallOption) (*UpsertDisplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertDisplayResponse)
	err := c.cc.Invoke(ctx, Displays_UpsertDisplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *displaysClient) DeleteDisplay(ctx context.Context, in *DeleteDisplayRequest, opts ...grpc.CallOption) (*DeleteDisplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDisplayResponse)
	err := c.cc.Invoke(ctx, Displays_DeleteDisplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *displaysClient) PublishDisplay(ctx context.Context, in *PublishDisplayRequest, opts ...grpc.CallOption) (*PublishDisplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishDisplayResponse)
	err := c.cc.Invoke(ctx, Displays_PublishDisplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *displaysClient) LoadDisplay(ctx context.Context, in *LoadDisplayRequest, opts ...grpc.CallOption) (*LoadDisplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadDisplayResponse)
	err := c.cc.Invoke(ctx, Displays_LoadDisplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DisplaysServer is the server API for Displays service.
// All implementations must embed UnimplementedDisplaysServer
// for forward compatibility.
type DisplaysServer interface {
	GetDisplays(context.Context, *GetDisplaysRequest) (*GetDisplaysResponse, error)
	GetDisplay(context.Context, *GetDisplayRequest) (*GetDisplayResponse, error)
	UpsertDisplay(context.Context, *UpsertDisplayRequest) (*UpsertDisplayResponse, error)
	DeleteDisplay(context.Context, *DeleteDisplayRequest) (*DeleteDisplayResponse, error)
	PublishDisplay(context.Context, *PublishDisplayRequest) (*PublishDisplayResponse, error)
	LoadDisplay(context.Context, *LoadDisplayRequest) (*LoadDisplayResponse, error)
	mustEmbedUnimplementedDisplaysServer()
}

// UnimplementedDisplaysServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDisplaysServer struct{}

func (UnimplementedDisplaysServer) GetDisplays(context.Context, *GetDisplaysRequest) (*GetDisplaysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDisplays not implemented")
}
func (UnimplementedDisplaysServer) GetDisplay(context.Context, *GetDisplayRequest) (*GetDisplayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDisplay not implemented")
}
func (UnimplementedDisplaysServer) UpsertDisplay(context.Context, *UpsertDisplayRequest) (*UpsertDisplayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertDisplay not implemented")
}
func (UnimplementedDisplaysServer) DeleteDisplay(context.Context, *DeleteDisplayRequest) (*DeleteDisplayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDisplay not implemented")
}
func (UnimplementedDisplaysServer) PublishDisplay(context.Context, *PublishDisplayRequest) (*PublishDisplayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishDisplay not implemented")
}
func (UnimplementedDisplaysServer) LoadDisplay(context.Context, *LoadDisplayRequest) (*LoadDisplayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadDisplay not implemented")
}
func (UnimplementedDisplaysServer) mustEmbedUnimplementedDisplaysServer() {}
func (UnimplementedDisplaysServer) testEmbeddedByValue()                  {}

// UnsafeDisplaysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DisplaysServer will
// result in compilation errors.
type UnsafeDisplaysServer interface {
	mustEmbedUnimplementedDisplaysServer()
}

func RegisterDisplaysServer(s grpc.ServiceRegistrar, srv DisplaysServer) {
	// If the following call pancis, it indicates UnimplementedDisplaysServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Displays_ServiceDesc, srv)
}

func _Displays_GetDisplays_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDisplaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).GetDisplays(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_GetDisplays_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).GetDisplays(ctx, req.(*GetDisplaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Displays_GetDisplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDisplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).GetDisplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_GetDisplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).GetDisplay(ctx, req.(*GetDisplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Displays_UpsertDisplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertDisplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).UpsertDisplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_UpsertDisplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).UpsertDisplay(ctx, req.(*UpsertDisplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Displays_DeleteDisplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDisplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).DeleteDisplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_DeleteDisplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).DeleteDisplay(ctx, req.(*DeleteDisplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Displays_PublishDisplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishDisplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).PublishDisplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_PublishDisplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).PublishDisplay(ctx, req.(*PublishDisplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Displays_LoadDisplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadDisplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisplaysServer).LoadDisplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Displays_LoadDisplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisplaysServer).LoadDisplay(ctx, req.(*LoadDisplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Displays_ServiceDesc is the grpc.ServiceDesc for Displays service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Displays_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Displays",
	HandlerType: (*DisplaysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDisplays",
			Handler:    _Displays_GetDisplays_Handler,
		},
		{
			MethodName: "GetDisplay",
			Handler:    _Displays_GetDisplay_Handler,
		},
		{
			MethodName: "UpsertDisplay",
			Handler:    _Displays_UpsertDisplay_Handler,
		},
		{
			MethodName: "DeleteDisplay",
			Handler:    _Displays_DeleteDisplay_Handler,
		},
		{
			MethodName: "PublishDisplay",
			Handler:    _Displays_PublishDisplay_Handler,
		},
		{
			MethodName: "LoadDisplay",
			Handler:    _Displays_LoadDisplay_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	ParticipantCodes_GetCodes_FullMethodName      = "/proto.api.ParticipantCodes/GetCodes"
	ParticipantCodes_GenerateCodes_FullMethodName = "/proto.api.ParticipantCodes/GenerateCodes"
	ParticipantCodes_AssignCode_FullMethodName    = "/proto.api.ParticipantCodes/AssignCode"
	ParticipantCodes_DeleteCode_FullMethodName    = "/proto.api.ParticipantCodes/DeleteCode"
	ParticipantCodes_UnassignCode_FullMethodName  = "/proto.api.ParticipantCodes/UnassignCode"
)

// ParticipantCodesClient is the client API for ParticipantCodes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParticipantCodesClient interface {
	GetCodes(ctx context.Context, in *GetCodesRequest, opts ...grpc.CallOption) (*GetCodesResponse, error)
	GenerateCodes(ctx context.Context, in *GenerateCodesRequest, opts ...grpc.CallOption) (*GenerateCodesResponse, error)
	AssignCode(ctx context.Context, in *AssignCodeRequest, opts ...grpc.CallOption) (*AssignCodeResponse, error)
	DeleteCode(ctx context.Context, in *DeleteCodeRequest, opts ...grpc.CallOption) (*DeleteCodeResponse, error)
	UnassignCode(ctx context.Context, in *UnassignCodeRequest, opts ...grpc.CallOption) (*UnassignCodeResponse, error)
}

type participantCodesClient struct {
	cc grpc.ClientConnInterface
}

func NewParticipantCodesClient(cc grpc.ClientConnInterface) ParticipantCodesClient {
	return &participantCodesClient{cc}
}

func (c *participantCodesClient) GetCodes(ctx context.Context, in *GetCodesRequest, opts ...grpc.CallOption) (*GetCodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCodesResponse)
	err := c.cc.Invoke(ctx, ParticipantCodes_GetCodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantCodesClient) GenerateCodes(ctx context.Context, in *GenerateCodesRequest, opts ...grpc.CallOption) (*GenerateCodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateCodesResponse)
	err := c.cc.Invoke(ctx, ParticipantCodes_GenerateCodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantCodesClient) AssignCode(ctx context.Context, in *AssignCodeRequest, opts ...grpc.CallOption) (*AssignCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssignCodeResponse)
	err := c.cc.Invoke(ctx, ParticipantCodes_AssignCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantCodesClient) DeleteCode(ctx context.Context, in *DeleteCodeRequest, opts ...grpc.CallOption) (*DeleteCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCodeResponse)
	err := c.cc.Invoke(ctx, ParticipantCodes_DeleteCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantCodesClient) UnassignCode(ctx context.Context, in *UnassignCodeRequest, opts ...grpc.CallOption) (*UnassignCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnassignCodeResponse)
	err := c.cc.Invoke(ctx, ParticipantCodes_UnassignCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ParticipantCodesServer is the server API for ParticipantCodes service.
// All implementations must embed UnimplementedParticipantCodesServer
// for forward compatibility.
type ParticipantCodesServer interface {
	GetCodes(context.Context, *GetCodesRequest) (*GetCodesResponse, error)
	GenerateCodes(context.Context, *GenerateCodesRequest) (*GenerateCodesResponse, error)
	AssignCode(context.Context, *AssignCodeRequest) (*AssignCodeResponse, error)
	DeleteCode(context.Context, *DeleteCodeRequest) (*DeleteCodeResponse, error)
	UnassignCode(context.Context, *UnassignCodeRequest) (*UnassignCodeResponse, error)
	mustEmbedUnimplementedParticipantCodesServer()
}

// UnimplementedParticipantCodesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedParticipantCodesServer struct{}

func (UnimplementedParticipantCodesServer) GetCodes(context.Context, *GetCodesRequest) (*GetCodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCodes not implemented")
}
func (UnimplementedParticipantCodesServer) GenerateCodes(context.Context, *GenerateCodesRequest) (*GenerateCodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCodes not implemented")
}
func (UnimplementedParticipantCodesServer) AssignCode(context.Context, *AssignCodeRequest) (*AssignCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignCode not implemented")
}
func (UnimplementedParticipantCodesServer) DeleteCode(context.Context, *DeleteCodeRequest) (*DeleteCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCode not implemented")
}
func (UnimplementedParticipantCodesServer) UnassignCode(context.Context, *UnassignCodeRequest) (*UnassignCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnassignCode not implemented")
}
func (UnimplementedParticipantCodesServer) mustEmbedUnimplementedParticipantCodesServer() {}
func (UnimplementedParticipantCodesServer) testEmbeddedByValue()                          {}

// UnsafeParticipantCodesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParticipantCodesServer will
// result in compilation errors.
type UnsafeParticipantCodesServer interface {
	mustEmbedUnimplementedParticipantCodesServer()
}

func RegisterParticipantCodesServer(s grpc.ServiceRegistrar, srv ParticipantCodesServer) {
	// If the following call pancis, it indicates UnimplementedParticipantCodesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ParticipantCodes_ServiceDesc, srv)
}

func _ParticipantCodes_GetCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantCodesServer).GetCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParticipantCodes_GetCodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantCodesServer).GetCodes(ctx, req.(*GetCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantCodes_GenerateCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantCodesServer).GenerateCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParticipantCodes_GenerateCodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantCodesServer).GenerateCodes(ctx, req.(*GenerateCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantCodes_AssignCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantCodesServer).AssignCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParticipantCodes_AssignCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantCodesServer).AssignCode(ctx, req.(*AssignCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantCodes_DeleteCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantCodesServer).DeleteCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParticipantCodes_DeleteCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantCodesServer).DeleteCode(ctx, req.(*DeleteCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantCodes_UnassignCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnassignCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantCodesServer).UnassignCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParticipantCodes_UnassignCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantCodesServer).UnassignCode(ctx, req.(*UnassignCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ParticipantCodes_ServiceDesc is the grpc.ServiceDesc for ParticipantCodes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ParticipantCodes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.ParticipantCodes",
	HandlerType: (*ParticipantCodesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCodes",
			Handler:    _ParticipantCodes_GetCodes_Handler,
		},
		{
			MethodName: "GenerateCodes",
			Handler:    _ParticipantCodes_GenerateCodes_Handler,
		},
		{
			MethodName: "AssignCode",
			Handler:    _ParticipantCodes_AssignCode_Handler,
		},
		{
			MethodName: "DeleteCode",
			Handler:    _ParticipantCodes_DeleteCode_Handler,
		},
		{
			MethodName: "UnassignCode",
			Handler:    _ParticipantCodes_UnassignCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Consents_GetConsents_FullMethodName          = "/proto.api.Consents/GetConsents"
	Consents_GetConsent_FullMethodName           = "/proto.api.Consents/GetConsent"
	Consents_UpsertConsent_FullMethodName        = "/proto.api.Consents/UpsertConsent"
	Consents_DeleteConsent_FullMethodName        = "/proto.api.Consents/DeleteConsent"
	Consents_DeleteConsentVersion_FullMethodName = "/proto.api.Consents/DeleteConsentVersion"
	Consents_PublishConsent_FullMethodName       = "/proto.api.Consents/PublishConsent"
)

// ConsentsClient is the client API for Consents service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsentsClient interface {
	GetConsents(ctx context.Context, in *GetConsentsRequest, opts ...grpc.CallOption) (*GetConsentsResponse, error)
	GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error)
	UpsertConsent(ctx context.Context, in *UpsertConsentRequest, opts ...grpc.CallOption) (*UpsertConsentResponse, error)
	DeleteConsent(ctx context.Context, in *DeleteConsentRequest, opts ...grpc.CallOption) (*DeleteConsentResponse, error)
	DeleteConsentVersion(ctx context.Context, in *DeleteConsentVersionRequest, opts ...grpc.CallOption) (*DeleteConsentVersionResponse, error)
	PublishConsent(ctx context.Context, in *PublishConsentRequest, opts ...grpc.CallOption) (*PublishConsentResponse, error)
}

type consentsClient struct {
	cc grpc.ClientConnInterface
}

func NewConsentsClient(cc grpc.ClientConnInterface) ConsentsClient {
	return &consentsClient{cc}
}

func (c *consentsClient) GetConsents(ctx context.Context, in *GetConsentsRequest, opts ...grpc.CallOption) (*GetConsentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsentsResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsentResponse)
	err := c.cc.Invoke(ctx, Consents_GetConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) UpsertConsent(ctx context.Context, in *UpsertConsentRequest, opts ...grpc.CallOption) (*UpsertConsentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertConsentResponse)
	err := c.cc.Invoke(ctx, Consents_UpsertConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) DeleteConsent(ctx context.Context, in *DeleteConsentRequest, opts ...grpc.CallOption) (*DeleteConsentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteConsentResponse)
	err := c.cc.Invoke(ctx, Consents_DeleteConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) DeleteConsentVersion(ctx context.Context, in *DeleteConsentVersionRequest, opts ...grpc.CallOption) (*DeleteConsentVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteConsentVersionResponse)
	err := c.cc.Invoke(ctx, Consents_DeleteConsentVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentsClient) PublishConsent(ctx context.Context, in *PublishConsentRequest, opts ...grpc.CallOption) (*PublishConsentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishConsentResponse)
	err := c.cc.Invoke(ctx, Consents_PublishConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsentsServer is the server API for Consents service.
// All implementations must embed UnimplementedConsentsServer
// for forward compatibility.
type ConsentsServer interface {
	GetConsents(context.Context, *GetConsentsRequest) (*GetConsentsResponse, error)
	GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error)
	UpsertConsent(context.Context, *UpsertConsentRequest) (*UpsertConsentResponse, error)
	DeleteConsent(context.Context, *DeleteConsentRequest) (*DeleteConsentResponse, error)
	DeleteConsentVersion(context.Context, *DeleteConsentVersionRequest) (*DeleteConsentVersionResponse, error)
	PublishConsent(context.Context, *PublishConsentRequest) (*PublishConsentResponse, error)
	mustEmbedUnimplementedConsentsServer()
}

// UnimplementedConsentsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConsentsServer struct{}

func (UnimplementedConsentsServer) GetConsents(context.Context, *GetConsentsRequest) (*GetConsentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsents not implemented")
}
func (UnimplementedConsentsServer) GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsent not implemented")
}
func (UnimplementedConsentsServer) UpsertConsent(context.Context, *UpsertConsentRequest) (*UpsertConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertConsent not implemented")
}
func (UnimplementedConsentsServer) DeleteConsent(context.Context, *DeleteConsentRequest) (*DeleteConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConsent not implemented")
}
func (UnimplementedConsentsServer) DeleteConsentVersion(context.Context, *DeleteConsentVersionRequest) (*DeleteConsentVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConsentVersion not implemented")
}
func (UnimplementedConsentsServer) PublishConsent(context.Context, *PublishConsentRequest) (*PublishConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishConsent not implemented")
}
func (UnimplementedConsentsServer) mustEmbedUnimplementedConsentsServer() {}
func (UnimplementedConsentsServer) testEmbeddedByValue()                  {}

// UnsafeConsentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsentsServer will
// result in compilation errors.
type UnsafeConsentsServer interface {
	mustEmbedUnimplementedConsentsServer()
}

func RegisterConsentsServer(s grpc.ServiceRegistrar, srv ConsentsServer) {
	// If the following call pancis, it indicates UnimplementedConsentsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Consents_ServiceDesc, srv)
}

func _Consents_GetConsents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsents(ctx, req.(*GetConsentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_GetConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).GetConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_GetConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).GetConsent(ctx, req.(*GetConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_UpsertConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).UpsertConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_UpsertConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).UpsertConsent(ctx, req.(*UpsertConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_DeleteConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).DeleteConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_DeleteConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).DeleteConsent(ctx, req.(*DeleteConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_DeleteConsentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConsentVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).DeleteConsentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_DeleteConsentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).DeleteConsentVersion(ctx, req.(*DeleteConsentVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consents_PublishConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentsServer).PublishConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consents_PublishConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentsServer).PublishConsent(ctx, req.(*PublishConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Consents_ServiceDesc is the grpc.ServiceDesc for Consents service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Consents_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Consents",
	HandlerType: (*ConsentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConsents",
			Handler:    _Consents_GetConsents_Handler,
		},
		{
			MethodName: "GetConsent",
			Handler:    _Consents_GetConsent_Handler,
		},
		{
			MethodName: "UpsertConsent",
			Handler:    _Consents_UpsertConsent_Handler,
		},
		{
			MethodName: "DeleteConsent",
			Handler:    _Consents_DeleteConsent_Handler,
		},
		{
			MethodName: "DeleteConsentVersion",
			Handler:    _Consents_DeleteConsentVersion_Handler,
		},
		{
			MethodName: "PublishConsent",
			Handler:    _Consents_PublishConsent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	StandaloneSurveys_GetStandaloneSurveys_FullMethodName   = "/proto.api.StandaloneSurveys/GetStandaloneSurveys"
	StandaloneSurveys_GetStandaloneSurvey_FullMethodName    = "/proto.api.StandaloneSurveys/GetStandaloneSurvey"
	StandaloneSurveys_UpsertStandaloneSurvey_FullMethodName = "/proto.api.StandaloneSurveys/UpsertStandaloneSurvey"
	StandaloneSurveys_DeleteStandaloneSurvey_FullMethodName = "/proto.api.StandaloneSurveys/DeleteStandaloneSurvey"
)

// StandaloneSurveysClient is the client API for StandaloneSurveys service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StandaloneSurveysClient interface {
	GetStandaloneSurveys(ctx context.Context, in *GetStandaloneSurveysRequest, opts ...grpc.CallOption) (*GetStandaloneSurveysResponse, error)
	GetStandaloneSurvey(ctx context.Context, in *GetStandaloneSurveyRequest, opts ...grpc.CallOption) (*GetStandaloneSurveyResponse, error)
	UpsertStandaloneSurvey(ctx context.Context, in *UpsertStandaloneSurveyRequest, opts ...grpc.CallOption) (*UpsertStandaloneSurveyResponse, error)
	DeleteStandaloneSurvey(ctx context.Context, in *DeleteStandaloneSurveyRequest, opts ...grpc.CallOption) (*DeleteStandaloneSurveyResponse, error)
}

type standaloneSurveysClient struct {
	cc grpc.ClientConnInterface
}

func NewStandaloneSurveysClient(cc grpc.ClientConnInterface) StandaloneSurveysClient {
	return &standaloneSurveysClient{cc}
}

func (c *standaloneSurveysClient) GetStandaloneSurveys(ctx context.Context, in *GetStandaloneSurveysRequest, opts ...grpc.CallOption) (*GetStandaloneSurveysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStandaloneSurveysResponse)
	err := c.cc.Invoke(ctx, StandaloneSurveys_GetStandaloneSurveys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standaloneSurveysClient) GetStandaloneSurvey(ctx context.Context, in *GetStandaloneSurveyRequest, opts ...grpc.CallOption) (*GetStandaloneSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStandaloneSurveyResponse)
	err := c.cc.Invoke(ctx, StandaloneSurveys_GetStandaloneSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standaloneSurveysClient) UpsertStandaloneSurvey(ctx context.Context, in *UpsertStandaloneSurveyRequest, opts ...grpc.CallOption) (*UpsertStandaloneSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertStandaloneSurveyResponse)
	err := c.cc.Invoke(ctx, StandaloneSurveys_UpsertStandaloneSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standaloneSurveysClient) DeleteStandaloneSurvey(ctx context.Context, in *DeleteStandaloneSurveyRequest, opts ...grpc.CallOption) (*DeleteStandaloneSurveyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteStandaloneSurveyResponse)
	err := c.cc.Invoke(ctx, StandaloneSurveys_DeleteStandaloneSurvey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StandaloneSurveysServer is the server API for StandaloneSurveys service.
// All implementations must embed UnimplementedStandaloneSurveysServer
// for forward compatibility.
type StandaloneSurveysServer interface {
	GetStandaloneSurveys(context.Context, *GetStandaloneSurveysRequest) (*GetStandaloneSurveysResponse, error)
	GetStandaloneSurvey(context.Context, *GetStandaloneSurveyRequest) (*GetStandaloneSurveyResponse, error)
	UpsertStandaloneSurvey(context.Context, *UpsertStandaloneSurveyRequest) (*UpsertStandaloneSurveyResponse, error)
	DeleteStandaloneSurvey(context.Context, *DeleteStandaloneSurveyRequest) (*DeleteStandaloneSurveyResponse, error)
	mustEmbedUnimplementedStandaloneSurveysServer()
}

// UnimplementedStandaloneSurveysServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStandaloneSurveysServer struct{}

func (UnimplementedStandaloneSurveysServer) GetStandaloneSurveys(context.Context, *GetStandaloneSurveysRequest) (*GetStandaloneSurveysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStandaloneSurveys not implemented")
}
func (UnimplementedStandaloneSurveysServer) GetStandaloneSurvey(context.Context, *GetStandaloneSurveyRequest) (*GetStandaloneSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStandaloneSurvey not implemented")
}
func (UnimplementedStandaloneSurveysServer) UpsertStandaloneSurvey(context.Context, *UpsertStandaloneSurveyRequest) (*UpsertStandaloneSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertStandaloneSurvey not implemented")
}
func (UnimplementedStandaloneSurveysServer) DeleteStandaloneSurvey(context.Context, *DeleteStandaloneSurveyRequest) (*DeleteStandaloneSurveyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStandaloneSurvey not implemented")
}
func (UnimplementedStandaloneSurveysServer) mustEmbedUnimplementedStandaloneSurveysServer() {}
func (UnimplementedStandaloneSurveysServer) testEmbeddedByValue()                           {}

// UnsafeStandaloneSurveysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StandaloneSurveysServer will
// result in compilation errors.
type UnsafeStandaloneSurveysServer interface {
	mustEmbedUnimplementedStandaloneSurveysServer()
}

func RegisterStandaloneSurveysServer(s grpc.ServiceRegistrar, srv StandaloneSurveysServer) {
	// If the following call pancis, it indicates UnimplementedStandaloneSurveysServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StandaloneSurveys_ServiceDesc, srv)
}

func _StandaloneSurveys_GetStandaloneSurveys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStandaloneSurveysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneSurveysServer).GetStandaloneSurveys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneSurveys_GetStandaloneSurveys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneSurveysServer).GetStandaloneSurveys(ctx, req.(*GetStandaloneSurveysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandaloneSurveys_GetStandaloneSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStandaloneSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneSurveysServer).GetStandaloneSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneSurveys_GetStandaloneSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneSurveysServer).GetStandaloneSurvey(ctx, req.(*GetStandaloneSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandaloneSurveys_UpsertStandaloneSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertStandaloneSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneSurveysServer).UpsertStandaloneSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneSurveys_UpsertStandaloneSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneSurveysServer).UpsertStandaloneSurvey(ctx, req.(*UpsertStandaloneSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandaloneSurveys_DeleteStandaloneSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStandaloneSurveyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneSurveysServer).DeleteStandaloneSurvey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneSurveys_DeleteStandaloneSurvey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneSurveysServer).DeleteStandaloneSurvey(ctx, req.(*DeleteStandaloneSurveyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StandaloneSurveys_ServiceDesc is the grpc.ServiceDesc for StandaloneSurveys service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StandaloneSurveys_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.StandaloneSurveys",
	HandlerType: (*StandaloneSurveysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStandaloneSurveys",
			Handler:    _StandaloneSurveys_GetStandaloneSurveys_Handler,
		},
		{
			MethodName: "GetStandaloneSurvey",
			Handler:    _StandaloneSurveys_GetStandaloneSurvey_Handler,
		},
		{
			MethodName: "UpsertStandaloneSurvey",
			Handler:    _StandaloneSurveys_UpsertStandaloneSurvey_Handler,
		},
		{
			MethodName: "DeleteStandaloneSurvey",
			Handler:    _StandaloneSurveys_DeleteStandaloneSurvey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	StandaloneQuestionnaires_GetStandaloneQuestionnaires_FullMethodName   = "/proto.api.StandaloneQuestionnaires/GetStandaloneQuestionnaires"
	StandaloneQuestionnaires_GetStandaloneQuestionnaire_FullMethodName    = "/proto.api.StandaloneQuestionnaires/GetStandaloneQuestionnaire"
	StandaloneQuestionnaires_UpsertStandaloneQuestionnaire_FullMethodName = "/proto.api.StandaloneQuestionnaires/UpsertStandaloneQuestionnaire"
	StandaloneQuestionnaires_DeleteStandaloneQuestionnaire_FullMethodName = "/proto.api.StandaloneQuestionnaires/DeleteStandaloneQuestionnaire"
)

// StandaloneQuestionnairesClient is the client API for StandaloneQuestionnaires service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StandaloneQuestionnairesClient interface {
	GetStandaloneQuestionnaires(ctx context.Context, in *GetStandaloneQuestionnairesRequest, opts ...grpc.CallOption) (*GetStandaloneQuestionnairesResponse, error)
	GetStandaloneQuestionnaire(ctx context.Context, in *GetStandaloneQuestionnaireRequest, opts ...grpc.CallOption) (*GetStandaloneQuestionnaireResponse, error)
	UpsertStandaloneQuestionnaire(ctx context.Context, in *UpsertStandaloneQuestionnaireRequest, opts ...grpc.CallOption) (*UpsertStandaloneQuestionnaireResponse, error)
	DeleteStandaloneQuestionnaire(ctx context.Context, in *DeleteStandaloneQuestionnaireRequest, opts ...grpc.CallOption) (*DeleteStandaloneQuestionnaireResponse, error)
}

type standaloneQuestionnairesClient struct {
	cc grpc.ClientConnInterface
}

func NewStandaloneQuestionnairesClient(cc grpc.ClientConnInterface) StandaloneQuestionnairesClient {
	return &standaloneQuestionnairesClient{cc}
}

func (c *standaloneQuestionnairesClient) GetStandaloneQuestionnaires(ctx context.Context, in *GetStandaloneQuestionnairesRequest, opts ...grpc.CallOption) (*GetStandaloneQuestionnairesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStandaloneQuestionnairesResponse)
	err := c.cc.Invoke(ctx, StandaloneQuestionnaires_GetStandaloneQuestionnaires_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standaloneQuestionnairesClient) GetStandaloneQuestionnaire(ctx context.Context, in *GetStandaloneQuestionnaireRequest, opts ...grpc.CallOption) (*GetStandaloneQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStandaloneQuestionnaireResponse)
	err := c.cc.Invoke(ctx, StandaloneQuestionnaires_GetStandaloneQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standaloneQuestionnairesClient) UpsertStandaloneQuestionnaire(ctx context.Context, in *UpsertStandaloneQuestionnaireRequest, opts ...grpc.CallOption) (*UpsertStandaloneQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertStandaloneQuestionnaireResponse)
	err := c.cc.Invoke(ctx, StandaloneQuestionnaires_UpsertStandaloneQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *standaloneQuestionnairesClient) DeleteStandaloneQuestionnaire(ctx context.Context, in *DeleteStandaloneQuestionnaireRequest, opts ...grpc.CallOption) (*DeleteStandaloneQuestionnaireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteStandaloneQuestionnaireResponse)
	err := c.cc.Invoke(ctx, StandaloneQuestionnaires_DeleteStandaloneQuestionnaire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StandaloneQuestionnairesServer is the server API for StandaloneQuestionnaires service.
// All implementations must embed UnimplementedStandaloneQuestionnairesServer
// for forward compatibility.
type StandaloneQuestionnairesServer interface {
	GetStandaloneQuestionnaires(context.Context, *GetStandaloneQuestionnairesRequest) (*GetStandaloneQuestionnairesResponse, error)
	GetStandaloneQuestionnaire(context.Context, *GetStandaloneQuestionnaireRequest) (*GetStandaloneQuestionnaireResponse, error)
	UpsertStandaloneQuestionnaire(context.Context, *UpsertStandaloneQuestionnaireRequest) (*UpsertStandaloneQuestionnaireResponse, error)
	DeleteStandaloneQuestionnaire(context.Context, *DeleteStandaloneQuestionnaireRequest) (*DeleteStandaloneQuestionnaireResponse, error)
	mustEmbedUnimplementedStandaloneQuestionnairesServer()
}

// UnimplementedStandaloneQuestionnairesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStandaloneQuestionnairesServer struct{}

func (UnimplementedStandaloneQuestionnairesServer) GetStandaloneQuestionnaires(context.Context, *GetStandaloneQuestionnairesRequest) (*GetStandaloneQuestionnairesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStandaloneQuestionnaires not implemented")
}
func (UnimplementedStandaloneQuestionnairesServer) GetStandaloneQuestionnaire(context.Context, *GetStandaloneQuestionnaireRequest) (*GetStandaloneQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStandaloneQuestionnaire not implemented")
}
func (UnimplementedStandaloneQuestionnairesServer) UpsertStandaloneQuestionnaire(context.Context, *UpsertStandaloneQuestionnaireRequest) (*UpsertStandaloneQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertStandaloneQuestionnaire not implemented")
}
func (UnimplementedStandaloneQuestionnairesServer) DeleteStandaloneQuestionnaire(context.Context, *DeleteStandaloneQuestionnaireRequest) (*DeleteStandaloneQuestionnaireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStandaloneQuestionnaire not implemented")
}
func (UnimplementedStandaloneQuestionnairesServer) mustEmbedUnimplementedStandaloneQuestionnairesServer() {
}
func (UnimplementedStandaloneQuestionnairesServer) testEmbeddedByValue() {}

// UnsafeStandaloneQuestionnairesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StandaloneQuestionnairesServer will
// result in compilation errors.
type UnsafeStandaloneQuestionnairesServer interface {
	mustEmbedUnimplementedStandaloneQuestionnairesServer()
}

func RegisterStandaloneQuestionnairesServer(s grpc.ServiceRegistrar, srv StandaloneQuestionnairesServer) {
	// If the following call pancis, it indicates UnimplementedStandaloneQuestionnairesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StandaloneQuestionnaires_ServiceDesc, srv)
}

func _StandaloneQuestionnaires_GetStandaloneQuestionnaires_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStandaloneQuestionnairesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneQuestionnairesServer).GetStandaloneQuestionnaires(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneQuestionnaires_GetStandaloneQuestionnaires_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneQuestionnairesServer).GetStandaloneQuestionnaires(ctx, req.(*GetStandaloneQuestionnairesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandaloneQuestionnaires_GetStandaloneQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStandaloneQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneQuestionnairesServer).GetStandaloneQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneQuestionnaires_GetStandaloneQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneQuestionnairesServer).GetStandaloneQuestionnaire(ctx, req.(*GetStandaloneQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandaloneQuestionnaires_UpsertStandaloneQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertStandaloneQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneQuestionnairesServer).UpsertStandaloneQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneQuestionnaires_UpsertStandaloneQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneQuestionnairesServer).UpsertStandaloneQuestionnaire(ctx, req.(*UpsertStandaloneQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StandaloneQuestionnaires_DeleteStandaloneQuestionnaire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStandaloneQuestionnaireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StandaloneQuestionnairesServer).DeleteStandaloneQuestionnaire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StandaloneQuestionnaires_DeleteStandaloneQuestionnaire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StandaloneQuestionnairesServer).DeleteStandaloneQuestionnaire(ctx, req.(*DeleteStandaloneQuestionnaireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StandaloneQuestionnaires_ServiceDesc is the grpc.ServiceDesc for StandaloneQuestionnaires service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StandaloneQuestionnaires_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.StandaloneQuestionnaires",
	HandlerType: (*StandaloneQuestionnairesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStandaloneQuestionnaires",
			Handler:    _StandaloneQuestionnaires_GetStandaloneQuestionnaires_Handler,
		},
		{
			MethodName: "GetStandaloneQuestionnaire",
			Handler:    _StandaloneQuestionnaires_GetStandaloneQuestionnaire_Handler,
		},
		{
			MethodName: "UpsertStandaloneQuestionnaire",
			Handler:    _StandaloneQuestionnaires_UpsertStandaloneQuestionnaire_Handler,
		},
		{
			MethodName: "DeleteStandaloneQuestionnaire",
			Handler:    _StandaloneQuestionnaires_DeleteStandaloneQuestionnaire_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Uploads_GetSubjects_FullMethodName        = "/proto.api.Uploads/GetSubjects"
	Uploads_GetSubjectData_FullMethodName     = "/proto.api.Uploads/GetSubjectData"
	Uploads_GetSubjectResource_FullMethodName = "/proto.api.Uploads/GetSubjectResource"
	Uploads_GetDownloadList_FullMethodName    = "/proto.api.Uploads/GetDownloadList"
	Uploads_GetDownloadTicket_FullMethodName  = "/proto.api.Uploads/GetDownloadTicket"
	Uploads_GetStatistics_FullMethodName      = "/proto.api.Uploads/GetStatistics"
)

// UploadsClient is the client API for Uploads service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UploadsClient interface {
	GetSubjects(ctx context.Context, in *GetSubjectsRequest, opts ...grpc.CallOption) (*GetSubjectsResponse, error)
	GetSubjectData(ctx context.Context, in *GetSubjectDataRequest, opts ...grpc.CallOption) (*GetSubjectDataResponse, error)
	GetSubjectResource(ctx context.Context, in *GetSubjectResourceRequest, opts ...grpc.CallOption) (*GetSubjectResourceResponse, error)
	GetDownloadList(ctx context.Context, in *GetDownloadListRequest, opts ...grpc.CallOption) (*GetDownloadListResponse, error)
	GetDownloadTicket(ctx context.Context, in *GetDownloadTicketRequest, opts ...grpc.CallOption) (*GetDownloadTicketResponse, error)
	GetStatistics(ctx context.Context, in *GetStatisticsRequest, opts ...grpc.CallOption) (*GetStatisticsResponse, error)
}

type uploadsClient struct {
	cc grpc.ClientConnInterface
}

func NewUploadsClient(cc grpc.ClientConnInterface) UploadsClient {
	return &uploadsClient{cc}
}

func (c *uploadsClient) GetSubjects(ctx context.Context, in *GetSubjectsRequest, opts ...grpc.CallOption) (*GetSubjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubjectsResponse)
	err := c.cc.Invoke(ctx, Uploads_GetSubjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadsClient) GetSubjectData(ctx context.Context, in *GetSubjectDataRequest, opts ...grpc.CallOption) (*GetSubjectDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubjectDataResponse)
	err := c.cc.Invoke(ctx, Uploads_GetSubjectData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadsClient) GetSubjectResource(ctx context.Context, in *GetSubjectResourceRequest, opts ...grpc.CallOption) (*GetSubjectResourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubjectResourceResponse)
	err := c.cc.Invoke(ctx, Uploads_GetSubjectResource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadsClient) GetDownloadList(ctx context.Context, in *GetDownloadListRequest, opts ...grpc.CallOption) (*GetDownloadListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDownloadListResponse)
	err := c.cc.Invoke(ctx, Uploads_GetDownloadList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadsClient) GetDownloadTicket(ctx context.Context, in *GetDownloadTicketRequest, opts ...grpc.CallOption) (*GetDownloadTicketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDownloadTicketResponse)
	err := c.cc.Invoke(ctx, Uploads_GetDownloadTicket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadsClient) GetStatistics(ctx context.Context, in *GetStatisticsRequest, opts ...grpc.CallOption) (*GetStatisticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatisticsResponse)
	err := c.cc.Invoke(ctx, Uploads_GetStatistics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UploadsServer is the server API for Uploads service.
// All implementations must embed UnimplementedUploadsServer
// for forward compatibility.
type UploadsServer interface {
	GetSubjects(context.Context, *GetSubjectsRequest) (*GetSubjectsResponse, error)
	GetSubjectData(context.Context, *GetSubjectDataRequest) (*GetSubjectDataResponse, error)
	GetSubjectResource(context.Context, *GetSubjectResourceRequest) (*GetSubjectResourceResponse, error)
	GetDownloadList(context.Context, *GetDownloadListRequest) (*GetDownloadListResponse, error)
	GetDownloadTicket(context.Context, *GetDownloadTicketRequest) (*GetDownloadTicketResponse, error)
	GetStatistics(context.Context, *GetStatisticsRequest) (*GetStatisticsResponse, error)
	mustEmbedUnimplementedUploadsServer()
}

// UnimplementedUploadsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUploadsServer struct{}

func (UnimplementedUploadsServer) GetSubjects(context.Context, *GetSubjectsRequest) (*GetSubjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubjects not implemented")
}
func (UnimplementedUploadsServer) GetSubjectData(context.Context, *GetSubjectDataRequest) (*GetSubjectDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubjectData not implemented")
}
func (UnimplementedUploadsServer) GetSubjectResource(context.Context, *GetSubjectResourceRequest) (*GetSubjectResourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubjectResource not implemented")
}
func (UnimplementedUploadsServer) GetDownloadList(context.Context, *GetDownloadListRequest) (*GetDownloadListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDownloadList not implemented")
}
func (UnimplementedUploadsServer) GetDownloadTicket(context.Context, *GetDownloadTicketRequest) (*GetDownloadTicketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDownloadTicket not implemented")
}
func (UnimplementedUploadsServer) GetStatistics(context.Context, *GetStatisticsRequest) (*GetStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatistics not implemented")
}
func (UnimplementedUploadsServer) mustEmbedUnimplementedUploadsServer() {}
func (UnimplementedUploadsServer) testEmbeddedByValue()                 {}

// UnsafeUploadsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UploadsServer will
// result in compilation errors.
type UnsafeUploadsServer interface {
	mustEmbedUnimplementedUploadsServer()
}

func RegisterUploadsServer(s grpc.ServiceRegistrar, srv UploadsServer) {
	// If the following call pancis, it indicates UnimplementedUploadsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Uploads_ServiceDesc, srv)
}

func _Uploads_GetSubjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadsServer).GetSubjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uploads_GetSubjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadsServer).GetSubjects(ctx, req.(*GetSubjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Uploads_GetSubjectData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubjectDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadsServer).GetSubjectData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uploads_GetSubjectData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadsServer).GetSubjectData(ctx, req.(*GetSubjectDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Uploads_GetSubjectResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubjectResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadsServer).GetSubjectResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uploads_GetSubjectResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadsServer).GetSubjectResource(ctx, req.(*GetSubjectResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Uploads_GetDownloadList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDownloadListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadsServer).GetDownloadList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uploads_GetDownloadList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadsServer).GetDownloadList(ctx, req.(*GetDownloadListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Uploads_GetDownloadTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDownloadTicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadsServer).GetDownloadTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uploads_GetDownloadTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadsServer).GetDownloadTicket(ctx, req.(*GetDownloadTicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Uploads_GetStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadsServer).GetStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uploads_GetStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadsServer).GetStatistics(ctx, req.(*GetStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Uploads_ServiceDesc is the grpc.ServiceDesc for Uploads service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Uploads_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Uploads",
	HandlerType: (*UploadsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSubjects",
			Handler:    _Uploads_GetSubjects_Handler,
		},
		{
			MethodName: "GetSubjectData",
			Handler:    _Uploads_GetSubjectData_Handler,
		},
		{
			MethodName: "GetSubjectResource",
			Handler:    _Uploads_GetSubjectResource_Handler,
		},
		{
			MethodName: "GetDownloadList",
			Handler:    _Uploads_GetDownloadList_Handler,
		},
		{
			MethodName: "GetDownloadTicket",
			Handler:    _Uploads_GetDownloadTicket_Handler,
		},
		{
			MethodName: "GetStatistics",
			Handler:    _Uploads_GetStatistics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Images_GetImage_FullMethodName    = "/proto.api.Images/GetImage"
	Images_UpsertImage_FullMethodName = "/proto.api.Images/UpsertImage"
	Images_DeleteImage_FullMethodName = "/proto.api.Images/DeleteImage"
)

// ImagesClient is the client API for Images service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImagesClient interface {
	GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error)
	UpsertImage(ctx context.Context, in *UpsertImageRequest, opts ...grpc.CallOption) (*UpsertImageResponse, error)
	DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*DeleteImageResponse, error)
}

type imagesClient struct {
	cc grpc.ClientConnInterface
}

func NewImagesClient(cc grpc.ClientConnInterface) ImagesClient {
	return &imagesClient{cc}
}

func (c *imagesClient) GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*httpbody.HttpBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(httpbody.HttpBody)
	err := c.cc.Invoke(ctx, Images_GetImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) UpsertImage(ctx context.Context, in *UpsertImageRequest, opts ...grpc.CallOption) (*UpsertImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertImageResponse)
	err := c.cc.Invoke(ctx, Images_UpsertImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*DeleteImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteImageResponse)
	err := c.cc.Invoke(ctx, Images_DeleteImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImagesServer is the server API for Images service.
// All implementations must embed UnimplementedImagesServer
// for forward compatibility.
type ImagesServer interface {
	GetImage(context.Context, *GetImageRequest) (*httpbody.HttpBody, error)
	UpsertImage(context.Context, *UpsertImageRequest) (*UpsertImageResponse, error)
	DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageResponse, error)
	mustEmbedUnimplementedImagesServer()
}

// UnimplementedImagesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImagesServer struct{}

func (UnimplementedImagesServer) GetImage(context.Context, *GetImageRequest) (*httpbody.HttpBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImage not implemented")
}
func (UnimplementedImagesServer) UpsertImage(context.Context, *UpsertImageRequest) (*UpsertImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertImage not implemented")
}
func (UnimplementedImagesServer) DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}
func (UnimplementedImagesServer) mustEmbedUnimplementedImagesServer() {}
func (UnimplementedImagesServer) testEmbeddedByValue()                {}

// UnsafeImagesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImagesServer will
// result in compilation errors.
type UnsafeImagesServer interface {
	mustEmbedUnimplementedImagesServer()
}

func RegisterImagesServer(s grpc.ServiceRegistrar, srv ImagesServer) {
	// If the following call pancis, it indicates UnimplementedImagesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Images_ServiceDesc, srv)
}

func _Images_GetImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_GetImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetImage(ctx, req.(*GetImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_UpsertImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).UpsertImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_UpsertImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).UpsertImage(ctx, req.(*UpsertImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_DeleteImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).DeleteImage(ctx, req.(*DeleteImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Images_ServiceDesc is the grpc.ServiceDesc for Images service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Images_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Images",
	HandlerType: (*ImagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetImage",
			Handler:    _Images_GetImage_Handler,
		},
		{
			MethodName: "UpsertImage",
			Handler:    _Images_UpsertImage_Handler,
		},
		{
			MethodName: "DeleteImage",
			Handler:    _Images_DeleteImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Clients_GetClients_FullMethodName    = "/proto.api.Clients/GetClients"
	Clients_GetClient_FullMethodName     = "/proto.api.Clients/GetClient"
	Clients_UpsertClient_FullMethodName  = "/proto.api.Clients/UpsertClient"
	Clients_ExchangeToken_FullMethodName = "/proto.api.Clients/ExchangeToken"
	Clients_DeleteClient_FullMethodName  = "/proto.api.Clients/DeleteClient"
)

// ClientsClient is the client API for Clients service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClientsClient interface {
	GetClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error)
	GetClient(ctx context.Context, in *GetClientRequest, opts ...grpc.CallOption) (*GetClientResponse, error)
	UpsertClient(ctx context.Context, in *UpsertClientRequest, opts ...grpc.CallOption) (*UpsertClientResponse, error)
	ExchangeToken(ctx context.Context, in *ExchangeTokenRequest, opts ...grpc.CallOption) (*ExchangeTokenResponse, error)
	DeleteClient(ctx context.Context, in *DeleteClientRequest, opts ...grpc.CallOption) (*DeleteClientResponse, error)
}

type clientsClient struct {
	cc grpc.ClientConnInterface
}

func NewClientsClient(cc grpc.ClientConnInterface) ClientsClient {
	return &clientsClient{cc}
}

func (c *clientsClient) GetClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClientsResponse)
	err := c.cc.Invoke(ctx, Clients_GetClients_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) GetClient(ctx context.Context, in *GetClientRequest, opts ...grpc.CallOption) (*GetClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClientResponse)
	err := c.cc.Invoke(ctx, Clients_GetClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) UpsertClient(ctx context.Context, in *UpsertClientRequest, opts ...grpc.CallOption) (*UpsertClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertClientResponse)
	err := c.cc.Invoke(ctx, Clients_UpsertClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) ExchangeToken(ctx context.Context, in *ExchangeTokenRequest, opts ...grpc.CallOption) (*ExchangeTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExchangeTokenResponse)
	err := c.cc.Invoke(ctx, Clients_ExchangeToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) DeleteClient(ctx context.Context, in *DeleteClientRequest, opts ...grpc.CallOption) (*DeleteClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClientResponse)
	err := c.cc.Invoke(ctx, Clients_DeleteClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientsServer is the server API for Clients service.
// All implementations must embed UnimplementedClientsServer
// for forward compatibility.
type ClientsServer interface {
	GetClients(context.Context, *GetClientsRequest) (*GetClientsResponse, error)
	GetClient(context.Context, *GetClientRequest) (*GetClientResponse, error)
	UpsertClient(context.Context, *UpsertClientRequest) (*UpsertClientResponse, error)
	ExchangeToken(context.Context, *ExchangeTokenRequest) (*ExchangeTokenResponse, error)
	DeleteClient(context.Context, *DeleteClientRequest) (*DeleteClientResponse, error)
	mustEmbedUnimplementedClientsServer()
}

// UnimplementedClientsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClientsServer struct{}

func (UnimplementedClientsServer) GetClients(context.Context, *GetClientsRequest) (*GetClientsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClients not implemented")
}
func (UnimplementedClientsServer) GetClient(context.Context, *GetClientRequest) (*GetClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClient not implemented")
}
func (UnimplementedClientsServer) UpsertClient(context.Context, *UpsertClientRequest) (*UpsertClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertClient not implemented")
}
func (UnimplementedClientsServer) ExchangeToken(context.Context, *ExchangeTokenRequest) (*ExchangeTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExchangeToken not implemented")
}
func (UnimplementedClientsServer) DeleteClient(context.Context, *DeleteClientRequest) (*DeleteClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClient not implemented")
}
func (UnimplementedClientsServer) mustEmbedUnimplementedClientsServer() {}
func (UnimplementedClientsServer) testEmbeddedByValue()                 {}

// UnsafeClientsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClientsServer will
// result in compilation errors.
type UnsafeClientsServer interface {
	mustEmbedUnimplementedClientsServer()
}

func RegisterClientsServer(s grpc.ServiceRegistrar, srv ClientsServer) {
	// If the following call pancis, it indicates UnimplementedClientsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Clients_ServiceDesc, srv)
}

func _Clients_GetClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).GetClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Clients_GetClients_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).GetClients(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_GetClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).GetClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Clients_GetClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).GetClient(ctx, req.(*GetClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_UpsertClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).UpsertClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Clients_UpsertClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).UpsertClient(ctx, req.(*UpsertClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_ExchangeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExchangeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).ExchangeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Clients_ExchangeToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).ExchangeToken(ctx, req.(*ExchangeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_DeleteClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).DeleteClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Clients_DeleteClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).DeleteClient(ctx, req.(*DeleteClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Clients_ServiceDesc is the grpc.ServiceDesc for Clients service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Clients_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Clients",
	HandlerType: (*ClientsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClients",
			Handler:    _Clients_GetClients_Handler,
		},
		{
			MethodName: "GetClient",
			Handler:    _Clients_GetClient_Handler,
		},
		{
			MethodName: "UpsertClient",
			Handler:    _Clients_UpsertClient_Handler,
		},
		{
			MethodName: "ExchangeToken",
			Handler:    _Clients_ExchangeToken_Handler,
		},
		{
			MethodName: "DeleteClient",
			Handler:    _Clients_DeleteClient_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}

const (
	Checks_Liveness_FullMethodName  = "/proto.api.Checks/Liveness"
	Checks_Readiness_FullMethodName = "/proto.api.Checks/Readiness"
)

// ChecksClient is the client API for Checks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChecksClient interface {
	Liveness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error)
	Readiness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error)
}

type checksClient struct {
	cc grpc.ClientConnInterface
}

func NewChecksClient(cc grpc.ClientConnInterface) ChecksClient {
	return &checksClient{cc}
}

func (c *checksClient) Liveness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChecksResponse)
	err := c.cc.Invoke(ctx, Checks_Liveness_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checksClient) Readiness(ctx context.Context, in *ChecksRequest, opts ...grpc.CallOption) (*ChecksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChecksResponse)
	err := c.cc.Invoke(ctx, Checks_Readiness_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChecksServer is the server API for Checks service.
// All implementations must embed UnimplementedChecksServer
// for forward compatibility.
type ChecksServer interface {
	Liveness(context.Context, *ChecksRequest) (*ChecksResponse, error)
	Readiness(context.Context, *ChecksRequest) (*ChecksResponse, error)
	mustEmbedUnimplementedChecksServer()
}

// UnimplementedChecksServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChecksServer struct{}

func (UnimplementedChecksServer) Liveness(context.Context, *ChecksRequest) (*ChecksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Liveness not implemented")
}
func (UnimplementedChecksServer) Readiness(context.Context, *ChecksRequest) (*ChecksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Readiness not implemented")
}
func (UnimplementedChecksServer) mustEmbedUnimplementedChecksServer() {}
func (UnimplementedChecksServer) testEmbeddedByValue()                {}

// UnsafeChecksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChecksServer will
// result in compilation errors.
type UnsafeChecksServer interface {
	mustEmbedUnimplementedChecksServer()
}

func RegisterChecksServer(s grpc.ServiceRegistrar, srv ChecksServer) {
	// If the following call pancis, it indicates UnimplementedChecksServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Checks_ServiceDesc, srv)
}

func _Checks_Liveness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).Liveness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Checks_Liveness_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).Liveness(ctx, req.(*ChecksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Checks_Readiness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).Readiness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Checks_Readiness_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).Readiness(ctx, req.(*ChecksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Checks_ServiceDesc is the grpc.ServiceDesc for Checks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Checks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.Checks",
	HandlerType: (*ChecksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Liveness",
			Handler:    _Checks_Liveness_Handler,
		},
		{
			MethodName: "Readiness",
			Handler:    _Checks_Readiness_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "research-pillars/api/api.proto",
}
