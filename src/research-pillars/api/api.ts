// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.31.1
// source: research-pillars/api/api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import { HttpBody } from "../../google/api/httpbody";
import { Struct } from "../../google/protobuf/struct";
import { BlockedProgram, Client, DeviceToken, Diff, ParticipantCode, ProgramRole, Questionnaire, User } from "../types";

export const protobufPackage = "proto.api";

export interface GetSelfRequest {
}

export interface GetSelfResponse {
  user?: User | undefined;
}

export interface GetUsersRequest {
}

export interface GetUsersResponse {
  users: User[];
}

export interface DeleteUserRequest {
  userEmail: string;
}

export interface DeleteUserResponse {
}

export interface UpsertProgramRoleRequest {
  programRole?: ProgramRole | undefined;
}

export interface UpsertProgramRoleResponse {
}

export interface DeleteProgramRoleRequest {
  userEmail: string;
  programName: string;
}

export interface DeleteProgramRoleResponse {
}

export interface GetBlockedProgramsRequest {
}

export interface GetBlockedProgramsResponse {
  blockedPrograms: BlockedProgram[];
}

export interface BlockProgramRequest {
  programName: string;
}

export interface BlockProgramResponse {
}

export interface UnblockProgramRequest {
}

export interface UnblockProgramResponse {
}

export interface GetProgramsRequest {
}

export interface GetProgramsResponse {
  programs: { [key: string]: any }[];
}

export interface GetProgramsListRequest {
}

export interface GetProgramsListResponse {
  programNames: string[];
}

export interface IsNameAvailableRequest {
  name: string;
}

export interface IsNameAvailableResponse {
  available: boolean;
}

export interface GetProgramRequest {
  name: string;
}

export interface GetProgramResponse {
  program?: { [key: string]: any } | undefined;
  diffs: Diff[];
}

export interface GetProgramDataRequest {
  name: string;
}

export interface GetProgramDataResponse {
  program?: { [key: string]: any } | undefined;
  surveys: { [key: string]: any }[];
  questionnaires: Questionnaire[];
  consents: { [key: string]: any }[];
  routines: { [key: string]: any }[];
  displays: { [key: string]: any }[];
}

export interface GetProgramDiffsRequest {
  name: string;
}

export interface GetProgramDiffsResponse {
  program: { [key: string]: any }[];
  surveys: { [key: string]: any }[];
  questionnaires: { [key: string]: any }[];
  routines: { [key: string]: any }[];
  displays: { [key: string]: any }[];
}

export interface UpsertProgramRequest {
  program?: { [key: string]: any } | undefined;
  change?: { [key: string]: any } | undefined;
}

export interface UpsertProgramResponse {
}

export interface DeleteProgramRequest {
  name: string;
}

export interface DeleteProgramResponse {
}

export interface PublishProgramRequest {
  name: string;
  forTesting: boolean;
}

export interface PublishProgramResponse {
}

export interface LoadProgramRequest {
  name: string;
}

export interface LoadProgramResponse {
}

export interface GetSurveysRequest {
  programName: string;
}

export interface GetSurveysResponse {
  surveys: { [key: string]: any }[];
}

export interface GetSurveyRequest {
  programName: string;
  name: string;
}

export interface GetSurveyResponse {
  survey?: { [key: string]: any } | undefined;
  diffs: Diff[];
}

export interface UpsertSurveyRequest {
  programName: string;
  survey?: { [key: string]: any } | undefined;
  change?: { [key: string]: any } | undefined;
}

export interface UpsertSurveyResponse {
}

export interface DeleteSurveyRequest {
  programName: string;
  name: string;
}

export interface DeleteSurveyResponse {
}

export interface PublishSurveyRequest {
  programName: string;
  name: string;
}

export interface PublishSurveyResponse {
}

export interface LoadSurveyRequest {
  programName: string;
  name: string;
}

export interface LoadSurveyResponse {
}

export interface GetQuestionnairesRequest {
  programName: string;
}

export interface GetQuestionnairesResponse {
  questionnaires: Questionnaire[];
}

export interface GetQuestionnaireRequest {
  programName: string;
  name: string;
}

export interface GetQuestionnaireResponse {
  questionnaire?: Questionnaire | undefined;
  diffs: Diff[];
}

export interface UpsertQuestionnaireRequest {
  programName: string;
  questionnaire?: Questionnaire | undefined;
  change?: { [key: string]: any } | undefined;
}

export interface UpsertQuestionnaireResponse {
}

export interface DeleteQuestionnaireRequest {
  programName: string;
  name: string;
}

export interface DeleteQuestionnaireResponse {
}

export interface PublishQuestionnaireRequest {
  programName: string;
  name: string;
}

export interface PublishQuestionnaireResponse {
}

export interface LoadQuestionnaireRequest {
  programName: string;
  name: string;
}

export interface LoadQuestionnaireResponse {
}

export interface GetRoutinesRequest {
  programName: string;
}

export interface GetRoutinesResponse {
  routines: { [key: string]: any }[];
}

export interface GetRoutineRequest {
  programName: string;
  name: string;
}

export interface GetRoutineResponse {
  routine?: { [key: string]: any } | undefined;
  diffs: Diff[];
}

export interface UpsertRoutineRequest {
  programName: string;
  routine?: { [key: string]: any } | undefined;
  change?: { [key: string]: any } | undefined;
}

export interface UpsertRoutineResponse {
}

export interface DeleteRoutineRequest {
  programName: string;
  name: string;
}

export interface DeleteRoutineResponse {
}

export interface PublishRoutineRequest {
  programName: string;
  name: string;
}

export interface PublishRoutineResponse {
}

export interface LoadRoutineRequest {
  programName: string;
  name: string;
}

export interface LoadRoutineResponse {
}

export interface GetDisplaysRequest {
  programName: string;
}

export interface GetDisplaysResponse {
  displays: { [key: string]: any }[];
}

export interface GetDisplayRequest {
  programName: string;
  name: string;
}

export interface GetDisplayResponse {
  display?: { [key: string]: any } | undefined;
  diffs: Diff[];
}

export interface UpsertDisplayRequest {
  programName: string;
  display?: { [key: string]: any } | undefined;
  change?: { [key: string]: any } | undefined;
}

export interface UpsertDisplayResponse {
}

export interface DeleteDisplayRequest {
  programName: string;
  name: string;
}

export interface DeleteDisplayResponse {
}

export interface PublishDisplayRequest {
  programName: string;
  name: string;
}

export interface PublishDisplayResponse {
}

export interface LoadDisplayRequest {
  programName: string;
  name: string;
}

export interface LoadDisplayResponse {
}

export interface GetCodesRequest {
  programName: string;
}

export interface GetCodesResponse {
  codes: ParticipantCode[];
}

export interface GenerateCodesRequest {
  programName: string;
  amount: number;
}

export interface GenerateCodesResponse {
}

export interface AssignCodeRequest {
  programName: string;
  code: string;
  alpID: string;
}

export interface AssignCodeResponse {
}

export interface DeleteCodeRequest {
  programName: string;
  code: string;
}

export interface DeleteCodeResponse {
}

export interface UnassignCodeRequest {
  programName: string;
  code: string;
}

export interface UnassignCodeResponse {
}

export interface GetConsentsRequest {
  programName: string;
}

export interface GetConsentsResponse {
  consents: { [key: string]: any }[];
}

export interface GetConsentRequest {
  programName: string;
  name: string;
}

export interface GetConsentResponse {
  consents: { [key: string]: any }[];
}

export interface UpsertConsentRequest {
  programName: string;
  consent?: { [key: string]: any } | undefined;
}

export interface UpsertConsentResponse {
}

export interface DeleteConsentRequest {
  programName: string;
  name: string;
}

export interface DeleteConsentResponse {
}

export interface DeleteConsentVersionRequest {
  programName: string;
  name: string;
  version: number;
}

export interface DeleteConsentVersionResponse {
}

export interface PublishConsentRequest {
  programName: string;
  name: string;
}

export interface PublishConsentResponse {
}

export interface GetStandaloneSurveysRequest {
}

export interface GetStandaloneSurveysResponse {
  surveys: { [key: string]: any }[];
}

export interface GetStandaloneSurveyRequest {
  name: string;
}

export interface GetStandaloneSurveyResponse {
  survey?: { [key: string]: any } | undefined;
}

export interface UpsertStandaloneSurveyRequest {
  survey?: { [key: string]: any } | undefined;
}

export interface UpsertStandaloneSurveyResponse {
}

export interface DeleteStandaloneSurveyRequest {
  name: string;
}

export interface DeleteStandaloneSurveyResponse {
}

export interface GetStandaloneQuestionnairesRequest {
  language: string;
}

export interface GetStandaloneQuestionnairesResponse {
  questionnaires: { [key: string]: any }[];
}

export interface GetStandaloneQuestionnaireRequest {
  name: string;
  language: string;
}

export interface GetStandaloneQuestionnaireResponse {
  questionnaire?: { [key: string]: any } | undefined;
}

export interface UpsertStandaloneQuestionnaireRequest {
  questionnaire?: { [key: string]: any } | undefined;
}

export interface UpsertStandaloneQuestionnaireResponse {
}

export interface DeleteStandaloneQuestionnaireRequest {
  name: string;
  language?: string | undefined;
}

export interface DeleteStandaloneQuestionnaireResponse {
}

export interface GetSubjectsRequest {
  programName: string;
}

export interface GetSubjectsResponse {
  subjects: { [key: string]: any }[];
}

export interface GetSubjectDataRequest {
  programName: string;
  subjectID: string;
}

export interface GetSubjectDataResponse {
  uploads: { [key: string]: any }[];
}

export interface GetSubjectResourceRequest {
  programName: string;
  subjectID: string;
  resourceID: string;
}

export interface GetSubjectResourceResponse {
  resource?: { [key: string]: any } | undefined;
}

export interface GetDownloadListRequest {
  programName: string;
}

export interface GetDownloadListResponse {
  subjects: { [key: string]: any }[];
}

export interface GetDownloadTicketRequest {
  programName: string;
  subjectIDs: string[];
  includeRawFHIR: boolean;
  includeETLCSV: boolean;
}

export interface GetDownloadTicketResponse {
  url: string;
}

export interface GetStatisticsRequest {
  programName: string;
  type: string;
  startDate?: string | undefined;
  endDate?: string | undefined;
  params?: { [key: string]: any } | undefined;
}

export interface GetStatisticsResponse {
  data?: { [key: string]: any } | undefined;
}

export interface GetImageRequest {
  programName: string;
  name: string;
}

export interface UpsertImageRequest {
  programName: string;
  name: string;
  contentType: string;
  data: Uint8Array;
}

export interface UpsertImageResponse {
}

export interface DeleteImageRequest {
  programName: string;
  name: string;
}

export interface DeleteImageResponse {
}

export interface GetClientsRequest {
  programName: string;
}

export interface GetClientsResponse {
  clients: Client[];
}

export interface GetClientRequest {
  programName: string;
  name: string;
}

export interface GetClientResponse {
  client?: Client | undefined;
}

export interface UpsertClientRequest {
  programName: string;
  name: string;
  clientID: string;
  clientSecret: string;
}

export interface UpsertClientResponse {
}

export interface ExchangeTokenRequest {
  name: string;
  programName: string;
  clientID: string;
  clientSecret: string;
  params?: { [key: string]: any } | undefined;
}

export interface ExchangeTokenResponse {
  body?: { [key: string]: any } | undefined;
}

export interface DeleteClientRequest {
  programName: string;
  name: string;
}

export interface DeleteClientResponse {
}

export interface GetMessagesRequest {
  programName: string;
}

export interface GetMessagesResponse {
  messages: { [key: string]: any }[];
}

export interface GetMessageRequest {
  programName: string;
  name: string;
}

export interface GetMessageResponse {
  message?: { [key: string]: any } | undefined;
  recipients: { [key: string]: any }[];
}

export interface UpsertMessageRequest {
  programName: string;
  message?: { [key: string]: any } | undefined;
}

export interface UpsertMessageResponse {
}

export interface DeleteMessageRequest {
  programName: string;
  name: string;
}

export interface DeleteMessageResponse {
}

export interface SendMessageRequest {
  programName: string;
  name: string;
}

export interface SendMessageResponse {
}

export interface GetTokensRequest {
  programName: string;
}

export interface GetTokensResponse {
  tokens: DeviceToken[];
}

export interface UpsertTokenRequest {
  programName: string;
  subjectID: string;
  token: string;
}

export interface UpsertTokenResponse {
}

export interface DeleteTokenRequest {
  programName: string;
  subjectID: string;
}

export interface DeleteTokenResponse {
}

export interface ChecksRequest {
}

export interface ChecksResponse {
  response: string;
}

function createBaseGetSelfRequest(): GetSelfRequest {
  return {};
}

export const GetSelfRequest: MessageFns<GetSelfRequest> = {
  encode(_: GetSelfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSelfRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSelfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetSelfRequest {
    return {};
  },

  toJSON(_: GetSelfRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSelfRequest>, I>>(base?: I): GetSelfRequest {
    return GetSelfRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSelfRequest>, I>>(_: I): GetSelfRequest {
    const message = createBaseGetSelfRequest();
    return message;
  },
};

function createBaseGetSelfResponse(): GetSelfResponse {
  return { user: undefined };
}

export const GetSelfResponse: MessageFns<GetSelfResponse> = {
  encode(message: GetSelfResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSelfResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSelfResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSelfResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: GetSelfResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSelfResponse>, I>>(base?: I): GetSelfResponse {
    return GetSelfResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSelfResponse>, I>>(object: I): GetSelfResponse {
    const message = createBaseGetSelfResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetUsersRequest(): GetUsersRequest {
  return {};
}

export const GetUsersRequest: MessageFns<GetUsersRequest> = {
  encode(_: GetUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetUsersRequest {
    return {};
  },

  toJSON(_: GetUsersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersRequest>, I>>(base?: I): GetUsersRequest {
    return GetUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersRequest>, I>>(_: I): GetUsersRequest {
    const message = createBaseGetUsersRequest();
    return message;
  },
};

function createBaseGetUsersResponse(): GetUsersResponse {
  return { users: [] };
}

export const GetUsersResponse: MessageFns<GetUsersResponse> = {
  encode(message: GetUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersResponse {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: GetUsersResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersResponse>, I>>(base?: I): GetUsersResponse {
    return GetUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersResponse>, I>>(object: I): GetUsersResponse {
    const message = createBaseGetUsersResponse();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { userEmail: "" };
}

export const DeleteUserRequest: MessageFns<DeleteUserRequest> = {
  encode(message: DeleteUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userEmail !== "") {
      writer.uint32(10).string(message.userEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return { userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "" };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.userEmail = object.userEmail ?? "";
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return {};
}

export const DeleteUserResponse: MessageFns<DeleteUserResponse> = {
  encode(_: DeleteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteUserResponse {
    return {};
  },

  toJSON(_: DeleteUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(_: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    return message;
  },
};

function createBaseUpsertProgramRoleRequest(): UpsertProgramRoleRequest {
  return { programRole: undefined };
}

export const UpsertProgramRoleRequest: MessageFns<UpsertProgramRoleRequest> = {
  encode(message: UpsertProgramRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programRole !== undefined) {
      ProgramRole.encode(message.programRole, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertProgramRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertProgramRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programRole = ProgramRole.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertProgramRoleRequest {
    return { programRole: isSet(object.programRole) ? ProgramRole.fromJSON(object.programRole) : undefined };
  },

  toJSON(message: UpsertProgramRoleRequest): unknown {
    const obj: any = {};
    if (message.programRole !== undefined) {
      obj.programRole = ProgramRole.toJSON(message.programRole);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertProgramRoleRequest>, I>>(base?: I): UpsertProgramRoleRequest {
    return UpsertProgramRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertProgramRoleRequest>, I>>(object: I): UpsertProgramRoleRequest {
    const message = createBaseUpsertProgramRoleRequest();
    message.programRole = (object.programRole !== undefined && object.programRole !== null)
      ? ProgramRole.fromPartial(object.programRole)
      : undefined;
    return message;
  },
};

function createBaseUpsertProgramRoleResponse(): UpsertProgramRoleResponse {
  return {};
}

export const UpsertProgramRoleResponse: MessageFns<UpsertProgramRoleResponse> = {
  encode(_: UpsertProgramRoleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertProgramRoleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertProgramRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertProgramRoleResponse {
    return {};
  },

  toJSON(_: UpsertProgramRoleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertProgramRoleResponse>, I>>(base?: I): UpsertProgramRoleResponse {
    return UpsertProgramRoleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertProgramRoleResponse>, I>>(_: I): UpsertProgramRoleResponse {
    const message = createBaseUpsertProgramRoleResponse();
    return message;
  },
};

function createBaseDeleteProgramRoleRequest(): DeleteProgramRoleRequest {
  return { userEmail: "", programName: "" };
}

export const DeleteProgramRoleRequest: MessageFns<DeleteProgramRoleRequest> = {
  encode(message: DeleteProgramRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userEmail !== "") {
      writer.uint32(10).string(message.userEmail);
    }
    if (message.programName !== "") {
      writer.uint32(18).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProgramRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProgramRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProgramRoleRequest {
    return {
      userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "",
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
    };
  },

  toJSON(message: DeleteProgramRoleRequest): unknown {
    const obj: any = {};
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProgramRoleRequest>, I>>(base?: I): DeleteProgramRoleRequest {
    return DeleteProgramRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProgramRoleRequest>, I>>(object: I): DeleteProgramRoleRequest {
    const message = createBaseDeleteProgramRoleRequest();
    message.userEmail = object.userEmail ?? "";
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseDeleteProgramRoleResponse(): DeleteProgramRoleResponse {
  return {};
}

export const DeleteProgramRoleResponse: MessageFns<DeleteProgramRoleResponse> = {
  encode(_: DeleteProgramRoleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProgramRoleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProgramRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteProgramRoleResponse {
    return {};
  },

  toJSON(_: DeleteProgramRoleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProgramRoleResponse>, I>>(base?: I): DeleteProgramRoleResponse {
    return DeleteProgramRoleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProgramRoleResponse>, I>>(_: I): DeleteProgramRoleResponse {
    const message = createBaseDeleteProgramRoleResponse();
    return message;
  },
};

function createBaseGetBlockedProgramsRequest(): GetBlockedProgramsRequest {
  return {};
}

export const GetBlockedProgramsRequest: MessageFns<GetBlockedProgramsRequest> = {
  encode(_: GetBlockedProgramsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockedProgramsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockedProgramsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetBlockedProgramsRequest {
    return {};
  },

  toJSON(_: GetBlockedProgramsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockedProgramsRequest>, I>>(base?: I): GetBlockedProgramsRequest {
    return GetBlockedProgramsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockedProgramsRequest>, I>>(_: I): GetBlockedProgramsRequest {
    const message = createBaseGetBlockedProgramsRequest();
    return message;
  },
};

function createBaseGetBlockedProgramsResponse(): GetBlockedProgramsResponse {
  return { blockedPrograms: [] };
}

export const GetBlockedProgramsResponse: MessageFns<GetBlockedProgramsResponse> = {
  encode(message: GetBlockedProgramsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blockedPrograms) {
      BlockedProgram.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockedProgramsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockedProgramsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockedPrograms.push(BlockedProgram.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockedProgramsResponse {
    return {
      blockedPrograms: globalThis.Array.isArray(object?.blockedPrograms)
        ? object.blockedPrograms.map((e: any) => BlockedProgram.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetBlockedProgramsResponse): unknown {
    const obj: any = {};
    if (message.blockedPrograms?.length) {
      obj.blockedPrograms = message.blockedPrograms.map((e) => BlockedProgram.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockedProgramsResponse>, I>>(base?: I): GetBlockedProgramsResponse {
    return GetBlockedProgramsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockedProgramsResponse>, I>>(object: I): GetBlockedProgramsResponse {
    const message = createBaseGetBlockedProgramsResponse();
    message.blockedPrograms = object.blockedPrograms?.map((e) => BlockedProgram.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockProgramRequest(): BlockProgramRequest {
  return { programName: "" };
}

export const BlockProgramRequest: MessageFns<BlockProgramRequest> = {
  encode(message: BlockProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockProgramRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: BlockProgramRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockProgramRequest>, I>>(base?: I): BlockProgramRequest {
    return BlockProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockProgramRequest>, I>>(object: I): BlockProgramRequest {
    const message = createBaseBlockProgramRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseBlockProgramResponse(): BlockProgramResponse {
  return {};
}

export const BlockProgramResponse: MessageFns<BlockProgramResponse> = {
  encode(_: BlockProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BlockProgramResponse {
    return {};
  },

  toJSON(_: BlockProgramResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockProgramResponse>, I>>(base?: I): BlockProgramResponse {
    return BlockProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockProgramResponse>, I>>(_: I): BlockProgramResponse {
    const message = createBaseBlockProgramResponse();
    return message;
  },
};

function createBaseUnblockProgramRequest(): UnblockProgramRequest {
  return {};
}

export const UnblockProgramRequest: MessageFns<UnblockProgramRequest> = {
  encode(_: UnblockProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnblockProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UnblockProgramRequest {
    return {};
  },

  toJSON(_: UnblockProgramRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UnblockProgramRequest>, I>>(base?: I): UnblockProgramRequest {
    return UnblockProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnblockProgramRequest>, I>>(_: I): UnblockProgramRequest {
    const message = createBaseUnblockProgramRequest();
    return message;
  },
};

function createBaseUnblockProgramResponse(): UnblockProgramResponse {
  return {};
}

export const UnblockProgramResponse: MessageFns<UnblockProgramResponse> = {
  encode(_: UnblockProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnblockProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UnblockProgramResponse {
    return {};
  },

  toJSON(_: UnblockProgramResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UnblockProgramResponse>, I>>(base?: I): UnblockProgramResponse {
    return UnblockProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnblockProgramResponse>, I>>(_: I): UnblockProgramResponse {
    const message = createBaseUnblockProgramResponse();
    return message;
  },
};

function createBaseGetProgramsRequest(): GetProgramsRequest {
  return {};
}

export const GetProgramsRequest: MessageFns<GetProgramsRequest> = {
  encode(_: GetProgramsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetProgramsRequest {
    return {};
  },

  toJSON(_: GetProgramsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramsRequest>, I>>(base?: I): GetProgramsRequest {
    return GetProgramsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramsRequest>, I>>(_: I): GetProgramsRequest {
    const message = createBaseGetProgramsRequest();
    return message;
  },
};

function createBaseGetProgramsResponse(): GetProgramsResponse {
  return { programs: [] };
}

export const GetProgramsResponse: MessageFns<GetProgramsResponse> = {
  encode(message: GetProgramsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.programs) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programs.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramsResponse {
    return { programs: globalThis.Array.isArray(object?.programs) ? [...object.programs] : [] };
  },

  toJSON(message: GetProgramsResponse): unknown {
    const obj: any = {};
    if (message.programs?.length) {
      obj.programs = message.programs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramsResponse>, I>>(base?: I): GetProgramsResponse {
    return GetProgramsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramsResponse>, I>>(object: I): GetProgramsResponse {
    const message = createBaseGetProgramsResponse();
    message.programs = object.programs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProgramsListRequest(): GetProgramsListRequest {
  return {};
}

export const GetProgramsListRequest: MessageFns<GetProgramsListRequest> = {
  encode(_: GetProgramsListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramsListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramsListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetProgramsListRequest {
    return {};
  },

  toJSON(_: GetProgramsListRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramsListRequest>, I>>(base?: I): GetProgramsListRequest {
    return GetProgramsListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramsListRequest>, I>>(_: I): GetProgramsListRequest {
    const message = createBaseGetProgramsListRequest();
    return message;
  },
};

function createBaseGetProgramsListResponse(): GetProgramsListResponse {
  return { programNames: [] };
}

export const GetProgramsListResponse: MessageFns<GetProgramsListResponse> = {
  encode(message: GetProgramsListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.programNames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramsListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramsListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programNames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramsListResponse {
    return {
      programNames: globalThis.Array.isArray(object?.programNames)
        ? object.programNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetProgramsListResponse): unknown {
    const obj: any = {};
    if (message.programNames?.length) {
      obj.programNames = message.programNames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramsListResponse>, I>>(base?: I): GetProgramsListResponse {
    return GetProgramsListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramsListResponse>, I>>(object: I): GetProgramsListResponse {
    const message = createBaseGetProgramsListResponse();
    message.programNames = object.programNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseIsNameAvailableRequest(): IsNameAvailableRequest {
  return { name: "" };
}

export const IsNameAvailableRequest: MessageFns<IsNameAvailableRequest> = {
  encode(message: IsNameAvailableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsNameAvailableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsNameAvailableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsNameAvailableRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: IsNameAvailableRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsNameAvailableRequest>, I>>(base?: I): IsNameAvailableRequest {
    return IsNameAvailableRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsNameAvailableRequest>, I>>(object: I): IsNameAvailableRequest {
    const message = createBaseIsNameAvailableRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseIsNameAvailableResponse(): IsNameAvailableResponse {
  return { available: false };
}

export const IsNameAvailableResponse: MessageFns<IsNameAvailableResponse> = {
  encode(message: IsNameAvailableResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.available !== false) {
      writer.uint32(8).bool(message.available);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsNameAvailableResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsNameAvailableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.available = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsNameAvailableResponse {
    return { available: isSet(object.available) ? globalThis.Boolean(object.available) : false };
  },

  toJSON(message: IsNameAvailableResponse): unknown {
    const obj: any = {};
    if (message.available !== false) {
      obj.available = message.available;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsNameAvailableResponse>, I>>(base?: I): IsNameAvailableResponse {
    return IsNameAvailableResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsNameAvailableResponse>, I>>(object: I): IsNameAvailableResponse {
    const message = createBaseIsNameAvailableResponse();
    message.available = object.available ?? false;
    return message;
  },
};

function createBaseGetProgramRequest(): GetProgramRequest {
  return { name: "" };
}

export const GetProgramRequest: MessageFns<GetProgramRequest> = {
  encode(message: GetProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProgramRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramRequest>, I>>(base?: I): GetProgramRequest {
    return GetProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramRequest>, I>>(object: I): GetProgramRequest {
    const message = createBaseGetProgramRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProgramResponse(): GetProgramResponse {
  return { program: undefined, diffs: [] };
}

export const GetProgramResponse: MessageFns<GetProgramResponse> = {
  encode(message: GetProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== undefined) {
      Struct.encode(Struct.wrap(message.program), writer.uint32(10).fork()).join();
    }
    for (const v of message.diffs) {
      Diff.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.program = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diffs.push(Diff.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramResponse {
    return {
      program: isObject(object.program) ? object.program : undefined,
      diffs: globalThis.Array.isArray(object?.diffs) ? object.diffs.map((e: any) => Diff.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetProgramResponse): unknown {
    const obj: any = {};
    if (message.program !== undefined) {
      obj.program = message.program;
    }
    if (message.diffs?.length) {
      obj.diffs = message.diffs.map((e) => Diff.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramResponse>, I>>(base?: I): GetProgramResponse {
    return GetProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramResponse>, I>>(object: I): GetProgramResponse {
    const message = createBaseGetProgramResponse();
    message.program = object.program ?? undefined;
    message.diffs = object.diffs?.map((e) => Diff.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProgramDataRequest(): GetProgramDataRequest {
  return { name: "" };
}

export const GetProgramDataRequest: MessageFns<GetProgramDataRequest> = {
  encode(message: GetProgramDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramDataRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProgramDataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramDataRequest>, I>>(base?: I): GetProgramDataRequest {
    return GetProgramDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramDataRequest>, I>>(object: I): GetProgramDataRequest {
    const message = createBaseGetProgramDataRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProgramDataResponse(): GetProgramDataResponse {
  return { program: undefined, surveys: [], questionnaires: [], consents: [], routines: [], displays: [] };
}

export const GetProgramDataResponse: MessageFns<GetProgramDataResponse> = {
  encode(message: GetProgramDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== undefined) {
      Struct.encode(Struct.wrap(message.program), writer.uint32(10).fork()).join();
    }
    for (const v of message.surveys) {
      Struct.encode(Struct.wrap(v!), writer.uint32(18).fork()).join();
    }
    for (const v of message.questionnaires) {
      Questionnaire.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.consents) {
      Struct.encode(Struct.wrap(v!), writer.uint32(34).fork()).join();
    }
    for (const v of message.routines) {
      Struct.encode(Struct.wrap(v!), writer.uint32(42).fork()).join();
    }
    for (const v of message.displays) {
      Struct.encode(Struct.wrap(v!), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.program = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.surveys.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.questionnaires.push(Questionnaire.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.consents.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.routines.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displays.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramDataResponse {
    return {
      program: isObject(object.program) ? object.program : undefined,
      surveys: globalThis.Array.isArray(object?.surveys) ? [...object.surveys] : [],
      questionnaires: globalThis.Array.isArray(object?.questionnaires)
        ? object.questionnaires.map((e: any) => Questionnaire.fromJSON(e))
        : [],
      consents: globalThis.Array.isArray(object?.consents) ? [...object.consents] : [],
      routines: globalThis.Array.isArray(object?.routines) ? [...object.routines] : [],
      displays: globalThis.Array.isArray(object?.displays) ? [...object.displays] : [],
    };
  },

  toJSON(message: GetProgramDataResponse): unknown {
    const obj: any = {};
    if (message.program !== undefined) {
      obj.program = message.program;
    }
    if (message.surveys?.length) {
      obj.surveys = message.surveys;
    }
    if (message.questionnaires?.length) {
      obj.questionnaires = message.questionnaires.map((e) => Questionnaire.toJSON(e));
    }
    if (message.consents?.length) {
      obj.consents = message.consents;
    }
    if (message.routines?.length) {
      obj.routines = message.routines;
    }
    if (message.displays?.length) {
      obj.displays = message.displays;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramDataResponse>, I>>(base?: I): GetProgramDataResponse {
    return GetProgramDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramDataResponse>, I>>(object: I): GetProgramDataResponse {
    const message = createBaseGetProgramDataResponse();
    message.program = object.program ?? undefined;
    message.surveys = object.surveys?.map((e) => e) || [];
    message.questionnaires = object.questionnaires?.map((e) => Questionnaire.fromPartial(e)) || [];
    message.consents = object.consents?.map((e) => e) || [];
    message.routines = object.routines?.map((e) => e) || [];
    message.displays = object.displays?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProgramDiffsRequest(): GetProgramDiffsRequest {
  return { name: "" };
}

export const GetProgramDiffsRequest: MessageFns<GetProgramDiffsRequest> = {
  encode(message: GetProgramDiffsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramDiffsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramDiffsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramDiffsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProgramDiffsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramDiffsRequest>, I>>(base?: I): GetProgramDiffsRequest {
    return GetProgramDiffsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramDiffsRequest>, I>>(object: I): GetProgramDiffsRequest {
    const message = createBaseGetProgramDiffsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProgramDiffsResponse(): GetProgramDiffsResponse {
  return { program: [], surveys: [], questionnaires: [], routines: [], displays: [] };
}

export const GetProgramDiffsResponse: MessageFns<GetProgramDiffsResponse> = {
  encode(message: GetProgramDiffsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.program) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    for (const v of message.surveys) {
      Struct.encode(Struct.wrap(v!), writer.uint32(18).fork()).join();
    }
    for (const v of message.questionnaires) {
      Struct.encode(Struct.wrap(v!), writer.uint32(26).fork()).join();
    }
    for (const v of message.routines) {
      Struct.encode(Struct.wrap(v!), writer.uint32(34).fork()).join();
    }
    for (const v of message.displays) {
      Struct.encode(Struct.wrap(v!), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramDiffsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramDiffsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.program.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.surveys.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.questionnaires.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.routines.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.displays.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramDiffsResponse {
    return {
      program: globalThis.Array.isArray(object?.program) ? [...object.program] : [],
      surveys: globalThis.Array.isArray(object?.surveys) ? [...object.surveys] : [],
      questionnaires: globalThis.Array.isArray(object?.questionnaires) ? [...object.questionnaires] : [],
      routines: globalThis.Array.isArray(object?.routines) ? [...object.routines] : [],
      displays: globalThis.Array.isArray(object?.displays) ? [...object.displays] : [],
    };
  },

  toJSON(message: GetProgramDiffsResponse): unknown {
    const obj: any = {};
    if (message.program?.length) {
      obj.program = message.program;
    }
    if (message.surveys?.length) {
      obj.surveys = message.surveys;
    }
    if (message.questionnaires?.length) {
      obj.questionnaires = message.questionnaires;
    }
    if (message.routines?.length) {
      obj.routines = message.routines;
    }
    if (message.displays?.length) {
      obj.displays = message.displays;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramDiffsResponse>, I>>(base?: I): GetProgramDiffsResponse {
    return GetProgramDiffsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramDiffsResponse>, I>>(object: I): GetProgramDiffsResponse {
    const message = createBaseGetProgramDiffsResponse();
    message.program = object.program?.map((e) => e) || [];
    message.surveys = object.surveys?.map((e) => e) || [];
    message.questionnaires = object.questionnaires?.map((e) => e) || [];
    message.routines = object.routines?.map((e) => e) || [];
    message.displays = object.displays?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpsertProgramRequest(): UpsertProgramRequest {
  return { program: undefined, change: undefined };
}

export const UpsertProgramRequest: MessageFns<UpsertProgramRequest> = {
  encode(message: UpsertProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== undefined) {
      Struct.encode(Struct.wrap(message.program), writer.uint32(10).fork()).join();
    }
    if (message.change !== undefined) {
      Struct.encode(Struct.wrap(message.change), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.program = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.change = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertProgramRequest {
    return {
      program: isObject(object.program) ? object.program : undefined,
      change: isObject(object.change) ? object.change : undefined,
    };
  },

  toJSON(message: UpsertProgramRequest): unknown {
    const obj: any = {};
    if (message.program !== undefined) {
      obj.program = message.program;
    }
    if (message.change !== undefined) {
      obj.change = message.change;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertProgramRequest>, I>>(base?: I): UpsertProgramRequest {
    return UpsertProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertProgramRequest>, I>>(object: I): UpsertProgramRequest {
    const message = createBaseUpsertProgramRequest();
    message.program = object.program ?? undefined;
    message.change = object.change ?? undefined;
    return message;
  },
};

function createBaseUpsertProgramResponse(): UpsertProgramResponse {
  return {};
}

export const UpsertProgramResponse: MessageFns<UpsertProgramResponse> = {
  encode(_: UpsertProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertProgramResponse {
    return {};
  },

  toJSON(_: UpsertProgramResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertProgramResponse>, I>>(base?: I): UpsertProgramResponse {
    return UpsertProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertProgramResponse>, I>>(_: I): UpsertProgramResponse {
    const message = createBaseUpsertProgramResponse();
    return message;
  },
};

function createBaseDeleteProgramRequest(): DeleteProgramRequest {
  return { name: "" };
}

export const DeleteProgramRequest: MessageFns<DeleteProgramRequest> = {
  encode(message: DeleteProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProgramRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteProgramRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProgramRequest>, I>>(base?: I): DeleteProgramRequest {
    return DeleteProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProgramRequest>, I>>(object: I): DeleteProgramRequest {
    const message = createBaseDeleteProgramRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteProgramResponse(): DeleteProgramResponse {
  return {};
}

export const DeleteProgramResponse: MessageFns<DeleteProgramResponse> = {
  encode(_: DeleteProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteProgramResponse {
    return {};
  },

  toJSON(_: DeleteProgramResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProgramResponse>, I>>(base?: I): DeleteProgramResponse {
    return DeleteProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProgramResponse>, I>>(_: I): DeleteProgramResponse {
    const message = createBaseDeleteProgramResponse();
    return message;
  },
};

function createBasePublishProgramRequest(): PublishProgramRequest {
  return { name: "", forTesting: false };
}

export const PublishProgramRequest: MessageFns<PublishProgramRequest> = {
  encode(message: PublishProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.forTesting !== false) {
      writer.uint32(16).bool(message.forTesting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.forTesting = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishProgramRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      forTesting: isSet(object.forTesting) ? globalThis.Boolean(object.forTesting) : false,
    };
  },

  toJSON(message: PublishProgramRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.forTesting !== false) {
      obj.forTesting = message.forTesting;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishProgramRequest>, I>>(base?: I): PublishProgramRequest {
    return PublishProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishProgramRequest>, I>>(object: I): PublishProgramRequest {
    const message = createBasePublishProgramRequest();
    message.name = object.name ?? "";
    message.forTesting = object.forTesting ?? false;
    return message;
  },
};

function createBasePublishProgramResponse(): PublishProgramResponse {
  return {};
}

export const PublishProgramResponse: MessageFns<PublishProgramResponse> = {
  encode(_: PublishProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishProgramResponse {
    return {};
  },

  toJSON(_: PublishProgramResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishProgramResponse>, I>>(base?: I): PublishProgramResponse {
    return PublishProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishProgramResponse>, I>>(_: I): PublishProgramResponse {
    const message = createBasePublishProgramResponse();
    return message;
  },
};

function createBaseLoadProgramRequest(): LoadProgramRequest {
  return { name: "" };
}

export const LoadProgramRequest: MessageFns<LoadProgramRequest> = {
  encode(message: LoadProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadProgramRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: LoadProgramRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadProgramRequest>, I>>(base?: I): LoadProgramRequest {
    return LoadProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadProgramRequest>, I>>(object: I): LoadProgramRequest {
    const message = createBaseLoadProgramRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLoadProgramResponse(): LoadProgramResponse {
  return {};
}

export const LoadProgramResponse: MessageFns<LoadProgramResponse> = {
  encode(_: LoadProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LoadProgramResponse {
    return {};
  },

  toJSON(_: LoadProgramResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadProgramResponse>, I>>(base?: I): LoadProgramResponse {
    return LoadProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadProgramResponse>, I>>(_: I): LoadProgramResponse {
    const message = createBaseLoadProgramResponse();
    return message;
  },
};

function createBaseGetSurveysRequest(): GetSurveysRequest {
  return { programName: "" };
}

export const GetSurveysRequest: MessageFns<GetSurveysRequest> = {
  encode(message: GetSurveysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveysRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetSurveysRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveysRequest>, I>>(base?: I): GetSurveysRequest {
    return GetSurveysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveysRequest>, I>>(object: I): GetSurveysRequest {
    const message = createBaseGetSurveysRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetSurveysResponse(): GetSurveysResponse {
  return { surveys: [] };
}

export const GetSurveysResponse: MessageFns<GetSurveysResponse> = {
  encode(message: GetSurveysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.surveys) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.surveys.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveysResponse {
    return { surveys: globalThis.Array.isArray(object?.surveys) ? [...object.surveys] : [] };
  },

  toJSON(message: GetSurveysResponse): unknown {
    const obj: any = {};
    if (message.surveys?.length) {
      obj.surveys = message.surveys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveysResponse>, I>>(base?: I): GetSurveysResponse {
    return GetSurveysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveysResponse>, I>>(object: I): GetSurveysResponse {
    const message = createBaseGetSurveysResponse();
    message.surveys = object.surveys?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSurveyRequest(): GetSurveyRequest {
  return { programName: "", name: "" };
}

export const GetSurveyRequest: MessageFns<GetSurveyRequest> = {
  encode(message: GetSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveyRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetSurveyRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveyRequest>, I>>(base?: I): GetSurveyRequest {
    return GetSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveyRequest>, I>>(object: I): GetSurveyRequest {
    const message = createBaseGetSurveyRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetSurveyResponse(): GetSurveyResponse {
  return { survey: undefined, diffs: [] };
}

export const GetSurveyResponse: MessageFns<GetSurveyResponse> = {
  encode(message: GetSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.survey !== undefined) {
      Struct.encode(Struct.wrap(message.survey), writer.uint32(10).fork()).join();
    }
    for (const v of message.diffs) {
      Diff.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.survey = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diffs.push(Diff.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveyResponse {
    return {
      survey: isObject(object.survey) ? object.survey : undefined,
      diffs: globalThis.Array.isArray(object?.diffs) ? object.diffs.map((e: any) => Diff.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetSurveyResponse): unknown {
    const obj: any = {};
    if (message.survey !== undefined) {
      obj.survey = message.survey;
    }
    if (message.diffs?.length) {
      obj.diffs = message.diffs.map((e) => Diff.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveyResponse>, I>>(base?: I): GetSurveyResponse {
    return GetSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveyResponse>, I>>(object: I): GetSurveyResponse {
    const message = createBaseGetSurveyResponse();
    message.survey = object.survey ?? undefined;
    message.diffs = object.diffs?.map((e) => Diff.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpsertSurveyRequest(): UpsertSurveyRequest {
  return { programName: "", survey: undefined, change: undefined };
}

export const UpsertSurveyRequest: MessageFns<UpsertSurveyRequest> = {
  encode(message: UpsertSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.survey !== undefined) {
      Struct.encode(Struct.wrap(message.survey), writer.uint32(18).fork()).join();
    }
    if (message.change !== undefined) {
      Struct.encode(Struct.wrap(message.change), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.survey = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.change = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertSurveyRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      survey: isObject(object.survey) ? object.survey : undefined,
      change: isObject(object.change) ? object.change : undefined,
    };
  },

  toJSON(message: UpsertSurveyRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.survey !== undefined) {
      obj.survey = message.survey;
    }
    if (message.change !== undefined) {
      obj.change = message.change;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertSurveyRequest>, I>>(base?: I): UpsertSurveyRequest {
    return UpsertSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertSurveyRequest>, I>>(object: I): UpsertSurveyRequest {
    const message = createBaseUpsertSurveyRequest();
    message.programName = object.programName ?? "";
    message.survey = object.survey ?? undefined;
    message.change = object.change ?? undefined;
    return message;
  },
};

function createBaseUpsertSurveyResponse(): UpsertSurveyResponse {
  return {};
}

export const UpsertSurveyResponse: MessageFns<UpsertSurveyResponse> = {
  encode(_: UpsertSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertSurveyResponse {
    return {};
  },

  toJSON(_: UpsertSurveyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertSurveyResponse>, I>>(base?: I): UpsertSurveyResponse {
    return UpsertSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertSurveyResponse>, I>>(_: I): UpsertSurveyResponse {
    const message = createBaseUpsertSurveyResponse();
    return message;
  },
};

function createBaseDeleteSurveyRequest(): DeleteSurveyRequest {
  return { programName: "", name: "" };
}

export const DeleteSurveyRequest: MessageFns<DeleteSurveyRequest> = {
  encode(message: DeleteSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSurveyRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteSurveyRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSurveyRequest>, I>>(base?: I): DeleteSurveyRequest {
    return DeleteSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSurveyRequest>, I>>(object: I): DeleteSurveyRequest {
    const message = createBaseDeleteSurveyRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteSurveyResponse(): DeleteSurveyResponse {
  return {};
}

export const DeleteSurveyResponse: MessageFns<DeleteSurveyResponse> = {
  encode(_: DeleteSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteSurveyResponse {
    return {};
  },

  toJSON(_: DeleteSurveyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSurveyResponse>, I>>(base?: I): DeleteSurveyResponse {
    return DeleteSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSurveyResponse>, I>>(_: I): DeleteSurveyResponse {
    const message = createBaseDeleteSurveyResponse();
    return message;
  },
};

function createBasePublishSurveyRequest(): PublishSurveyRequest {
  return { programName: "", name: "" };
}

export const PublishSurveyRequest: MessageFns<PublishSurveyRequest> = {
  encode(message: PublishSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishSurveyRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PublishSurveyRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishSurveyRequest>, I>>(base?: I): PublishSurveyRequest {
    return PublishSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishSurveyRequest>, I>>(object: I): PublishSurveyRequest {
    const message = createBasePublishSurveyRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePublishSurveyResponse(): PublishSurveyResponse {
  return {};
}

export const PublishSurveyResponse: MessageFns<PublishSurveyResponse> = {
  encode(_: PublishSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishSurveyResponse {
    return {};
  },

  toJSON(_: PublishSurveyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishSurveyResponse>, I>>(base?: I): PublishSurveyResponse {
    return PublishSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishSurveyResponse>, I>>(_: I): PublishSurveyResponse {
    const message = createBasePublishSurveyResponse();
    return message;
  },
};

function createBaseLoadSurveyRequest(): LoadSurveyRequest {
  return { programName: "", name: "" };
}

export const LoadSurveyRequest: MessageFns<LoadSurveyRequest> = {
  encode(message: LoadSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadSurveyRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: LoadSurveyRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadSurveyRequest>, I>>(base?: I): LoadSurveyRequest {
    return LoadSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadSurveyRequest>, I>>(object: I): LoadSurveyRequest {
    const message = createBaseLoadSurveyRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLoadSurveyResponse(): LoadSurveyResponse {
  return {};
}

export const LoadSurveyResponse: MessageFns<LoadSurveyResponse> = {
  encode(_: LoadSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LoadSurveyResponse {
    return {};
  },

  toJSON(_: LoadSurveyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadSurveyResponse>, I>>(base?: I): LoadSurveyResponse {
    return LoadSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadSurveyResponse>, I>>(_: I): LoadSurveyResponse {
    const message = createBaseLoadSurveyResponse();
    return message;
  },
};

function createBaseGetQuestionnairesRequest(): GetQuestionnairesRequest {
  return { programName: "" };
}

export const GetQuestionnairesRequest: MessageFns<GetQuestionnairesRequest> = {
  encode(message: GetQuestionnairesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnairesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnairesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnairesRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetQuestionnairesRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnairesRequest>, I>>(base?: I): GetQuestionnairesRequest {
    return GetQuestionnairesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnairesRequest>, I>>(object: I): GetQuestionnairesRequest {
    const message = createBaseGetQuestionnairesRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetQuestionnairesResponse(): GetQuestionnairesResponse {
  return { questionnaires: [] };
}

export const GetQuestionnairesResponse: MessageFns<GetQuestionnairesResponse> = {
  encode(message: GetQuestionnairesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.questionnaires) {
      Questionnaire.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnairesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnairesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionnaires.push(Questionnaire.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnairesResponse {
    return {
      questionnaires: globalThis.Array.isArray(object?.questionnaires)
        ? object.questionnaires.map((e: any) => Questionnaire.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetQuestionnairesResponse): unknown {
    const obj: any = {};
    if (message.questionnaires?.length) {
      obj.questionnaires = message.questionnaires.map((e) => Questionnaire.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnairesResponse>, I>>(base?: I): GetQuestionnairesResponse {
    return GetQuestionnairesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnairesResponse>, I>>(object: I): GetQuestionnairesResponse {
    const message = createBaseGetQuestionnairesResponse();
    message.questionnaires = object.questionnaires?.map((e) => Questionnaire.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuestionnaireRequest(): GetQuestionnaireRequest {
  return { programName: "", name: "" };
}

export const GetQuestionnaireRequest: MessageFns<GetQuestionnaireRequest> = {
  encode(message: GetQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnaireRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnaireRequest>, I>>(base?: I): GetQuestionnaireRequest {
    return GetQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnaireRequest>, I>>(object: I): GetQuestionnaireRequest {
    const message = createBaseGetQuestionnaireRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetQuestionnaireResponse(): GetQuestionnaireResponse {
  return { questionnaire: undefined, diffs: [] };
}

export const GetQuestionnaireResponse: MessageFns<GetQuestionnaireResponse> = {
  encode(message: GetQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionnaire !== undefined) {
      Questionnaire.encode(message.questionnaire, writer.uint32(10).fork()).join();
    }
    for (const v of message.diffs) {
      Diff.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionnaire = Questionnaire.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diffs.push(Diff.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnaireResponse {
    return {
      questionnaire: isSet(object.questionnaire) ? Questionnaire.fromJSON(object.questionnaire) : undefined,
      diffs: globalThis.Array.isArray(object?.diffs) ? object.diffs.map((e: any) => Diff.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetQuestionnaireResponse): unknown {
    const obj: any = {};
    if (message.questionnaire !== undefined) {
      obj.questionnaire = Questionnaire.toJSON(message.questionnaire);
    }
    if (message.diffs?.length) {
      obj.diffs = message.diffs.map((e) => Diff.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnaireResponse>, I>>(base?: I): GetQuestionnaireResponse {
    return GetQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnaireResponse>, I>>(object: I): GetQuestionnaireResponse {
    const message = createBaseGetQuestionnaireResponse();
    message.questionnaire = (object.questionnaire !== undefined && object.questionnaire !== null)
      ? Questionnaire.fromPartial(object.questionnaire)
      : undefined;
    message.diffs = object.diffs?.map((e) => Diff.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpsertQuestionnaireRequest(): UpsertQuestionnaireRequest {
  return { programName: "", questionnaire: undefined, change: undefined };
}

export const UpsertQuestionnaireRequest: MessageFns<UpsertQuestionnaireRequest> = {
  encode(message: UpsertQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.questionnaire !== undefined) {
      Questionnaire.encode(message.questionnaire, writer.uint32(18).fork()).join();
    }
    if (message.change !== undefined) {
      Struct.encode(Struct.wrap(message.change), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionnaire = Questionnaire.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.change = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertQuestionnaireRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      questionnaire: isSet(object.questionnaire) ? Questionnaire.fromJSON(object.questionnaire) : undefined,
      change: isObject(object.change) ? object.change : undefined,
    };
  },

  toJSON(message: UpsertQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.questionnaire !== undefined) {
      obj.questionnaire = Questionnaire.toJSON(message.questionnaire);
    }
    if (message.change !== undefined) {
      obj.change = message.change;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertQuestionnaireRequest>, I>>(base?: I): UpsertQuestionnaireRequest {
    return UpsertQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertQuestionnaireRequest>, I>>(object: I): UpsertQuestionnaireRequest {
    const message = createBaseUpsertQuestionnaireRequest();
    message.programName = object.programName ?? "";
    message.questionnaire = (object.questionnaire !== undefined && object.questionnaire !== null)
      ? Questionnaire.fromPartial(object.questionnaire)
      : undefined;
    message.change = object.change ?? undefined;
    return message;
  },
};

function createBaseUpsertQuestionnaireResponse(): UpsertQuestionnaireResponse {
  return {};
}

export const UpsertQuestionnaireResponse: MessageFns<UpsertQuestionnaireResponse> = {
  encode(_: UpsertQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertQuestionnaireResponse {
    return {};
  },

  toJSON(_: UpsertQuestionnaireResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertQuestionnaireResponse>, I>>(base?: I): UpsertQuestionnaireResponse {
    return UpsertQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertQuestionnaireResponse>, I>>(_: I): UpsertQuestionnaireResponse {
    const message = createBaseUpsertQuestionnaireResponse();
    return message;
  },
};

function createBaseDeleteQuestionnaireRequest(): DeleteQuestionnaireRequest {
  return { programName: "", name: "" };
}

export const DeleteQuestionnaireRequest: MessageFns<DeleteQuestionnaireRequest> = {
  encode(message: DeleteQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteQuestionnaireRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteQuestionnaireRequest>, I>>(base?: I): DeleteQuestionnaireRequest {
    return DeleteQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteQuestionnaireRequest>, I>>(object: I): DeleteQuestionnaireRequest {
    const message = createBaseDeleteQuestionnaireRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteQuestionnaireResponse(): DeleteQuestionnaireResponse {
  return {};
}

export const DeleteQuestionnaireResponse: MessageFns<DeleteQuestionnaireResponse> = {
  encode(_: DeleteQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteQuestionnaireResponse {
    return {};
  },

  toJSON(_: DeleteQuestionnaireResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteQuestionnaireResponse>, I>>(base?: I): DeleteQuestionnaireResponse {
    return DeleteQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteQuestionnaireResponse>, I>>(_: I): DeleteQuestionnaireResponse {
    const message = createBaseDeleteQuestionnaireResponse();
    return message;
  },
};

function createBasePublishQuestionnaireRequest(): PublishQuestionnaireRequest {
  return { programName: "", name: "" };
}

export const PublishQuestionnaireRequest: MessageFns<PublishQuestionnaireRequest> = {
  encode(message: PublishQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishQuestionnaireRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PublishQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishQuestionnaireRequest>, I>>(base?: I): PublishQuestionnaireRequest {
    return PublishQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishQuestionnaireRequest>, I>>(object: I): PublishQuestionnaireRequest {
    const message = createBasePublishQuestionnaireRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePublishQuestionnaireResponse(): PublishQuestionnaireResponse {
  return {};
}

export const PublishQuestionnaireResponse: MessageFns<PublishQuestionnaireResponse> = {
  encode(_: PublishQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishQuestionnaireResponse {
    return {};
  },

  toJSON(_: PublishQuestionnaireResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishQuestionnaireResponse>, I>>(base?: I): PublishQuestionnaireResponse {
    return PublishQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishQuestionnaireResponse>, I>>(_: I): PublishQuestionnaireResponse {
    const message = createBasePublishQuestionnaireResponse();
    return message;
  },
};

function createBaseLoadQuestionnaireRequest(): LoadQuestionnaireRequest {
  return { programName: "", name: "" };
}

export const LoadQuestionnaireRequest: MessageFns<LoadQuestionnaireRequest> = {
  encode(message: LoadQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadQuestionnaireRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: LoadQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadQuestionnaireRequest>, I>>(base?: I): LoadQuestionnaireRequest {
    return LoadQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadQuestionnaireRequest>, I>>(object: I): LoadQuestionnaireRequest {
    const message = createBaseLoadQuestionnaireRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLoadQuestionnaireResponse(): LoadQuestionnaireResponse {
  return {};
}

export const LoadQuestionnaireResponse: MessageFns<LoadQuestionnaireResponse> = {
  encode(_: LoadQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LoadQuestionnaireResponse {
    return {};
  },

  toJSON(_: LoadQuestionnaireResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadQuestionnaireResponse>, I>>(base?: I): LoadQuestionnaireResponse {
    return LoadQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadQuestionnaireResponse>, I>>(_: I): LoadQuestionnaireResponse {
    const message = createBaseLoadQuestionnaireResponse();
    return message;
  },
};

function createBaseGetRoutinesRequest(): GetRoutinesRequest {
  return { programName: "" };
}

export const GetRoutinesRequest: MessageFns<GetRoutinesRequest> = {
  encode(message: GetRoutinesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutinesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutinesRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetRoutinesRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutinesRequest>, I>>(base?: I): GetRoutinesRequest {
    return GetRoutinesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutinesRequest>, I>>(object: I): GetRoutinesRequest {
    const message = createBaseGetRoutinesRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetRoutinesResponse(): GetRoutinesResponse {
  return { routines: [] };
}

export const GetRoutinesResponse: MessageFns<GetRoutinesResponse> = {
  encode(message: GetRoutinesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routines) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutinesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutinesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routines.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutinesResponse {
    return { routines: globalThis.Array.isArray(object?.routines) ? [...object.routines] : [] };
  },

  toJSON(message: GetRoutinesResponse): unknown {
    const obj: any = {};
    if (message.routines?.length) {
      obj.routines = message.routines;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutinesResponse>, I>>(base?: I): GetRoutinesResponse {
    return GetRoutinesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutinesResponse>, I>>(object: I): GetRoutinesResponse {
    const message = createBaseGetRoutinesResponse();
    message.routines = object.routines?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRoutineRequest(): GetRoutineRequest {
  return { programName: "", name: "" };
}

export const GetRoutineRequest: MessageFns<GetRoutineRequest> = {
  encode(message: GetRoutineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutineRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetRoutineRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutineRequest>, I>>(base?: I): GetRoutineRequest {
    return GetRoutineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutineRequest>, I>>(object: I): GetRoutineRequest {
    const message = createBaseGetRoutineRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetRoutineResponse(): GetRoutineResponse {
  return { routine: undefined, diffs: [] };
}

export const GetRoutineResponse: MessageFns<GetRoutineResponse> = {
  encode(message: GetRoutineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routine !== undefined) {
      Struct.encode(Struct.wrap(message.routine), writer.uint32(10).fork()).join();
    }
    for (const v of message.diffs) {
      Diff.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routine = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diffs.push(Diff.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutineResponse {
    return {
      routine: isObject(object.routine) ? object.routine : undefined,
      diffs: globalThis.Array.isArray(object?.diffs) ? object.diffs.map((e: any) => Diff.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetRoutineResponse): unknown {
    const obj: any = {};
    if (message.routine !== undefined) {
      obj.routine = message.routine;
    }
    if (message.diffs?.length) {
      obj.diffs = message.diffs.map((e) => Diff.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutineResponse>, I>>(base?: I): GetRoutineResponse {
    return GetRoutineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutineResponse>, I>>(object: I): GetRoutineResponse {
    const message = createBaseGetRoutineResponse();
    message.routine = object.routine ?? undefined;
    message.diffs = object.diffs?.map((e) => Diff.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpsertRoutineRequest(): UpsertRoutineRequest {
  return { programName: "", routine: undefined, change: undefined };
}

export const UpsertRoutineRequest: MessageFns<UpsertRoutineRequest> = {
  encode(message: UpsertRoutineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.routine !== undefined) {
      Struct.encode(Struct.wrap(message.routine), writer.uint32(18).fork()).join();
    }
    if (message.change !== undefined) {
      Struct.encode(Struct.wrap(message.change), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRoutineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRoutineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.routine = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.change = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertRoutineRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      routine: isObject(object.routine) ? object.routine : undefined,
      change: isObject(object.change) ? object.change : undefined,
    };
  },

  toJSON(message: UpsertRoutineRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.routine !== undefined) {
      obj.routine = message.routine;
    }
    if (message.change !== undefined) {
      obj.change = message.change;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertRoutineRequest>, I>>(base?: I): UpsertRoutineRequest {
    return UpsertRoutineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertRoutineRequest>, I>>(object: I): UpsertRoutineRequest {
    const message = createBaseUpsertRoutineRequest();
    message.programName = object.programName ?? "";
    message.routine = object.routine ?? undefined;
    message.change = object.change ?? undefined;
    return message;
  },
};

function createBaseUpsertRoutineResponse(): UpsertRoutineResponse {
  return {};
}

export const UpsertRoutineResponse: MessageFns<UpsertRoutineResponse> = {
  encode(_: UpsertRoutineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRoutineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRoutineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertRoutineResponse {
    return {};
  },

  toJSON(_: UpsertRoutineResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertRoutineResponse>, I>>(base?: I): UpsertRoutineResponse {
    return UpsertRoutineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertRoutineResponse>, I>>(_: I): UpsertRoutineResponse {
    const message = createBaseUpsertRoutineResponse();
    return message;
  },
};

function createBaseDeleteRoutineRequest(): DeleteRoutineRequest {
  return { programName: "", name: "" };
}

export const DeleteRoutineRequest: MessageFns<DeleteRoutineRequest> = {
  encode(message: DeleteRoutineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoutineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoutineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoutineRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteRoutineRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoutineRequest>, I>>(base?: I): DeleteRoutineRequest {
    return DeleteRoutineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoutineRequest>, I>>(object: I): DeleteRoutineRequest {
    const message = createBaseDeleteRoutineRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteRoutineResponse(): DeleteRoutineResponse {
  return {};
}

export const DeleteRoutineResponse: MessageFns<DeleteRoutineResponse> = {
  encode(_: DeleteRoutineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoutineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoutineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteRoutineResponse {
    return {};
  },

  toJSON(_: DeleteRoutineResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoutineResponse>, I>>(base?: I): DeleteRoutineResponse {
    return DeleteRoutineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoutineResponse>, I>>(_: I): DeleteRoutineResponse {
    const message = createBaseDeleteRoutineResponse();
    return message;
  },
};

function createBasePublishRoutineRequest(): PublishRoutineRequest {
  return { programName: "", name: "" };
}

export const PublishRoutineRequest: MessageFns<PublishRoutineRequest> = {
  encode(message: PublishRoutineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishRoutineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishRoutineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishRoutineRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PublishRoutineRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishRoutineRequest>, I>>(base?: I): PublishRoutineRequest {
    return PublishRoutineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishRoutineRequest>, I>>(object: I): PublishRoutineRequest {
    const message = createBasePublishRoutineRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePublishRoutineResponse(): PublishRoutineResponse {
  return {};
}

export const PublishRoutineResponse: MessageFns<PublishRoutineResponse> = {
  encode(_: PublishRoutineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishRoutineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishRoutineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishRoutineResponse {
    return {};
  },

  toJSON(_: PublishRoutineResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishRoutineResponse>, I>>(base?: I): PublishRoutineResponse {
    return PublishRoutineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishRoutineResponse>, I>>(_: I): PublishRoutineResponse {
    const message = createBasePublishRoutineResponse();
    return message;
  },
};

function createBaseLoadRoutineRequest(): LoadRoutineRequest {
  return { programName: "", name: "" };
}

export const LoadRoutineRequest: MessageFns<LoadRoutineRequest> = {
  encode(message: LoadRoutineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadRoutineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadRoutineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadRoutineRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: LoadRoutineRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadRoutineRequest>, I>>(base?: I): LoadRoutineRequest {
    return LoadRoutineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadRoutineRequest>, I>>(object: I): LoadRoutineRequest {
    const message = createBaseLoadRoutineRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLoadRoutineResponse(): LoadRoutineResponse {
  return {};
}

export const LoadRoutineResponse: MessageFns<LoadRoutineResponse> = {
  encode(_: LoadRoutineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadRoutineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadRoutineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LoadRoutineResponse {
    return {};
  },

  toJSON(_: LoadRoutineResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadRoutineResponse>, I>>(base?: I): LoadRoutineResponse {
    return LoadRoutineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadRoutineResponse>, I>>(_: I): LoadRoutineResponse {
    const message = createBaseLoadRoutineResponse();
    return message;
  },
};

function createBaseGetDisplaysRequest(): GetDisplaysRequest {
  return { programName: "" };
}

export const GetDisplaysRequest: MessageFns<GetDisplaysRequest> = {
  encode(message: GetDisplaysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplaysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplaysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplaysRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetDisplaysRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplaysRequest>, I>>(base?: I): GetDisplaysRequest {
    return GetDisplaysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplaysRequest>, I>>(object: I): GetDisplaysRequest {
    const message = createBaseGetDisplaysRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetDisplaysResponse(): GetDisplaysResponse {
  return { displays: [] };
}

export const GetDisplaysResponse: MessageFns<GetDisplaysResponse> = {
  encode(message: GetDisplaysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.displays) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplaysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplaysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displays.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplaysResponse {
    return { displays: globalThis.Array.isArray(object?.displays) ? [...object.displays] : [] };
  },

  toJSON(message: GetDisplaysResponse): unknown {
    const obj: any = {};
    if (message.displays?.length) {
      obj.displays = message.displays;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplaysResponse>, I>>(base?: I): GetDisplaysResponse {
    return GetDisplaysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplaysResponse>, I>>(object: I): GetDisplaysResponse {
    const message = createBaseGetDisplaysResponse();
    message.displays = object.displays?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDisplayRequest(): GetDisplayRequest {
  return { programName: "", name: "" };
}

export const GetDisplayRequest: MessageFns<GetDisplayRequest> = {
  encode(message: GetDisplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplayRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetDisplayRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplayRequest>, I>>(base?: I): GetDisplayRequest {
    return GetDisplayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplayRequest>, I>>(object: I): GetDisplayRequest {
    const message = createBaseGetDisplayRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetDisplayResponse(): GetDisplayResponse {
  return { display: undefined, diffs: [] };
}

export const GetDisplayResponse: MessageFns<GetDisplayResponse> = {
  encode(message: GetDisplayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.display !== undefined) {
      Struct.encode(Struct.wrap(message.display), writer.uint32(10).fork()).join();
    }
    for (const v of message.diffs) {
      Diff.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.display = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diffs.push(Diff.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplayResponse {
    return {
      display: isObject(object.display) ? object.display : undefined,
      diffs: globalThis.Array.isArray(object?.diffs) ? object.diffs.map((e: any) => Diff.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetDisplayResponse): unknown {
    const obj: any = {};
    if (message.display !== undefined) {
      obj.display = message.display;
    }
    if (message.diffs?.length) {
      obj.diffs = message.diffs.map((e) => Diff.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplayResponse>, I>>(base?: I): GetDisplayResponse {
    return GetDisplayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplayResponse>, I>>(object: I): GetDisplayResponse {
    const message = createBaseGetDisplayResponse();
    message.display = object.display ?? undefined;
    message.diffs = object.diffs?.map((e) => Diff.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpsertDisplayRequest(): UpsertDisplayRequest {
  return { programName: "", display: undefined, change: undefined };
}

export const UpsertDisplayRequest: MessageFns<UpsertDisplayRequest> = {
  encode(message: UpsertDisplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.display !== undefined) {
      Struct.encode(Struct.wrap(message.display), writer.uint32(18).fork()).join();
    }
    if (message.change !== undefined) {
      Struct.encode(Struct.wrap(message.change), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertDisplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertDisplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.display = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.change = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertDisplayRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      display: isObject(object.display) ? object.display : undefined,
      change: isObject(object.change) ? object.change : undefined,
    };
  },

  toJSON(message: UpsertDisplayRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.display !== undefined) {
      obj.display = message.display;
    }
    if (message.change !== undefined) {
      obj.change = message.change;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertDisplayRequest>, I>>(base?: I): UpsertDisplayRequest {
    return UpsertDisplayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertDisplayRequest>, I>>(object: I): UpsertDisplayRequest {
    const message = createBaseUpsertDisplayRequest();
    message.programName = object.programName ?? "";
    message.display = object.display ?? undefined;
    message.change = object.change ?? undefined;
    return message;
  },
};

function createBaseUpsertDisplayResponse(): UpsertDisplayResponse {
  return {};
}

export const UpsertDisplayResponse: MessageFns<UpsertDisplayResponse> = {
  encode(_: UpsertDisplayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertDisplayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertDisplayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertDisplayResponse {
    return {};
  },

  toJSON(_: UpsertDisplayResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertDisplayResponse>, I>>(base?: I): UpsertDisplayResponse {
    return UpsertDisplayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertDisplayResponse>, I>>(_: I): UpsertDisplayResponse {
    const message = createBaseUpsertDisplayResponse();
    return message;
  },
};

function createBaseDeleteDisplayRequest(): DeleteDisplayRequest {
  return { programName: "", name: "" };
}

export const DeleteDisplayRequest: MessageFns<DeleteDisplayRequest> = {
  encode(message: DeleteDisplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDisplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDisplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDisplayRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteDisplayRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDisplayRequest>, I>>(base?: I): DeleteDisplayRequest {
    return DeleteDisplayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDisplayRequest>, I>>(object: I): DeleteDisplayRequest {
    const message = createBaseDeleteDisplayRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteDisplayResponse(): DeleteDisplayResponse {
  return {};
}

export const DeleteDisplayResponse: MessageFns<DeleteDisplayResponse> = {
  encode(_: DeleteDisplayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDisplayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDisplayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteDisplayResponse {
    return {};
  },

  toJSON(_: DeleteDisplayResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDisplayResponse>, I>>(base?: I): DeleteDisplayResponse {
    return DeleteDisplayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDisplayResponse>, I>>(_: I): DeleteDisplayResponse {
    const message = createBaseDeleteDisplayResponse();
    return message;
  },
};

function createBasePublishDisplayRequest(): PublishDisplayRequest {
  return { programName: "", name: "" };
}

export const PublishDisplayRequest: MessageFns<PublishDisplayRequest> = {
  encode(message: PublishDisplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishDisplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishDisplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishDisplayRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PublishDisplayRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishDisplayRequest>, I>>(base?: I): PublishDisplayRequest {
    return PublishDisplayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishDisplayRequest>, I>>(object: I): PublishDisplayRequest {
    const message = createBasePublishDisplayRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePublishDisplayResponse(): PublishDisplayResponse {
  return {};
}

export const PublishDisplayResponse: MessageFns<PublishDisplayResponse> = {
  encode(_: PublishDisplayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishDisplayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishDisplayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishDisplayResponse {
    return {};
  },

  toJSON(_: PublishDisplayResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishDisplayResponse>, I>>(base?: I): PublishDisplayResponse {
    return PublishDisplayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishDisplayResponse>, I>>(_: I): PublishDisplayResponse {
    const message = createBasePublishDisplayResponse();
    return message;
  },
};

function createBaseLoadDisplayRequest(): LoadDisplayRequest {
  return { programName: "", name: "" };
}

export const LoadDisplayRequest: MessageFns<LoadDisplayRequest> = {
  encode(message: LoadDisplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadDisplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadDisplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadDisplayRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: LoadDisplayRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadDisplayRequest>, I>>(base?: I): LoadDisplayRequest {
    return LoadDisplayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadDisplayRequest>, I>>(object: I): LoadDisplayRequest {
    const message = createBaseLoadDisplayRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLoadDisplayResponse(): LoadDisplayResponse {
  return {};
}

export const LoadDisplayResponse: MessageFns<LoadDisplayResponse> = {
  encode(_: LoadDisplayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadDisplayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadDisplayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LoadDisplayResponse {
    return {};
  },

  toJSON(_: LoadDisplayResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadDisplayResponse>, I>>(base?: I): LoadDisplayResponse {
    return LoadDisplayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadDisplayResponse>, I>>(_: I): LoadDisplayResponse {
    const message = createBaseLoadDisplayResponse();
    return message;
  },
};

function createBaseGetCodesRequest(): GetCodesRequest {
  return { programName: "" };
}

export const GetCodesRequest: MessageFns<GetCodesRequest> = {
  encode(message: GetCodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCodesRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetCodesRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCodesRequest>, I>>(base?: I): GetCodesRequest {
    return GetCodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCodesRequest>, I>>(object: I): GetCodesRequest {
    const message = createBaseGetCodesRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetCodesResponse(): GetCodesResponse {
  return { codes: [] };
}

export const GetCodesResponse: MessageFns<GetCodesResponse> = {
  encode(message: GetCodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.codes) {
      ParticipantCode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.codes.push(ParticipantCode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCodesResponse {
    return {
      codes: globalThis.Array.isArray(object?.codes) ? object.codes.map((e: any) => ParticipantCode.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetCodesResponse): unknown {
    const obj: any = {};
    if (message.codes?.length) {
      obj.codes = message.codes.map((e) => ParticipantCode.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCodesResponse>, I>>(base?: I): GetCodesResponse {
    return GetCodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCodesResponse>, I>>(object: I): GetCodesResponse {
    const message = createBaseGetCodesResponse();
    message.codes = object.codes?.map((e) => ParticipantCode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCodesRequest(): GenerateCodesRequest {
  return { programName: "", amount: 0 };
}

export const GenerateCodesRequest: MessageFns<GenerateCodesRequest> = {
  encode(message: GenerateCodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int32(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCodesRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: GenerateCodesRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCodesRequest>, I>>(base?: I): GenerateCodesRequest {
    return GenerateCodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCodesRequest>, I>>(object: I): GenerateCodesRequest {
    const message = createBaseGenerateCodesRequest();
    message.programName = object.programName ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseGenerateCodesResponse(): GenerateCodesResponse {
  return {};
}

export const GenerateCodesResponse: MessageFns<GenerateCodesResponse> = {
  encode(_: GenerateCodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerateCodesResponse {
    return {};
  },

  toJSON(_: GenerateCodesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCodesResponse>, I>>(base?: I): GenerateCodesResponse {
    return GenerateCodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCodesResponse>, I>>(_: I): GenerateCodesResponse {
    const message = createBaseGenerateCodesResponse();
    return message;
  },
};

function createBaseAssignCodeRequest(): AssignCodeRequest {
  return { programName: "", code: "", alpID: "" };
}

export const AssignCodeRequest: MessageFns<AssignCodeRequest> = {
  encode(message: AssignCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.alpID !== "") {
      writer.uint32(26).string(message.alpID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.alpID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignCodeRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      alpID: isSet(object.alpID) ? globalThis.String(object.alpID) : "",
    };
  },

  toJSON(message: AssignCodeRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.alpID !== "") {
      obj.alpID = message.alpID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignCodeRequest>, I>>(base?: I): AssignCodeRequest {
    return AssignCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignCodeRequest>, I>>(object: I): AssignCodeRequest {
    const message = createBaseAssignCodeRequest();
    message.programName = object.programName ?? "";
    message.code = object.code ?? "";
    message.alpID = object.alpID ?? "";
    return message;
  },
};

function createBaseAssignCodeResponse(): AssignCodeResponse {
  return {};
}

export const AssignCodeResponse: MessageFns<AssignCodeResponse> = {
  encode(_: AssignCodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignCodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignCodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AssignCodeResponse {
    return {};
  },

  toJSON(_: AssignCodeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignCodeResponse>, I>>(base?: I): AssignCodeResponse {
    return AssignCodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignCodeResponse>, I>>(_: I): AssignCodeResponse {
    const message = createBaseAssignCodeResponse();
    return message;
  },
};

function createBaseDeleteCodeRequest(): DeleteCodeRequest {
  return { programName: "", code: "" };
}

export const DeleteCodeRequest: MessageFns<DeleteCodeRequest> = {
  encode(message: DeleteCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCodeRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: DeleteCodeRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCodeRequest>, I>>(base?: I): DeleteCodeRequest {
    return DeleteCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCodeRequest>, I>>(object: I): DeleteCodeRequest {
    const message = createBaseDeleteCodeRequest();
    message.programName = object.programName ?? "";
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseDeleteCodeResponse(): DeleteCodeResponse {
  return {};
}

export const DeleteCodeResponse: MessageFns<DeleteCodeResponse> = {
  encode(_: DeleteCodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteCodeResponse {
    return {};
  },

  toJSON(_: DeleteCodeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCodeResponse>, I>>(base?: I): DeleteCodeResponse {
    return DeleteCodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCodeResponse>, I>>(_: I): DeleteCodeResponse {
    const message = createBaseDeleteCodeResponse();
    return message;
  },
};

function createBaseUnassignCodeRequest(): UnassignCodeRequest {
  return { programName: "", code: "" };
}

export const UnassignCodeRequest: MessageFns<UnassignCodeRequest> = {
  encode(message: UnassignCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnassignCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnassignCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnassignCodeRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: UnassignCodeRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnassignCodeRequest>, I>>(base?: I): UnassignCodeRequest {
    return UnassignCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnassignCodeRequest>, I>>(object: I): UnassignCodeRequest {
    const message = createBaseUnassignCodeRequest();
    message.programName = object.programName ?? "";
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseUnassignCodeResponse(): UnassignCodeResponse {
  return {};
}

export const UnassignCodeResponse: MessageFns<UnassignCodeResponse> = {
  encode(_: UnassignCodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnassignCodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnassignCodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UnassignCodeResponse {
    return {};
  },

  toJSON(_: UnassignCodeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UnassignCodeResponse>, I>>(base?: I): UnassignCodeResponse {
    return UnassignCodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnassignCodeResponse>, I>>(_: I): UnassignCodeResponse {
    const message = createBaseUnassignCodeResponse();
    return message;
  },
};

function createBaseGetConsentsRequest(): GetConsentsRequest {
  return { programName: "" };
}

export const GetConsentsRequest: MessageFns<GetConsentsRequest> = {
  encode(message: GetConsentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentsRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetConsentsRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentsRequest>, I>>(base?: I): GetConsentsRequest {
    return GetConsentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentsRequest>, I>>(object: I): GetConsentsRequest {
    const message = createBaseGetConsentsRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetConsentsResponse(): GetConsentsResponse {
  return { consents: [] };
}

export const GetConsentsResponse: MessageFns<GetConsentsResponse> = {
  encode(message: GetConsentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.consents) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consents.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentsResponse {
    return { consents: globalThis.Array.isArray(object?.consents) ? [...object.consents] : [] };
  },

  toJSON(message: GetConsentsResponse): unknown {
    const obj: any = {};
    if (message.consents?.length) {
      obj.consents = message.consents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentsResponse>, I>>(base?: I): GetConsentsResponse {
    return GetConsentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentsResponse>, I>>(object: I): GetConsentsResponse {
    const message = createBaseGetConsentsResponse();
    message.consents = object.consents?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetConsentRequest(): GetConsentRequest {
  return { programName: "", name: "" };
}

export const GetConsentRequest: MessageFns<GetConsentRequest> = {
  encode(message: GetConsentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetConsentRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentRequest>, I>>(base?: I): GetConsentRequest {
    return GetConsentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentRequest>, I>>(object: I): GetConsentRequest {
    const message = createBaseGetConsentRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetConsentResponse(): GetConsentResponse {
  return { consents: [] };
}

export const GetConsentResponse: MessageFns<GetConsentResponse> = {
  encode(message: GetConsentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.consents) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consents.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentResponse {
    return { consents: globalThis.Array.isArray(object?.consents) ? [...object.consents] : [] };
  },

  toJSON(message: GetConsentResponse): unknown {
    const obj: any = {};
    if (message.consents?.length) {
      obj.consents = message.consents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentResponse>, I>>(base?: I): GetConsentResponse {
    return GetConsentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentResponse>, I>>(object: I): GetConsentResponse {
    const message = createBaseGetConsentResponse();
    message.consents = object.consents?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpsertConsentRequest(): UpsertConsentRequest {
  return { programName: "", consent: undefined };
}

export const UpsertConsentRequest: MessageFns<UpsertConsentRequest> = {
  encode(message: UpsertConsentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.consent !== undefined) {
      Struct.encode(Struct.wrap(message.consent), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertConsentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertConsentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consent = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertConsentRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      consent: isObject(object.consent) ? object.consent : undefined,
    };
  },

  toJSON(message: UpsertConsentRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.consent !== undefined) {
      obj.consent = message.consent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertConsentRequest>, I>>(base?: I): UpsertConsentRequest {
    return UpsertConsentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertConsentRequest>, I>>(object: I): UpsertConsentRequest {
    const message = createBaseUpsertConsentRequest();
    message.programName = object.programName ?? "";
    message.consent = object.consent ?? undefined;
    return message;
  },
};

function createBaseUpsertConsentResponse(): UpsertConsentResponse {
  return {};
}

export const UpsertConsentResponse: MessageFns<UpsertConsentResponse> = {
  encode(_: UpsertConsentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertConsentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertConsentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertConsentResponse {
    return {};
  },

  toJSON(_: UpsertConsentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertConsentResponse>, I>>(base?: I): UpsertConsentResponse {
    return UpsertConsentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertConsentResponse>, I>>(_: I): UpsertConsentResponse {
    const message = createBaseUpsertConsentResponse();
    return message;
  },
};

function createBaseDeleteConsentRequest(): DeleteConsentRequest {
  return { programName: "", name: "" };
}

export const DeleteConsentRequest: MessageFns<DeleteConsentRequest> = {
  encode(message: DeleteConsentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConsentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConsentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConsentRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteConsentRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConsentRequest>, I>>(base?: I): DeleteConsentRequest {
    return DeleteConsentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConsentRequest>, I>>(object: I): DeleteConsentRequest {
    const message = createBaseDeleteConsentRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteConsentResponse(): DeleteConsentResponse {
  return {};
}

export const DeleteConsentResponse: MessageFns<DeleteConsentResponse> = {
  encode(_: DeleteConsentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConsentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConsentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteConsentResponse {
    return {};
  },

  toJSON(_: DeleteConsentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConsentResponse>, I>>(base?: I): DeleteConsentResponse {
    return DeleteConsentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConsentResponse>, I>>(_: I): DeleteConsentResponse {
    const message = createBaseDeleteConsentResponse();
    return message;
  },
};

function createBaseDeleteConsentVersionRequest(): DeleteConsentVersionRequest {
  return { programName: "", name: "", version: 0 };
}

export const DeleteConsentVersionRequest: MessageFns<DeleteConsentVersionRequest> = {
  encode(message: DeleteConsentVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConsentVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConsentVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConsentVersionRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: DeleteConsentVersionRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConsentVersionRequest>, I>>(base?: I): DeleteConsentVersionRequest {
    return DeleteConsentVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConsentVersionRequest>, I>>(object: I): DeleteConsentVersionRequest {
    const message = createBaseDeleteConsentVersionRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseDeleteConsentVersionResponse(): DeleteConsentVersionResponse {
  return {};
}

export const DeleteConsentVersionResponse: MessageFns<DeleteConsentVersionResponse> = {
  encode(_: DeleteConsentVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConsentVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConsentVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteConsentVersionResponse {
    return {};
  },

  toJSON(_: DeleteConsentVersionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConsentVersionResponse>, I>>(base?: I): DeleteConsentVersionResponse {
    return DeleteConsentVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConsentVersionResponse>, I>>(_: I): DeleteConsentVersionResponse {
    const message = createBaseDeleteConsentVersionResponse();
    return message;
  },
};

function createBasePublishConsentRequest(): PublishConsentRequest {
  return { programName: "", name: "" };
}

export const PublishConsentRequest: MessageFns<PublishConsentRequest> = {
  encode(message: PublishConsentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishConsentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishConsentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishConsentRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PublishConsentRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishConsentRequest>, I>>(base?: I): PublishConsentRequest {
    return PublishConsentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishConsentRequest>, I>>(object: I): PublishConsentRequest {
    const message = createBasePublishConsentRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePublishConsentResponse(): PublishConsentResponse {
  return {};
}

export const PublishConsentResponse: MessageFns<PublishConsentResponse> = {
  encode(_: PublishConsentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishConsentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishConsentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishConsentResponse {
    return {};
  },

  toJSON(_: PublishConsentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishConsentResponse>, I>>(base?: I): PublishConsentResponse {
    return PublishConsentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishConsentResponse>, I>>(_: I): PublishConsentResponse {
    const message = createBasePublishConsentResponse();
    return message;
  },
};

function createBaseGetStandaloneSurveysRequest(): GetStandaloneSurveysRequest {
  return {};
}

export const GetStandaloneSurveysRequest: MessageFns<GetStandaloneSurveysRequest> = {
  encode(_: GetStandaloneSurveysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneSurveysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneSurveysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStandaloneSurveysRequest {
    return {};
  },

  toJSON(_: GetStandaloneSurveysRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneSurveysRequest>, I>>(base?: I): GetStandaloneSurveysRequest {
    return GetStandaloneSurveysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneSurveysRequest>, I>>(_: I): GetStandaloneSurveysRequest {
    const message = createBaseGetStandaloneSurveysRequest();
    return message;
  },
};

function createBaseGetStandaloneSurveysResponse(): GetStandaloneSurveysResponse {
  return { surveys: [] };
}

export const GetStandaloneSurveysResponse: MessageFns<GetStandaloneSurveysResponse> = {
  encode(message: GetStandaloneSurveysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.surveys) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneSurveysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneSurveysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.surveys.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStandaloneSurveysResponse {
    return { surveys: globalThis.Array.isArray(object?.surveys) ? [...object.surveys] : [] };
  },

  toJSON(message: GetStandaloneSurveysResponse): unknown {
    const obj: any = {};
    if (message.surveys?.length) {
      obj.surveys = message.surveys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneSurveysResponse>, I>>(base?: I): GetStandaloneSurveysResponse {
    return GetStandaloneSurveysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneSurveysResponse>, I>>(object: I): GetStandaloneSurveysResponse {
    const message = createBaseGetStandaloneSurveysResponse();
    message.surveys = object.surveys?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetStandaloneSurveyRequest(): GetStandaloneSurveyRequest {
  return { name: "" };
}

export const GetStandaloneSurveyRequest: MessageFns<GetStandaloneSurveyRequest> = {
  encode(message: GetStandaloneSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStandaloneSurveyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetStandaloneSurveyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneSurveyRequest>, I>>(base?: I): GetStandaloneSurveyRequest {
    return GetStandaloneSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneSurveyRequest>, I>>(object: I): GetStandaloneSurveyRequest {
    const message = createBaseGetStandaloneSurveyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetStandaloneSurveyResponse(): GetStandaloneSurveyResponse {
  return { survey: undefined };
}

export const GetStandaloneSurveyResponse: MessageFns<GetStandaloneSurveyResponse> = {
  encode(message: GetStandaloneSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.survey !== undefined) {
      Struct.encode(Struct.wrap(message.survey), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.survey = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStandaloneSurveyResponse {
    return { survey: isObject(object.survey) ? object.survey : undefined };
  },

  toJSON(message: GetStandaloneSurveyResponse): unknown {
    const obj: any = {};
    if (message.survey !== undefined) {
      obj.survey = message.survey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneSurveyResponse>, I>>(base?: I): GetStandaloneSurveyResponse {
    return GetStandaloneSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneSurveyResponse>, I>>(object: I): GetStandaloneSurveyResponse {
    const message = createBaseGetStandaloneSurveyResponse();
    message.survey = object.survey ?? undefined;
    return message;
  },
};

function createBaseUpsertStandaloneSurveyRequest(): UpsertStandaloneSurveyRequest {
  return { survey: undefined };
}

export const UpsertStandaloneSurveyRequest: MessageFns<UpsertStandaloneSurveyRequest> = {
  encode(message: UpsertStandaloneSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.survey !== undefined) {
      Struct.encode(Struct.wrap(message.survey), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertStandaloneSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertStandaloneSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.survey = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertStandaloneSurveyRequest {
    return { survey: isObject(object.survey) ? object.survey : undefined };
  },

  toJSON(message: UpsertStandaloneSurveyRequest): unknown {
    const obj: any = {};
    if (message.survey !== undefined) {
      obj.survey = message.survey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertStandaloneSurveyRequest>, I>>(base?: I): UpsertStandaloneSurveyRequest {
    return UpsertStandaloneSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertStandaloneSurveyRequest>, I>>(
    object: I,
  ): UpsertStandaloneSurveyRequest {
    const message = createBaseUpsertStandaloneSurveyRequest();
    message.survey = object.survey ?? undefined;
    return message;
  },
};

function createBaseUpsertStandaloneSurveyResponse(): UpsertStandaloneSurveyResponse {
  return {};
}

export const UpsertStandaloneSurveyResponse: MessageFns<UpsertStandaloneSurveyResponse> = {
  encode(_: UpsertStandaloneSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertStandaloneSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertStandaloneSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertStandaloneSurveyResponse {
    return {};
  },

  toJSON(_: UpsertStandaloneSurveyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertStandaloneSurveyResponse>, I>>(base?: I): UpsertStandaloneSurveyResponse {
    return UpsertStandaloneSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertStandaloneSurveyResponse>, I>>(_: I): UpsertStandaloneSurveyResponse {
    const message = createBaseUpsertStandaloneSurveyResponse();
    return message;
  },
};

function createBaseDeleteStandaloneSurveyRequest(): DeleteStandaloneSurveyRequest {
  return { name: "" };
}

export const DeleteStandaloneSurveyRequest: MessageFns<DeleteStandaloneSurveyRequest> = {
  encode(message: DeleteStandaloneSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStandaloneSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStandaloneSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStandaloneSurveyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteStandaloneSurveyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStandaloneSurveyRequest>, I>>(base?: I): DeleteStandaloneSurveyRequest {
    return DeleteStandaloneSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStandaloneSurveyRequest>, I>>(
    object: I,
  ): DeleteStandaloneSurveyRequest {
    const message = createBaseDeleteStandaloneSurveyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteStandaloneSurveyResponse(): DeleteStandaloneSurveyResponse {
  return {};
}

export const DeleteStandaloneSurveyResponse: MessageFns<DeleteStandaloneSurveyResponse> = {
  encode(_: DeleteStandaloneSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStandaloneSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStandaloneSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteStandaloneSurveyResponse {
    return {};
  },

  toJSON(_: DeleteStandaloneSurveyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStandaloneSurveyResponse>, I>>(base?: I): DeleteStandaloneSurveyResponse {
    return DeleteStandaloneSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStandaloneSurveyResponse>, I>>(_: I): DeleteStandaloneSurveyResponse {
    const message = createBaseDeleteStandaloneSurveyResponse();
    return message;
  },
};

function createBaseGetStandaloneQuestionnairesRequest(): GetStandaloneQuestionnairesRequest {
  return { language: "" };
}

export const GetStandaloneQuestionnairesRequest: MessageFns<GetStandaloneQuestionnairesRequest> = {
  encode(message: GetStandaloneQuestionnairesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneQuestionnairesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneQuestionnairesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStandaloneQuestionnairesRequest {
    return { language: isSet(object.language) ? globalThis.String(object.language) : "" };
  },

  toJSON(message: GetStandaloneQuestionnairesRequest): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneQuestionnairesRequest>, I>>(
    base?: I,
  ): GetStandaloneQuestionnairesRequest {
    return GetStandaloneQuestionnairesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneQuestionnairesRequest>, I>>(
    object: I,
  ): GetStandaloneQuestionnairesRequest {
    const message = createBaseGetStandaloneQuestionnairesRequest();
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseGetStandaloneQuestionnairesResponse(): GetStandaloneQuestionnairesResponse {
  return { questionnaires: [] };
}

export const GetStandaloneQuestionnairesResponse: MessageFns<GetStandaloneQuestionnairesResponse> = {
  encode(message: GetStandaloneQuestionnairesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.questionnaires) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneQuestionnairesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneQuestionnairesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionnaires.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStandaloneQuestionnairesResponse {
    return { questionnaires: globalThis.Array.isArray(object?.questionnaires) ? [...object.questionnaires] : [] };
  },

  toJSON(message: GetStandaloneQuestionnairesResponse): unknown {
    const obj: any = {};
    if (message.questionnaires?.length) {
      obj.questionnaires = message.questionnaires;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneQuestionnairesResponse>, I>>(
    base?: I,
  ): GetStandaloneQuestionnairesResponse {
    return GetStandaloneQuestionnairesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneQuestionnairesResponse>, I>>(
    object: I,
  ): GetStandaloneQuestionnairesResponse {
    const message = createBaseGetStandaloneQuestionnairesResponse();
    message.questionnaires = object.questionnaires?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetStandaloneQuestionnaireRequest(): GetStandaloneQuestionnaireRequest {
  return { name: "", language: "" };
}

export const GetStandaloneQuestionnaireRequest: MessageFns<GetStandaloneQuestionnaireRequest> = {
  encode(message: GetStandaloneQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStandaloneQuestionnaireRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: GetStandaloneQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneQuestionnaireRequest>, I>>(
    base?: I,
  ): GetStandaloneQuestionnaireRequest {
    return GetStandaloneQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneQuestionnaireRequest>, I>>(
    object: I,
  ): GetStandaloneQuestionnaireRequest {
    const message = createBaseGetStandaloneQuestionnaireRequest();
    message.name = object.name ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseGetStandaloneQuestionnaireResponse(): GetStandaloneQuestionnaireResponse {
  return { questionnaire: undefined };
}

export const GetStandaloneQuestionnaireResponse: MessageFns<GetStandaloneQuestionnaireResponse> = {
  encode(message: GetStandaloneQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionnaire !== undefined) {
      Struct.encode(Struct.wrap(message.questionnaire), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStandaloneQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStandaloneQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionnaire = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStandaloneQuestionnaireResponse {
    return { questionnaire: isObject(object.questionnaire) ? object.questionnaire : undefined };
  },

  toJSON(message: GetStandaloneQuestionnaireResponse): unknown {
    const obj: any = {};
    if (message.questionnaire !== undefined) {
      obj.questionnaire = message.questionnaire;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStandaloneQuestionnaireResponse>, I>>(
    base?: I,
  ): GetStandaloneQuestionnaireResponse {
    return GetStandaloneQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStandaloneQuestionnaireResponse>, I>>(
    object: I,
  ): GetStandaloneQuestionnaireResponse {
    const message = createBaseGetStandaloneQuestionnaireResponse();
    message.questionnaire = object.questionnaire ?? undefined;
    return message;
  },
};

function createBaseUpsertStandaloneQuestionnaireRequest(): UpsertStandaloneQuestionnaireRequest {
  return { questionnaire: undefined };
}

export const UpsertStandaloneQuestionnaireRequest: MessageFns<UpsertStandaloneQuestionnaireRequest> = {
  encode(message: UpsertStandaloneQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionnaire !== undefined) {
      Struct.encode(Struct.wrap(message.questionnaire), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertStandaloneQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertStandaloneQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionnaire = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertStandaloneQuestionnaireRequest {
    return { questionnaire: isObject(object.questionnaire) ? object.questionnaire : undefined };
  },

  toJSON(message: UpsertStandaloneQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.questionnaire !== undefined) {
      obj.questionnaire = message.questionnaire;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertStandaloneQuestionnaireRequest>, I>>(
    base?: I,
  ): UpsertStandaloneQuestionnaireRequest {
    return UpsertStandaloneQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertStandaloneQuestionnaireRequest>, I>>(
    object: I,
  ): UpsertStandaloneQuestionnaireRequest {
    const message = createBaseUpsertStandaloneQuestionnaireRequest();
    message.questionnaire = object.questionnaire ?? undefined;
    return message;
  },
};

function createBaseUpsertStandaloneQuestionnaireResponse(): UpsertStandaloneQuestionnaireResponse {
  return {};
}

export const UpsertStandaloneQuestionnaireResponse: MessageFns<UpsertStandaloneQuestionnaireResponse> = {
  encode(_: UpsertStandaloneQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertStandaloneQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertStandaloneQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertStandaloneQuestionnaireResponse {
    return {};
  },

  toJSON(_: UpsertStandaloneQuestionnaireResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertStandaloneQuestionnaireResponse>, I>>(
    base?: I,
  ): UpsertStandaloneQuestionnaireResponse {
    return UpsertStandaloneQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertStandaloneQuestionnaireResponse>, I>>(
    _: I,
  ): UpsertStandaloneQuestionnaireResponse {
    const message = createBaseUpsertStandaloneQuestionnaireResponse();
    return message;
  },
};

function createBaseDeleteStandaloneQuestionnaireRequest(): DeleteStandaloneQuestionnaireRequest {
  return { name: "", language: undefined };
}

export const DeleteStandaloneQuestionnaireRequest: MessageFns<DeleteStandaloneQuestionnaireRequest> = {
  encode(message: DeleteStandaloneQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.language !== undefined) {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStandaloneQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStandaloneQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStandaloneQuestionnaireRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
    };
  },

  toJSON(message: DeleteStandaloneQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStandaloneQuestionnaireRequest>, I>>(
    base?: I,
  ): DeleteStandaloneQuestionnaireRequest {
    return DeleteStandaloneQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStandaloneQuestionnaireRequest>, I>>(
    object: I,
  ): DeleteStandaloneQuestionnaireRequest {
    const message = createBaseDeleteStandaloneQuestionnaireRequest();
    message.name = object.name ?? "";
    message.language = object.language ?? undefined;
    return message;
  },
};

function createBaseDeleteStandaloneQuestionnaireResponse(): DeleteStandaloneQuestionnaireResponse {
  return {};
}

export const DeleteStandaloneQuestionnaireResponse: MessageFns<DeleteStandaloneQuestionnaireResponse> = {
  encode(_: DeleteStandaloneQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStandaloneQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStandaloneQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteStandaloneQuestionnaireResponse {
    return {};
  },

  toJSON(_: DeleteStandaloneQuestionnaireResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStandaloneQuestionnaireResponse>, I>>(
    base?: I,
  ): DeleteStandaloneQuestionnaireResponse {
    return DeleteStandaloneQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStandaloneQuestionnaireResponse>, I>>(
    _: I,
  ): DeleteStandaloneQuestionnaireResponse {
    const message = createBaseDeleteStandaloneQuestionnaireResponse();
    return message;
  },
};

function createBaseGetSubjectsRequest(): GetSubjectsRequest {
  return { programName: "" };
}

export const GetSubjectsRequest: MessageFns<GetSubjectsRequest> = {
  encode(message: GetSubjectsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubjectsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubjectsRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetSubjectsRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubjectsRequest>, I>>(base?: I): GetSubjectsRequest {
    return GetSubjectsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubjectsRequest>, I>>(object: I): GetSubjectsRequest {
    const message = createBaseGetSubjectsRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetSubjectsResponse(): GetSubjectsResponse {
  return { subjects: [] };
}

export const GetSubjectsResponse: MessageFns<GetSubjectsResponse> = {
  encode(message: GetSubjectsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subjects) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubjectsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjects.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubjectsResponse {
    return { subjects: globalThis.Array.isArray(object?.subjects) ? [...object.subjects] : [] };
  },

  toJSON(message: GetSubjectsResponse): unknown {
    const obj: any = {};
    if (message.subjects?.length) {
      obj.subjects = message.subjects;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubjectsResponse>, I>>(base?: I): GetSubjectsResponse {
    return GetSubjectsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubjectsResponse>, I>>(object: I): GetSubjectsResponse {
    const message = createBaseGetSubjectsResponse();
    message.subjects = object.subjects?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSubjectDataRequest(): GetSubjectDataRequest {
  return { programName: "", subjectID: "" };
}

export const GetSubjectDataRequest: MessageFns<GetSubjectDataRequest> = {
  encode(message: GetSubjectDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.subjectID !== "") {
      writer.uint32(18).string(message.subjectID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubjectDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubjectDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubjectDataRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      subjectID: isSet(object.subjectID) ? globalThis.String(object.subjectID) : "",
    };
  },

  toJSON(message: GetSubjectDataRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.subjectID !== "") {
      obj.subjectID = message.subjectID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubjectDataRequest>, I>>(base?: I): GetSubjectDataRequest {
    return GetSubjectDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubjectDataRequest>, I>>(object: I): GetSubjectDataRequest {
    const message = createBaseGetSubjectDataRequest();
    message.programName = object.programName ?? "";
    message.subjectID = object.subjectID ?? "";
    return message;
  },
};

function createBaseGetSubjectDataResponse(): GetSubjectDataResponse {
  return { uploads: [] };
}

export const GetSubjectDataResponse: MessageFns<GetSubjectDataResponse> = {
  encode(message: GetSubjectDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.uploads) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubjectDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubjectDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uploads.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubjectDataResponse {
    return { uploads: globalThis.Array.isArray(object?.uploads) ? [...object.uploads] : [] };
  },

  toJSON(message: GetSubjectDataResponse): unknown {
    const obj: any = {};
    if (message.uploads?.length) {
      obj.uploads = message.uploads;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubjectDataResponse>, I>>(base?: I): GetSubjectDataResponse {
    return GetSubjectDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubjectDataResponse>, I>>(object: I): GetSubjectDataResponse {
    const message = createBaseGetSubjectDataResponse();
    message.uploads = object.uploads?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSubjectResourceRequest(): GetSubjectResourceRequest {
  return { programName: "", subjectID: "", resourceID: "" };
}

export const GetSubjectResourceRequest: MessageFns<GetSubjectResourceRequest> = {
  encode(message: GetSubjectResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.subjectID !== "") {
      writer.uint32(18).string(message.subjectID);
    }
    if (message.resourceID !== "") {
      writer.uint32(26).string(message.resourceID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubjectResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubjectResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resourceID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubjectResourceRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      subjectID: isSet(object.subjectID) ? globalThis.String(object.subjectID) : "",
      resourceID: isSet(object.resourceID) ? globalThis.String(object.resourceID) : "",
    };
  },

  toJSON(message: GetSubjectResourceRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.subjectID !== "") {
      obj.subjectID = message.subjectID;
    }
    if (message.resourceID !== "") {
      obj.resourceID = message.resourceID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubjectResourceRequest>, I>>(base?: I): GetSubjectResourceRequest {
    return GetSubjectResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubjectResourceRequest>, I>>(object: I): GetSubjectResourceRequest {
    const message = createBaseGetSubjectResourceRequest();
    message.programName = object.programName ?? "";
    message.subjectID = object.subjectID ?? "";
    message.resourceID = object.resourceID ?? "";
    return message;
  },
};

function createBaseGetSubjectResourceResponse(): GetSubjectResourceResponse {
  return { resource: undefined };
}

export const GetSubjectResourceResponse: MessageFns<GetSubjectResourceResponse> = {
  encode(message: GetSubjectResourceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== undefined) {
      Struct.encode(Struct.wrap(message.resource), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubjectResourceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubjectResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubjectResourceResponse {
    return { resource: isObject(object.resource) ? object.resource : undefined };
  },

  toJSON(message: GetSubjectResourceResponse): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = message.resource;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubjectResourceResponse>, I>>(base?: I): GetSubjectResourceResponse {
    return GetSubjectResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubjectResourceResponse>, I>>(object: I): GetSubjectResourceResponse {
    const message = createBaseGetSubjectResourceResponse();
    message.resource = object.resource ?? undefined;
    return message;
  },
};

function createBaseGetDownloadListRequest(): GetDownloadListRequest {
  return { programName: "" };
}

export const GetDownloadListRequest: MessageFns<GetDownloadListRequest> = {
  encode(message: GetDownloadListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDownloadListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDownloadListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDownloadListRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetDownloadListRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDownloadListRequest>, I>>(base?: I): GetDownloadListRequest {
    return GetDownloadListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDownloadListRequest>, I>>(object: I): GetDownloadListRequest {
    const message = createBaseGetDownloadListRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetDownloadListResponse(): GetDownloadListResponse {
  return { subjects: [] };
}

export const GetDownloadListResponse: MessageFns<GetDownloadListResponse> = {
  encode(message: GetDownloadListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subjects) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDownloadListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDownloadListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjects.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDownloadListResponse {
    return { subjects: globalThis.Array.isArray(object?.subjects) ? [...object.subjects] : [] };
  },

  toJSON(message: GetDownloadListResponse): unknown {
    const obj: any = {};
    if (message.subjects?.length) {
      obj.subjects = message.subjects;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDownloadListResponse>, I>>(base?: I): GetDownloadListResponse {
    return GetDownloadListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDownloadListResponse>, I>>(object: I): GetDownloadListResponse {
    const message = createBaseGetDownloadListResponse();
    message.subjects = object.subjects?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDownloadTicketRequest(): GetDownloadTicketRequest {
  return { programName: "", subjectIDs: [], includeRawFHIR: false, includeETLCSV: false };
}

export const GetDownloadTicketRequest: MessageFns<GetDownloadTicketRequest> = {
  encode(message: GetDownloadTicketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    for (const v of message.subjectIDs) {
      writer.uint32(18).string(v!);
    }
    if (message.includeRawFHIR !== false) {
      writer.uint32(24).bool(message.includeRawFHIR);
    }
    if (message.includeETLCSV !== false) {
      writer.uint32(32).bool(message.includeETLCSV);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDownloadTicketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDownloadTicketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectIDs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeRawFHIR = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeETLCSV = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDownloadTicketRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      subjectIDs: globalThis.Array.isArray(object?.subjectIDs)
        ? object.subjectIDs.map((e: any) => globalThis.String(e))
        : [],
      includeRawFHIR: isSet(object.includeRawFHIR) ? globalThis.Boolean(object.includeRawFHIR) : false,
      includeETLCSV: isSet(object.includeETLCSV) ? globalThis.Boolean(object.includeETLCSV) : false,
    };
  },

  toJSON(message: GetDownloadTicketRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.subjectIDs?.length) {
      obj.subjectIDs = message.subjectIDs;
    }
    if (message.includeRawFHIR !== false) {
      obj.includeRawFHIR = message.includeRawFHIR;
    }
    if (message.includeETLCSV !== false) {
      obj.includeETLCSV = message.includeETLCSV;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDownloadTicketRequest>, I>>(base?: I): GetDownloadTicketRequest {
    return GetDownloadTicketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDownloadTicketRequest>, I>>(object: I): GetDownloadTicketRequest {
    const message = createBaseGetDownloadTicketRequest();
    message.programName = object.programName ?? "";
    message.subjectIDs = object.subjectIDs?.map((e) => e) || [];
    message.includeRawFHIR = object.includeRawFHIR ?? false;
    message.includeETLCSV = object.includeETLCSV ?? false;
    return message;
  },
};

function createBaseGetDownloadTicketResponse(): GetDownloadTicketResponse {
  return { url: "" };
}

export const GetDownloadTicketResponse: MessageFns<GetDownloadTicketResponse> = {
  encode(message: GetDownloadTicketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDownloadTicketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDownloadTicketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDownloadTicketResponse {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: GetDownloadTicketResponse): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDownloadTicketResponse>, I>>(base?: I): GetDownloadTicketResponse {
    return GetDownloadTicketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDownloadTicketResponse>, I>>(object: I): GetDownloadTicketResponse {
    const message = createBaseGetDownloadTicketResponse();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseGetStatisticsRequest(): GetStatisticsRequest {
  return { programName: "", type: "", startDate: undefined, endDate: undefined, params: undefined };
}

export const GetStatisticsRequest: MessageFns<GetStatisticsRequest> = {
  encode(message: GetStatisticsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.startDate !== undefined) {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== undefined) {
      writer.uint32(34).string(message.endDate);
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatisticsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatisticsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStatisticsRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : undefined,
      params: isObject(object.params) ? object.params : undefined,
    };
  },

  toJSON(message: GetStatisticsRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== undefined) {
      obj.endDate = message.endDate;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatisticsRequest>, I>>(base?: I): GetStatisticsRequest {
    return GetStatisticsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatisticsRequest>, I>>(object: I): GetStatisticsRequest {
    const message = createBaseGetStatisticsRequest();
    message.programName = object.programName ?? "";
    message.type = object.type ?? "";
    message.startDate = object.startDate ?? undefined;
    message.endDate = object.endDate ?? undefined;
    message.params = object.params ?? undefined;
    return message;
  },
};

function createBaseGetStatisticsResponse(): GetStatisticsResponse {
  return { data: undefined };
}

export const GetStatisticsResponse: MessageFns<GetStatisticsResponse> = {
  encode(message: GetStatisticsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatisticsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatisticsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStatisticsResponse {
    return { data: isObject(object.data) ? object.data : undefined };
  },

  toJSON(message: GetStatisticsResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatisticsResponse>, I>>(base?: I): GetStatisticsResponse {
    return GetStatisticsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatisticsResponse>, I>>(object: I): GetStatisticsResponse {
    const message = createBaseGetStatisticsResponse();
    message.data = object.data ?? undefined;
    return message;
  },
};

function createBaseGetImageRequest(): GetImageRequest {
  return { programName: "", name: "" };
}

export const GetImageRequest: MessageFns<GetImageRequest> = {
  encode(message: GetImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetImageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetImageRequest>, I>>(base?: I): GetImageRequest {
    return GetImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetImageRequest>, I>>(object: I): GetImageRequest {
    const message = createBaseGetImageRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpsertImageRequest(): UpsertImageRequest {
  return { programName: "", name: "", contentType: "", data: new Uint8Array(0) };
}

export const UpsertImageRequest: MessageFns<UpsertImageRequest> = {
  encode(message: UpsertImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertImageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: UpsertImageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertImageRequest>, I>>(base?: I): UpsertImageRequest {
    return UpsertImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertImageRequest>, I>>(object: I): UpsertImageRequest {
    const message = createBaseUpsertImageRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    message.contentType = object.contentType ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUpsertImageResponse(): UpsertImageResponse {
  return {};
}

export const UpsertImageResponse: MessageFns<UpsertImageResponse> = {
  encode(_: UpsertImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertImageResponse {
    return {};
  },

  toJSON(_: UpsertImageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertImageResponse>, I>>(base?: I): UpsertImageResponse {
    return UpsertImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertImageResponse>, I>>(_: I): UpsertImageResponse {
    const message = createBaseUpsertImageResponse();
    return message;
  },
};

function createBaseDeleteImageRequest(): DeleteImageRequest {
  return { programName: "", name: "" };
}

export const DeleteImageRequest: MessageFns<DeleteImageRequest> = {
  encode(message: DeleteImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteImageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteImageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteImageRequest>, I>>(base?: I): DeleteImageRequest {
    return DeleteImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteImageRequest>, I>>(object: I): DeleteImageRequest {
    const message = createBaseDeleteImageRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteImageResponse(): DeleteImageResponse {
  return {};
}

export const DeleteImageResponse: MessageFns<DeleteImageResponse> = {
  encode(_: DeleteImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteImageResponse {
    return {};
  },

  toJSON(_: DeleteImageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteImageResponse>, I>>(base?: I): DeleteImageResponse {
    return DeleteImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteImageResponse>, I>>(_: I): DeleteImageResponse {
    const message = createBaseDeleteImageResponse();
    return message;
  },
};

function createBaseGetClientsRequest(): GetClientsRequest {
  return { programName: "" };
}

export const GetClientsRequest: MessageFns<GetClientsRequest> = {
  encode(message: GetClientsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClientsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClientsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClientsRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetClientsRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClientsRequest>, I>>(base?: I): GetClientsRequest {
    return GetClientsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClientsRequest>, I>>(object: I): GetClientsRequest {
    const message = createBaseGetClientsRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetClientsResponse(): GetClientsResponse {
  return { clients: [] };
}

export const GetClientsResponse: MessageFns<GetClientsResponse> = {
  encode(message: GetClientsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clients) {
      Client.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClientsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClientsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clients.push(Client.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClientsResponse {
    return {
      clients: globalThis.Array.isArray(object?.clients) ? object.clients.map((e: any) => Client.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetClientsResponse): unknown {
    const obj: any = {};
    if (message.clients?.length) {
      obj.clients = message.clients.map((e) => Client.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClientsResponse>, I>>(base?: I): GetClientsResponse {
    return GetClientsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClientsResponse>, I>>(object: I): GetClientsResponse {
    const message = createBaseGetClientsResponse();
    message.clients = object.clients?.map((e) => Client.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetClientRequest(): GetClientRequest {
  return { programName: "", name: "" };
}

export const GetClientRequest: MessageFns<GetClientRequest> = {
  encode(message: GetClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClientRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetClientRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClientRequest>, I>>(base?: I): GetClientRequest {
    return GetClientRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClientRequest>, I>>(object: I): GetClientRequest {
    const message = createBaseGetClientRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetClientResponse(): GetClientResponse {
  return { client: undefined };
}

export const GetClientResponse: MessageFns<GetClientResponse> = {
  encode(message: GetClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client !== undefined) {
      Client.encode(message.client, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.client = Client.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClientResponse {
    return { client: isSet(object.client) ? Client.fromJSON(object.client) : undefined };
  },

  toJSON(message: GetClientResponse): unknown {
    const obj: any = {};
    if (message.client !== undefined) {
      obj.client = Client.toJSON(message.client);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClientResponse>, I>>(base?: I): GetClientResponse {
    return GetClientResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClientResponse>, I>>(object: I): GetClientResponse {
    const message = createBaseGetClientResponse();
    message.client = (object.client !== undefined && object.client !== null)
      ? Client.fromPartial(object.client)
      : undefined;
    return message;
  },
};

function createBaseUpsertClientRequest(): UpsertClientRequest {
  return { programName: "", name: "", clientID: "", clientSecret: "" };
}

export const UpsertClientRequest: MessageFns<UpsertClientRequest> = {
  encode(message: UpsertClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.clientID !== "") {
      writer.uint32(26).string(message.clientID);
    }
    if (message.clientSecret !== "") {
      writer.uint32(34).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientID = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertClientRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      clientID: isSet(object.clientID) ? globalThis.String(object.clientID) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
    };
  },

  toJSON(message: UpsertClientRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.clientID !== "") {
      obj.clientID = message.clientID;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertClientRequest>, I>>(base?: I): UpsertClientRequest {
    return UpsertClientRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertClientRequest>, I>>(object: I): UpsertClientRequest {
    const message = createBaseUpsertClientRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    message.clientID = object.clientID ?? "";
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

function createBaseUpsertClientResponse(): UpsertClientResponse {
  return {};
}

export const UpsertClientResponse: MessageFns<UpsertClientResponse> = {
  encode(_: UpsertClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertClientResponse {
    return {};
  },

  toJSON(_: UpsertClientResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertClientResponse>, I>>(base?: I): UpsertClientResponse {
    return UpsertClientResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertClientResponse>, I>>(_: I): UpsertClientResponse {
    const message = createBaseUpsertClientResponse();
    return message;
  },
};

function createBaseExchangeTokenRequest(): ExchangeTokenRequest {
  return { name: "", programName: "", clientID: "", clientSecret: "", params: undefined };
}

export const ExchangeTokenRequest: MessageFns<ExchangeTokenRequest> = {
  encode(message: ExchangeTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.programName !== "") {
      writer.uint32(18).string(message.programName);
    }
    if (message.clientID !== "") {
      writer.uint32(26).string(message.clientID);
    }
    if (message.clientSecret !== "") {
      writer.uint32(34).string(message.clientSecret);
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientID = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeTokenRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      clientID: isSet(object.clientID) ? globalThis.String(object.clientID) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
      params: isObject(object.params) ? object.params : undefined,
    };
  },

  toJSON(message: ExchangeTokenRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.clientID !== "") {
      obj.clientID = message.clientID;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeTokenRequest>, I>>(base?: I): ExchangeTokenRequest {
    return ExchangeTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeTokenRequest>, I>>(object: I): ExchangeTokenRequest {
    const message = createBaseExchangeTokenRequest();
    message.name = object.name ?? "";
    message.programName = object.programName ?? "";
    message.clientID = object.clientID ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.params = object.params ?? undefined;
    return message;
  },
};

function createBaseExchangeTokenResponse(): ExchangeTokenResponse {
  return { body: undefined };
}

export const ExchangeTokenResponse: MessageFns<ExchangeTokenResponse> = {
  encode(message: ExchangeTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined) {
      Struct.encode(Struct.wrap(message.body), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeTokenResponse {
    return { body: isObject(object.body) ? object.body : undefined };
  },

  toJSON(message: ExchangeTokenResponse): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeTokenResponse>, I>>(base?: I): ExchangeTokenResponse {
    return ExchangeTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeTokenResponse>, I>>(object: I): ExchangeTokenResponse {
    const message = createBaseExchangeTokenResponse();
    message.body = object.body ?? undefined;
    return message;
  },
};

function createBaseDeleteClientRequest(): DeleteClientRequest {
  return { programName: "", name: "" };
}

export const DeleteClientRequest: MessageFns<DeleteClientRequest> = {
  encode(message: DeleteClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClientRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteClientRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteClientRequest>, I>>(base?: I): DeleteClientRequest {
    return DeleteClientRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteClientRequest>, I>>(object: I): DeleteClientRequest {
    const message = createBaseDeleteClientRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteClientResponse(): DeleteClientResponse {
  return {};
}

export const DeleteClientResponse: MessageFns<DeleteClientResponse> = {
  encode(_: DeleteClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteClientResponse {
    return {};
  },

  toJSON(_: DeleteClientResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteClientResponse>, I>>(base?: I): DeleteClientResponse {
    return DeleteClientResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteClientResponse>, I>>(_: I): DeleteClientResponse {
    const message = createBaseDeleteClientResponse();
    return message;
  },
};

function createBaseGetMessagesRequest(): GetMessagesRequest {
  return { programName: "" };
}

export const GetMessagesRequest: MessageFns<GetMessagesRequest> = {
  encode(message: GetMessagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessagesRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetMessagesRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessagesRequest>, I>>(base?: I): GetMessagesRequest {
    return GetMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessagesRequest>, I>>(object: I): GetMessagesRequest {
    const message = createBaseGetMessagesRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetMessagesResponse(): GetMessagesResponse {
  return { messages: [] };
}

export const GetMessagesResponse: MessageFns<GetMessagesResponse> = {
  encode(message: GetMessagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessagesResponse {
    return { messages: globalThis.Array.isArray(object?.messages) ? [...object.messages] : [] };
  },

  toJSON(message: GetMessagesResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessagesResponse>, I>>(base?: I): GetMessagesResponse {
    return GetMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessagesResponse>, I>>(object: I): GetMessagesResponse {
    const message = createBaseGetMessagesResponse();
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMessageRequest(): GetMessageRequest {
  return { programName: "", name: "" };
}

export const GetMessageRequest: MessageFns<GetMessageRequest> = {
  encode(message: GetMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetMessageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessageRequest>, I>>(base?: I): GetMessageRequest {
    return GetMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessageRequest>, I>>(object: I): GetMessageRequest {
    const message = createBaseGetMessageRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetMessageResponse(): GetMessageResponse {
  return { message: undefined, recipients: [] };
}

export const GetMessageResponse: MessageFns<GetMessageResponse> = {
  encode(message: GetMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      Struct.encode(Struct.wrap(message.message), writer.uint32(10).fork()).join();
    }
    for (const v of message.recipients) {
      Struct.encode(Struct.wrap(v!), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipients.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessageResponse {
    return {
      message: isObject(object.message) ? object.message : undefined,
      recipients: globalThis.Array.isArray(object?.recipients) ? [...object.recipients] : [],
    };
  },

  toJSON(message: GetMessageResponse): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.recipients?.length) {
      obj.recipients = message.recipients;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessageResponse>, I>>(base?: I): GetMessageResponse {
    return GetMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessageResponse>, I>>(object: I): GetMessageResponse {
    const message = createBaseGetMessageResponse();
    message.message = object.message ?? undefined;
    message.recipients = object.recipients?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpsertMessageRequest(): UpsertMessageRequest {
  return { programName: "", message: undefined };
}

export const UpsertMessageRequest: MessageFns<UpsertMessageRequest> = {
  encode(message: UpsertMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.message !== undefined) {
      Struct.encode(Struct.wrap(message.message), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertMessageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      message: isObject(object.message) ? object.message : undefined,
    };
  },

  toJSON(message: UpsertMessageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertMessageRequest>, I>>(base?: I): UpsertMessageRequest {
    return UpsertMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertMessageRequest>, I>>(object: I): UpsertMessageRequest {
    const message = createBaseUpsertMessageRequest();
    message.programName = object.programName ?? "";
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseUpsertMessageResponse(): UpsertMessageResponse {
  return {};
}

export const UpsertMessageResponse: MessageFns<UpsertMessageResponse> = {
  encode(_: UpsertMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertMessageResponse {
    return {};
  },

  toJSON(_: UpsertMessageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertMessageResponse>, I>>(base?: I): UpsertMessageResponse {
    return UpsertMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertMessageResponse>, I>>(_: I): UpsertMessageResponse {
    const message = createBaseUpsertMessageResponse();
    return message;
  },
};

function createBaseDeleteMessageRequest(): DeleteMessageRequest {
  return { programName: "", name: "" };
}

export const DeleteMessageRequest: MessageFns<DeleteMessageRequest> = {
  encode(message: DeleteMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteMessageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageRequest>, I>>(base?: I): DeleteMessageRequest {
    return DeleteMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageRequest>, I>>(object: I): DeleteMessageRequest {
    const message = createBaseDeleteMessageRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteMessageResponse(): DeleteMessageResponse {
  return {};
}

export const DeleteMessageResponse: MessageFns<DeleteMessageResponse> = {
  encode(_: DeleteMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteMessageResponse {
    return {};
  },

  toJSON(_: DeleteMessageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageResponse>, I>>(base?: I): DeleteMessageResponse {
    return DeleteMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageResponse>, I>>(_: I): DeleteMessageResponse {
    const message = createBaseDeleteMessageResponse();
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { programName: "", name: "" };
}

export const SendMessageRequest: MessageFns<SendMessageRequest> = {
  encode(message: SendMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageRequest>, I>>(base?: I): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(object: I): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSendMessageResponse(): SendMessageResponse {
  return {};
}

export const SendMessageResponse: MessageFns<SendMessageResponse> = {
  encode(_: SendMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SendMessageResponse {
    return {};
  },

  toJSON(_: SendMessageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResponse>, I>>(base?: I): SendMessageResponse {
    return SendMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResponse>, I>>(_: I): SendMessageResponse {
    const message = createBaseSendMessageResponse();
    return message;
  },
};

function createBaseGetTokensRequest(): GetTokensRequest {
  return { programName: "" };
}

export const GetTokensRequest: MessageFns<GetTokensRequest> = {
  encode(message: GetTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetTokensRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensRequest>, I>>(base?: I): GetTokensRequest {
    return GetTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensRequest>, I>>(object: I): GetTokensRequest {
    const message = createBaseGetTokensRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetTokensResponse(): GetTokensResponse {
  return { tokens: [] };
}

export const GetTokensResponse: MessageFns<GetTokensResponse> = {
  encode(message: GetTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokens) {
      DeviceToken.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokens.push(DeviceToken.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensResponse {
    return {
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => DeviceToken.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetTokensResponse): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => DeviceToken.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensResponse>, I>>(base?: I): GetTokensResponse {
    return GetTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensResponse>, I>>(object: I): GetTokensResponse {
    const message = createBaseGetTokensResponse();
    message.tokens = object.tokens?.map((e) => DeviceToken.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpsertTokenRequest(): UpsertTokenRequest {
  return { programName: "", subjectID: "", token: "" };
}

export const UpsertTokenRequest: MessageFns<UpsertTokenRequest> = {
  encode(message: UpsertTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.subjectID !== "") {
      writer.uint32(18).string(message.subjectID);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertTokenRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      subjectID: isSet(object.subjectID) ? globalThis.String(object.subjectID) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: UpsertTokenRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.subjectID !== "") {
      obj.subjectID = message.subjectID;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertTokenRequest>, I>>(base?: I): UpsertTokenRequest {
    return UpsertTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertTokenRequest>, I>>(object: I): UpsertTokenRequest {
    const message = createBaseUpsertTokenRequest();
    message.programName = object.programName ?? "";
    message.subjectID = object.subjectID ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseUpsertTokenResponse(): UpsertTokenResponse {
  return {};
}

export const UpsertTokenResponse: MessageFns<UpsertTokenResponse> = {
  encode(_: UpsertTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertTokenResponse {
    return {};
  },

  toJSON(_: UpsertTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertTokenResponse>, I>>(base?: I): UpsertTokenResponse {
    return UpsertTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertTokenResponse>, I>>(_: I): UpsertTokenResponse {
    const message = createBaseUpsertTokenResponse();
    return message;
  },
};

function createBaseDeleteTokenRequest(): DeleteTokenRequest {
  return { programName: "", subjectID: "" };
}

export const DeleteTokenRequest: MessageFns<DeleteTokenRequest> = {
  encode(message: DeleteTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.subjectID !== "") {
      writer.uint32(18).string(message.subjectID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTokenRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      subjectID: isSet(object.subjectID) ? globalThis.String(object.subjectID) : "",
    };
  },

  toJSON(message: DeleteTokenRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.subjectID !== "") {
      obj.subjectID = message.subjectID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTokenRequest>, I>>(base?: I): DeleteTokenRequest {
    return DeleteTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTokenRequest>, I>>(object: I): DeleteTokenRequest {
    const message = createBaseDeleteTokenRequest();
    message.programName = object.programName ?? "";
    message.subjectID = object.subjectID ?? "";
    return message;
  },
};

function createBaseDeleteTokenResponse(): DeleteTokenResponse {
  return {};
}

export const DeleteTokenResponse: MessageFns<DeleteTokenResponse> = {
  encode(_: DeleteTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteTokenResponse {
    return {};
  },

  toJSON(_: DeleteTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTokenResponse>, I>>(base?: I): DeleteTokenResponse {
    return DeleteTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTokenResponse>, I>>(_: I): DeleteTokenResponse {
    const message = createBaseDeleteTokenResponse();
    return message;
  },
};

function createBaseChecksRequest(): ChecksRequest {
  return {};
}

export const ChecksRequest: MessageFns<ChecksRequest> = {
  encode(_: ChecksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChecksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChecksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ChecksRequest {
    return {};
  },

  toJSON(_: ChecksRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ChecksRequest>, I>>(base?: I): ChecksRequest {
    return ChecksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChecksRequest>, I>>(_: I): ChecksRequest {
    const message = createBaseChecksRequest();
    return message;
  },
};

function createBaseChecksResponse(): ChecksResponse {
  return { response: "" };
}

export const ChecksResponse: MessageFns<ChecksResponse> = {
  encode(message: ChecksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChecksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChecksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChecksResponse {
    return { response: isSet(object.response) ? globalThis.String(object.response) : "" };
  },

  toJSON(message: ChecksResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChecksResponse>, I>>(base?: I): ChecksResponse {
    return ChecksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChecksResponse>, I>>(object: I): ChecksResponse {
    const message = createBaseChecksResponse();
    message.response = object.response ?? "";
    return message;
  },
};

export interface Users {
  GetSelf(request: DeepPartial<GetSelfRequest>, metadata?: grpc.Metadata): Promise<GetSelfResponse>;
  GetUsers(request: DeepPartial<GetUsersRequest>, metadata?: grpc.Metadata): Promise<GetUsersResponse>;
  DeleteUser(request: DeepPartial<DeleteUserRequest>, metadata?: grpc.Metadata): Promise<DeleteUserResponse>;
  UpsertProgramRole(
    request: DeepPartial<UpsertProgramRoleRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertProgramRoleResponse>;
  DeleteProgramRole(
    request: DeepPartial<DeleteProgramRoleRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteProgramRoleResponse>;
  GetBlockedPrograms(
    request: DeepPartial<GetBlockedProgramsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetBlockedProgramsResponse>;
  BlockProgram(request: DeepPartial<BlockProgramRequest>, metadata?: grpc.Metadata): Promise<BlockProgramResponse>;
  UnblockProgram(
    request: DeepPartial<UnblockProgramRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UnblockProgramResponse>;
}

export class UsersClientImpl implements Users {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetSelf = this.GetSelf.bind(this);
    this.GetUsers = this.GetUsers.bind(this);
    this.DeleteUser = this.DeleteUser.bind(this);
    this.UpsertProgramRole = this.UpsertProgramRole.bind(this);
    this.DeleteProgramRole = this.DeleteProgramRole.bind(this);
    this.GetBlockedPrograms = this.GetBlockedPrograms.bind(this);
    this.BlockProgram = this.BlockProgram.bind(this);
    this.UnblockProgram = this.UnblockProgram.bind(this);
  }

  GetSelf(request: DeepPartial<GetSelfRequest>, metadata?: grpc.Metadata): Promise<GetSelfResponse> {
    return this.rpc.unary(UsersGetSelfDesc, GetSelfRequest.fromPartial(request), metadata);
  }

  GetUsers(request: DeepPartial<GetUsersRequest>, metadata?: grpc.Metadata): Promise<GetUsersResponse> {
    return this.rpc.unary(UsersGetUsersDesc, GetUsersRequest.fromPartial(request), metadata);
  }

  DeleteUser(request: DeepPartial<DeleteUserRequest>, metadata?: grpc.Metadata): Promise<DeleteUserResponse> {
    return this.rpc.unary(UsersDeleteUserDesc, DeleteUserRequest.fromPartial(request), metadata);
  }

  UpsertProgramRole(
    request: DeepPartial<UpsertProgramRoleRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertProgramRoleResponse> {
    return this.rpc.unary(UsersUpsertProgramRoleDesc, UpsertProgramRoleRequest.fromPartial(request), metadata);
  }

  DeleteProgramRole(
    request: DeepPartial<DeleteProgramRoleRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteProgramRoleResponse> {
    return this.rpc.unary(UsersDeleteProgramRoleDesc, DeleteProgramRoleRequest.fromPartial(request), metadata);
  }

  GetBlockedPrograms(
    request: DeepPartial<GetBlockedProgramsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetBlockedProgramsResponse> {
    return this.rpc.unary(UsersGetBlockedProgramsDesc, GetBlockedProgramsRequest.fromPartial(request), metadata);
  }

  BlockProgram(request: DeepPartial<BlockProgramRequest>, metadata?: grpc.Metadata): Promise<BlockProgramResponse> {
    return this.rpc.unary(UsersBlockProgramDesc, BlockProgramRequest.fromPartial(request), metadata);
  }

  UnblockProgram(
    request: DeepPartial<UnblockProgramRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UnblockProgramResponse> {
    return this.rpc.unary(UsersUnblockProgramDesc, UnblockProgramRequest.fromPartial(request), metadata);
  }
}

export const UsersDesc = { serviceName: "proto.api.Users" };

export const UsersGetSelfDesc: UnaryMethodDefinitionish = {
  methodName: "GetSelf",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSelfRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSelfResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UsersGetUsersDesc: UnaryMethodDefinitionish = {
  methodName: "GetUsers",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetUsersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetUsersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UsersDeleteUserDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteUser",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteUserRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteUserResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UsersUpsertProgramRoleDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertProgramRole",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertProgramRoleRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertProgramRoleResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UsersDeleteProgramRoleDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteProgramRole",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteProgramRoleRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteProgramRoleResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UsersGetBlockedProgramsDesc: UnaryMethodDefinitionish = {
  methodName: "GetBlockedPrograms",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetBlockedProgramsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetBlockedProgramsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UsersBlockProgramDesc: UnaryMethodDefinitionish = {
  methodName: "BlockProgram",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BlockProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = BlockProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UsersUnblockProgramDesc: UnaryMethodDefinitionish = {
  methodName: "UnblockProgram",
  service: UsersDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnblockProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UnblockProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Programs {
  GetPrograms(request: DeepPartial<GetProgramsRequest>, metadata?: grpc.Metadata): Promise<GetProgramsResponse>;
  GetProgramsList(
    request: DeepPartial<GetProgramsListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramsListResponse>;
  IsNameAvailable(
    request: DeepPartial<IsNameAvailableRequest>,
    metadata?: grpc.Metadata,
  ): Promise<IsNameAvailableResponse>;
  GetProgram(request: DeepPartial<GetProgramRequest>, metadata?: grpc.Metadata): Promise<GetProgramResponse>;
  GetProgramData(
    request: DeepPartial<GetProgramDataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramDataResponse>;
  GetProgramDiffs(
    request: DeepPartial<GetProgramDiffsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramDiffsResponse>;
  UpsertProgram(request: DeepPartial<UpsertProgramRequest>, metadata?: grpc.Metadata): Promise<UpsertProgramResponse>;
  DeleteProgram(request: DeepPartial<DeleteProgramRequest>, metadata?: grpc.Metadata): Promise<DeleteProgramResponse>;
  PublishProgram(
    request: DeepPartial<PublishProgramRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishProgramResponse>;
  LoadProgram(request: DeepPartial<LoadProgramRequest>, metadata?: grpc.Metadata): Promise<LoadProgramResponse>;
}

export class ProgramsClientImpl implements Programs {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetPrograms = this.GetPrograms.bind(this);
    this.GetProgramsList = this.GetProgramsList.bind(this);
    this.IsNameAvailable = this.IsNameAvailable.bind(this);
    this.GetProgram = this.GetProgram.bind(this);
    this.GetProgramData = this.GetProgramData.bind(this);
    this.GetProgramDiffs = this.GetProgramDiffs.bind(this);
    this.UpsertProgram = this.UpsertProgram.bind(this);
    this.DeleteProgram = this.DeleteProgram.bind(this);
    this.PublishProgram = this.PublishProgram.bind(this);
    this.LoadProgram = this.LoadProgram.bind(this);
  }

  GetPrograms(request: DeepPartial<GetProgramsRequest>, metadata?: grpc.Metadata): Promise<GetProgramsResponse> {
    return this.rpc.unary(ProgramsGetProgramsDesc, GetProgramsRequest.fromPartial(request), metadata);
  }

  GetProgramsList(
    request: DeepPartial<GetProgramsListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramsListResponse> {
    return this.rpc.unary(ProgramsGetProgramsListDesc, GetProgramsListRequest.fromPartial(request), metadata);
  }

  IsNameAvailable(
    request: DeepPartial<IsNameAvailableRequest>,
    metadata?: grpc.Metadata,
  ): Promise<IsNameAvailableResponse> {
    return this.rpc.unary(ProgramsIsNameAvailableDesc, IsNameAvailableRequest.fromPartial(request), metadata);
  }

  GetProgram(request: DeepPartial<GetProgramRequest>, metadata?: grpc.Metadata): Promise<GetProgramResponse> {
    return this.rpc.unary(ProgramsGetProgramDesc, GetProgramRequest.fromPartial(request), metadata);
  }

  GetProgramData(
    request: DeepPartial<GetProgramDataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramDataResponse> {
    return this.rpc.unary(ProgramsGetProgramDataDesc, GetProgramDataRequest.fromPartial(request), metadata);
  }

  GetProgramDiffs(
    request: DeepPartial<GetProgramDiffsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramDiffsResponse> {
    return this.rpc.unary(ProgramsGetProgramDiffsDesc, GetProgramDiffsRequest.fromPartial(request), metadata);
  }

  UpsertProgram(request: DeepPartial<UpsertProgramRequest>, metadata?: grpc.Metadata): Promise<UpsertProgramResponse> {
    return this.rpc.unary(ProgramsUpsertProgramDesc, UpsertProgramRequest.fromPartial(request), metadata);
  }

  DeleteProgram(request: DeepPartial<DeleteProgramRequest>, metadata?: grpc.Metadata): Promise<DeleteProgramResponse> {
    return this.rpc.unary(ProgramsDeleteProgramDesc, DeleteProgramRequest.fromPartial(request), metadata);
  }

  PublishProgram(
    request: DeepPartial<PublishProgramRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishProgramResponse> {
    return this.rpc.unary(ProgramsPublishProgramDesc, PublishProgramRequest.fromPartial(request), metadata);
  }

  LoadProgram(request: DeepPartial<LoadProgramRequest>, metadata?: grpc.Metadata): Promise<LoadProgramResponse> {
    return this.rpc.unary(ProgramsLoadProgramDesc, LoadProgramRequest.fromPartial(request), metadata);
  }
}

export const ProgramsDesc = { serviceName: "proto.api.Programs" };

export const ProgramsGetProgramsDesc: UnaryMethodDefinitionish = {
  methodName: "GetPrograms",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsGetProgramsListDesc: UnaryMethodDefinitionish = {
  methodName: "GetProgramsList",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramsListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramsListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsIsNameAvailableDesc: UnaryMethodDefinitionish = {
  methodName: "IsNameAvailable",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return IsNameAvailableRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = IsNameAvailableResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsGetProgramDesc: UnaryMethodDefinitionish = {
  methodName: "GetProgram",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsGetProgramDataDesc: UnaryMethodDefinitionish = {
  methodName: "GetProgramData",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramDataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramDataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsGetProgramDiffsDesc: UnaryMethodDefinitionish = {
  methodName: "GetProgramDiffs",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramDiffsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramDiffsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsUpsertProgramDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertProgram",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsDeleteProgramDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteProgram",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsPublishProgramDesc: UnaryMethodDefinitionish = {
  methodName: "PublishProgram",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PublishProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PublishProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsLoadProgramDesc: UnaryMethodDefinitionish = {
  methodName: "LoadProgram",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoadProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoadProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Surveys {
  GetSurveys(request: DeepPartial<GetSurveysRequest>, metadata?: grpc.Metadata): Promise<GetSurveysResponse>;
  GetSurvey(request: DeepPartial<GetSurveyRequest>, metadata?: grpc.Metadata): Promise<GetSurveyResponse>;
  UpsertSurvey(request: DeepPartial<UpsertSurveyRequest>, metadata?: grpc.Metadata): Promise<UpsertSurveyResponse>;
  DeleteSurvey(request: DeepPartial<DeleteSurveyRequest>, metadata?: grpc.Metadata): Promise<DeleteSurveyResponse>;
  PublishSurvey(request: DeepPartial<PublishSurveyRequest>, metadata?: grpc.Metadata): Promise<PublishSurveyResponse>;
  LoadSurvey(request: DeepPartial<LoadSurveyRequest>, metadata?: grpc.Metadata): Promise<LoadSurveyResponse>;
}

export class SurveysClientImpl implements Surveys {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetSurveys = this.GetSurveys.bind(this);
    this.GetSurvey = this.GetSurvey.bind(this);
    this.UpsertSurvey = this.UpsertSurvey.bind(this);
    this.DeleteSurvey = this.DeleteSurvey.bind(this);
    this.PublishSurvey = this.PublishSurvey.bind(this);
    this.LoadSurvey = this.LoadSurvey.bind(this);
  }

  GetSurveys(request: DeepPartial<GetSurveysRequest>, metadata?: grpc.Metadata): Promise<GetSurveysResponse> {
    return this.rpc.unary(SurveysGetSurveysDesc, GetSurveysRequest.fromPartial(request), metadata);
  }

  GetSurvey(request: DeepPartial<GetSurveyRequest>, metadata?: grpc.Metadata): Promise<GetSurveyResponse> {
    return this.rpc.unary(SurveysGetSurveyDesc, GetSurveyRequest.fromPartial(request), metadata);
  }

  UpsertSurvey(request: DeepPartial<UpsertSurveyRequest>, metadata?: grpc.Metadata): Promise<UpsertSurveyResponse> {
    return this.rpc.unary(SurveysUpsertSurveyDesc, UpsertSurveyRequest.fromPartial(request), metadata);
  }

  DeleteSurvey(request: DeepPartial<DeleteSurveyRequest>, metadata?: grpc.Metadata): Promise<DeleteSurveyResponse> {
    return this.rpc.unary(SurveysDeleteSurveyDesc, DeleteSurveyRequest.fromPartial(request), metadata);
  }

  PublishSurvey(request: DeepPartial<PublishSurveyRequest>, metadata?: grpc.Metadata): Promise<PublishSurveyResponse> {
    return this.rpc.unary(SurveysPublishSurveyDesc, PublishSurveyRequest.fromPartial(request), metadata);
  }

  LoadSurvey(request: DeepPartial<LoadSurveyRequest>, metadata?: grpc.Metadata): Promise<LoadSurveyResponse> {
    return this.rpc.unary(SurveysLoadSurveyDesc, LoadSurveyRequest.fromPartial(request), metadata);
  }
}

export const SurveysDesc = { serviceName: "proto.api.Surveys" };

export const SurveysGetSurveysDesc: UnaryMethodDefinitionish = {
  methodName: "GetSurveys",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSurveysRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSurveysResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SurveysGetSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "GetSurvey",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SurveysUpsertSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertSurvey",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SurveysDeleteSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteSurvey",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SurveysPublishSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "PublishSurvey",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PublishSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PublishSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SurveysLoadSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "LoadSurvey",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoadSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoadSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Questionnaires {
  GetQuestionnaires(
    request: DeepPartial<GetQuestionnairesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnairesResponse>;
  GetQuestionnaire(
    request: DeepPartial<GetQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnaireResponse>;
  UpsertQuestionnaire(
    request: DeepPartial<UpsertQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertQuestionnaireResponse>;
  DeleteQuestionnaire(
    request: DeepPartial<DeleteQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteQuestionnaireResponse>;
  PublishQuestionnaire(
    request: DeepPartial<PublishQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishQuestionnaireResponse>;
  LoadQuestionnaire(
    request: DeepPartial<LoadQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<LoadQuestionnaireResponse>;
}

export class QuestionnairesClientImpl implements Questionnaires {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetQuestionnaires = this.GetQuestionnaires.bind(this);
    this.GetQuestionnaire = this.GetQuestionnaire.bind(this);
    this.UpsertQuestionnaire = this.UpsertQuestionnaire.bind(this);
    this.DeleteQuestionnaire = this.DeleteQuestionnaire.bind(this);
    this.PublishQuestionnaire = this.PublishQuestionnaire.bind(this);
    this.LoadQuestionnaire = this.LoadQuestionnaire.bind(this);
  }

  GetQuestionnaires(
    request: DeepPartial<GetQuestionnairesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnairesResponse> {
    return this.rpc.unary(QuestionnairesGetQuestionnairesDesc, GetQuestionnairesRequest.fromPartial(request), metadata);
  }

  GetQuestionnaire(
    request: DeepPartial<GetQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnaireResponse> {
    return this.rpc.unary(QuestionnairesGetQuestionnaireDesc, GetQuestionnaireRequest.fromPartial(request), metadata);
  }

  UpsertQuestionnaire(
    request: DeepPartial<UpsertQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertQuestionnaireResponse> {
    return this.rpc.unary(
      QuestionnairesUpsertQuestionnaireDesc,
      UpsertQuestionnaireRequest.fromPartial(request),
      metadata,
    );
  }

  DeleteQuestionnaire(
    request: DeepPartial<DeleteQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteQuestionnaireResponse> {
    return this.rpc.unary(
      QuestionnairesDeleteQuestionnaireDesc,
      DeleteQuestionnaireRequest.fromPartial(request),
      metadata,
    );
  }

  PublishQuestionnaire(
    request: DeepPartial<PublishQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishQuestionnaireResponse> {
    return this.rpc.unary(
      QuestionnairesPublishQuestionnaireDesc,
      PublishQuestionnaireRequest.fromPartial(request),
      metadata,
    );
  }

  LoadQuestionnaire(
    request: DeepPartial<LoadQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<LoadQuestionnaireResponse> {
    return this.rpc.unary(QuestionnairesLoadQuestionnaireDesc, LoadQuestionnaireRequest.fromPartial(request), metadata);
  }
}

export const QuestionnairesDesc = { serviceName: "proto.api.Questionnaires" };

export const QuestionnairesGetQuestionnairesDesc: UnaryMethodDefinitionish = {
  methodName: "GetQuestionnaires",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetQuestionnairesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetQuestionnairesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuestionnairesGetQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "GetQuestionnaire",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuestionnairesUpsertQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertQuestionnaire",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuestionnairesDeleteQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteQuestionnaire",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuestionnairesPublishQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "PublishQuestionnaire",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PublishQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PublishQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuestionnairesLoadQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "LoadQuestionnaire",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoadQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoadQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Routines {
  GetRoutines(request: DeepPartial<GetRoutinesRequest>, metadata?: grpc.Metadata): Promise<GetRoutinesResponse>;
  GetRoutine(request: DeepPartial<GetRoutineRequest>, metadata?: grpc.Metadata): Promise<GetRoutineResponse>;
  UpsertRoutine(request: DeepPartial<UpsertRoutineRequest>, metadata?: grpc.Metadata): Promise<UpsertRoutineResponse>;
  DeleteRoutine(request: DeepPartial<DeleteRoutineRequest>, metadata?: grpc.Metadata): Promise<DeleteRoutineResponse>;
  PublishRoutine(
    request: DeepPartial<PublishRoutineRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishRoutineResponse>;
  LoadRoutine(request: DeepPartial<LoadRoutineRequest>, metadata?: grpc.Metadata): Promise<LoadRoutineResponse>;
}

export class RoutinesClientImpl implements Routines {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetRoutines = this.GetRoutines.bind(this);
    this.GetRoutine = this.GetRoutine.bind(this);
    this.UpsertRoutine = this.UpsertRoutine.bind(this);
    this.DeleteRoutine = this.DeleteRoutine.bind(this);
    this.PublishRoutine = this.PublishRoutine.bind(this);
    this.LoadRoutine = this.LoadRoutine.bind(this);
  }

  GetRoutines(request: DeepPartial<GetRoutinesRequest>, metadata?: grpc.Metadata): Promise<GetRoutinesResponse> {
    return this.rpc.unary(RoutinesGetRoutinesDesc, GetRoutinesRequest.fromPartial(request), metadata);
  }

  GetRoutine(request: DeepPartial<GetRoutineRequest>, metadata?: grpc.Metadata): Promise<GetRoutineResponse> {
    return this.rpc.unary(RoutinesGetRoutineDesc, GetRoutineRequest.fromPartial(request), metadata);
  }

  UpsertRoutine(request: DeepPartial<UpsertRoutineRequest>, metadata?: grpc.Metadata): Promise<UpsertRoutineResponse> {
    return this.rpc.unary(RoutinesUpsertRoutineDesc, UpsertRoutineRequest.fromPartial(request), metadata);
  }

  DeleteRoutine(request: DeepPartial<DeleteRoutineRequest>, metadata?: grpc.Metadata): Promise<DeleteRoutineResponse> {
    return this.rpc.unary(RoutinesDeleteRoutineDesc, DeleteRoutineRequest.fromPartial(request), metadata);
  }

  PublishRoutine(
    request: DeepPartial<PublishRoutineRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishRoutineResponse> {
    return this.rpc.unary(RoutinesPublishRoutineDesc, PublishRoutineRequest.fromPartial(request), metadata);
  }

  LoadRoutine(request: DeepPartial<LoadRoutineRequest>, metadata?: grpc.Metadata): Promise<LoadRoutineResponse> {
    return this.rpc.unary(RoutinesLoadRoutineDesc, LoadRoutineRequest.fromPartial(request), metadata);
  }
}

export const RoutinesDesc = { serviceName: "proto.api.Routines" };

export const RoutinesGetRoutinesDesc: UnaryMethodDefinitionish = {
  methodName: "GetRoutines",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetRoutinesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetRoutinesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RoutinesGetRoutineDesc: UnaryMethodDefinitionish = {
  methodName: "GetRoutine",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetRoutineRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetRoutineResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RoutinesUpsertRoutineDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertRoutine",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertRoutineRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertRoutineResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RoutinesDeleteRoutineDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteRoutine",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteRoutineRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteRoutineResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RoutinesPublishRoutineDesc: UnaryMethodDefinitionish = {
  methodName: "PublishRoutine",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PublishRoutineRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PublishRoutineResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RoutinesLoadRoutineDesc: UnaryMethodDefinitionish = {
  methodName: "LoadRoutine",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoadRoutineRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoadRoutineResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Displays {
  GetDisplays(request: DeepPartial<GetDisplaysRequest>, metadata?: grpc.Metadata): Promise<GetDisplaysResponse>;
  GetDisplay(request: DeepPartial<GetDisplayRequest>, metadata?: grpc.Metadata): Promise<GetDisplayResponse>;
  UpsertDisplay(request: DeepPartial<UpsertDisplayRequest>, metadata?: grpc.Metadata): Promise<UpsertDisplayResponse>;
  DeleteDisplay(request: DeepPartial<DeleteDisplayRequest>, metadata?: grpc.Metadata): Promise<DeleteDisplayResponse>;
  PublishDisplay(
    request: DeepPartial<PublishDisplayRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishDisplayResponse>;
  LoadDisplay(request: DeepPartial<LoadDisplayRequest>, metadata?: grpc.Metadata): Promise<LoadDisplayResponse>;
}

export class DisplaysClientImpl implements Displays {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetDisplays = this.GetDisplays.bind(this);
    this.GetDisplay = this.GetDisplay.bind(this);
    this.UpsertDisplay = this.UpsertDisplay.bind(this);
    this.DeleteDisplay = this.DeleteDisplay.bind(this);
    this.PublishDisplay = this.PublishDisplay.bind(this);
    this.LoadDisplay = this.LoadDisplay.bind(this);
  }

  GetDisplays(request: DeepPartial<GetDisplaysRequest>, metadata?: grpc.Metadata): Promise<GetDisplaysResponse> {
    return this.rpc.unary(DisplaysGetDisplaysDesc, GetDisplaysRequest.fromPartial(request), metadata);
  }

  GetDisplay(request: DeepPartial<GetDisplayRequest>, metadata?: grpc.Metadata): Promise<GetDisplayResponse> {
    return this.rpc.unary(DisplaysGetDisplayDesc, GetDisplayRequest.fromPartial(request), metadata);
  }

  UpsertDisplay(request: DeepPartial<UpsertDisplayRequest>, metadata?: grpc.Metadata): Promise<UpsertDisplayResponse> {
    return this.rpc.unary(DisplaysUpsertDisplayDesc, UpsertDisplayRequest.fromPartial(request), metadata);
  }

  DeleteDisplay(request: DeepPartial<DeleteDisplayRequest>, metadata?: grpc.Metadata): Promise<DeleteDisplayResponse> {
    return this.rpc.unary(DisplaysDeleteDisplayDesc, DeleteDisplayRequest.fromPartial(request), metadata);
  }

  PublishDisplay(
    request: DeepPartial<PublishDisplayRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishDisplayResponse> {
    return this.rpc.unary(DisplaysPublishDisplayDesc, PublishDisplayRequest.fromPartial(request), metadata);
  }

  LoadDisplay(request: DeepPartial<LoadDisplayRequest>, metadata?: grpc.Metadata): Promise<LoadDisplayResponse> {
    return this.rpc.unary(DisplaysLoadDisplayDesc, LoadDisplayRequest.fromPartial(request), metadata);
  }
}

export const DisplaysDesc = { serviceName: "proto.api.Displays" };

export const DisplaysGetDisplaysDesc: UnaryMethodDefinitionish = {
  methodName: "GetDisplays",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDisplaysRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetDisplaysResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DisplaysGetDisplayDesc: UnaryMethodDefinitionish = {
  methodName: "GetDisplay",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDisplayRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetDisplayResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DisplaysUpsertDisplayDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertDisplay",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertDisplayRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertDisplayResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DisplaysDeleteDisplayDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteDisplay",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteDisplayRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteDisplayResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DisplaysPublishDisplayDesc: UnaryMethodDefinitionish = {
  methodName: "PublishDisplay",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PublishDisplayRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PublishDisplayResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DisplaysLoadDisplayDesc: UnaryMethodDefinitionish = {
  methodName: "LoadDisplay",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoadDisplayRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoadDisplayResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface ParticipantCodes {
  GetCodes(request: DeepPartial<GetCodesRequest>, metadata?: grpc.Metadata): Promise<GetCodesResponse>;
  GenerateCodes(request: DeepPartial<GenerateCodesRequest>, metadata?: grpc.Metadata): Promise<GenerateCodesResponse>;
  AssignCode(request: DeepPartial<AssignCodeRequest>, metadata?: grpc.Metadata): Promise<AssignCodeResponse>;
  DeleteCode(request: DeepPartial<DeleteCodeRequest>, metadata?: grpc.Metadata): Promise<DeleteCodeResponse>;
  UnassignCode(request: DeepPartial<UnassignCodeRequest>, metadata?: grpc.Metadata): Promise<UnassignCodeResponse>;
}

export class ParticipantCodesClientImpl implements ParticipantCodes {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetCodes = this.GetCodes.bind(this);
    this.GenerateCodes = this.GenerateCodes.bind(this);
    this.AssignCode = this.AssignCode.bind(this);
    this.DeleteCode = this.DeleteCode.bind(this);
    this.UnassignCode = this.UnassignCode.bind(this);
  }

  GetCodes(request: DeepPartial<GetCodesRequest>, metadata?: grpc.Metadata): Promise<GetCodesResponse> {
    return this.rpc.unary(ParticipantCodesGetCodesDesc, GetCodesRequest.fromPartial(request), metadata);
  }

  GenerateCodes(request: DeepPartial<GenerateCodesRequest>, metadata?: grpc.Metadata): Promise<GenerateCodesResponse> {
    return this.rpc.unary(ParticipantCodesGenerateCodesDesc, GenerateCodesRequest.fromPartial(request), metadata);
  }

  AssignCode(request: DeepPartial<AssignCodeRequest>, metadata?: grpc.Metadata): Promise<AssignCodeResponse> {
    return this.rpc.unary(ParticipantCodesAssignCodeDesc, AssignCodeRequest.fromPartial(request), metadata);
  }

  DeleteCode(request: DeepPartial<DeleteCodeRequest>, metadata?: grpc.Metadata): Promise<DeleteCodeResponse> {
    return this.rpc.unary(ParticipantCodesDeleteCodeDesc, DeleteCodeRequest.fromPartial(request), metadata);
  }

  UnassignCode(request: DeepPartial<UnassignCodeRequest>, metadata?: grpc.Metadata): Promise<UnassignCodeResponse> {
    return this.rpc.unary(ParticipantCodesUnassignCodeDesc, UnassignCodeRequest.fromPartial(request), metadata);
  }
}

export const ParticipantCodesDesc = { serviceName: "proto.api.ParticipantCodes" };

export const ParticipantCodesGetCodesDesc: UnaryMethodDefinitionish = {
  methodName: "GetCodes",
  service: ParticipantCodesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetCodesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetCodesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParticipantCodesGenerateCodesDesc: UnaryMethodDefinitionish = {
  methodName: "GenerateCodes",
  service: ParticipantCodesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenerateCodesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenerateCodesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParticipantCodesAssignCodeDesc: UnaryMethodDefinitionish = {
  methodName: "AssignCode",
  service: ParticipantCodesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AssignCodeRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AssignCodeResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParticipantCodesDeleteCodeDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteCode",
  service: ParticipantCodesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteCodeRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteCodeResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParticipantCodesUnassignCodeDesc: UnaryMethodDefinitionish = {
  methodName: "UnassignCode",
  service: ParticipantCodesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnassignCodeRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UnassignCodeResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Consents {
  GetConsents(request: DeepPartial<GetConsentsRequest>, metadata?: grpc.Metadata): Promise<GetConsentsResponse>;
  GetConsent(request: DeepPartial<GetConsentRequest>, metadata?: grpc.Metadata): Promise<GetConsentResponse>;
  UpsertConsent(request: DeepPartial<UpsertConsentRequest>, metadata?: grpc.Metadata): Promise<UpsertConsentResponse>;
  DeleteConsent(request: DeepPartial<DeleteConsentRequest>, metadata?: grpc.Metadata): Promise<DeleteConsentResponse>;
  DeleteConsentVersion(
    request: DeepPartial<DeleteConsentVersionRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteConsentVersionResponse>;
  PublishConsent(
    request: DeepPartial<PublishConsentRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishConsentResponse>;
}

export class ConsentsClientImpl implements Consents {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetConsents = this.GetConsents.bind(this);
    this.GetConsent = this.GetConsent.bind(this);
    this.UpsertConsent = this.UpsertConsent.bind(this);
    this.DeleteConsent = this.DeleteConsent.bind(this);
    this.DeleteConsentVersion = this.DeleteConsentVersion.bind(this);
    this.PublishConsent = this.PublishConsent.bind(this);
  }

  GetConsents(request: DeepPartial<GetConsentsRequest>, metadata?: grpc.Metadata): Promise<GetConsentsResponse> {
    return this.rpc.unary(ConsentsGetConsentsDesc, GetConsentsRequest.fromPartial(request), metadata);
  }

  GetConsent(request: DeepPartial<GetConsentRequest>, metadata?: grpc.Metadata): Promise<GetConsentResponse> {
    return this.rpc.unary(ConsentsGetConsentDesc, GetConsentRequest.fromPartial(request), metadata);
  }

  UpsertConsent(request: DeepPartial<UpsertConsentRequest>, metadata?: grpc.Metadata): Promise<UpsertConsentResponse> {
    return this.rpc.unary(ConsentsUpsertConsentDesc, UpsertConsentRequest.fromPartial(request), metadata);
  }

  DeleteConsent(request: DeepPartial<DeleteConsentRequest>, metadata?: grpc.Metadata): Promise<DeleteConsentResponse> {
    return this.rpc.unary(ConsentsDeleteConsentDesc, DeleteConsentRequest.fromPartial(request), metadata);
  }

  DeleteConsentVersion(
    request: DeepPartial<DeleteConsentVersionRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteConsentVersionResponse> {
    return this.rpc.unary(ConsentsDeleteConsentVersionDesc, DeleteConsentVersionRequest.fromPartial(request), metadata);
  }

  PublishConsent(
    request: DeepPartial<PublishConsentRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PublishConsentResponse> {
    return this.rpc.unary(ConsentsPublishConsentDesc, PublishConsentRequest.fromPartial(request), metadata);
  }
}

export const ConsentsDesc = { serviceName: "proto.api.Consents" };

export const ConsentsGetConsentsDesc: UnaryMethodDefinitionish = {
  methodName: "GetConsents",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConsentsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetConsentsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConsentsGetConsentDesc: UnaryMethodDefinitionish = {
  methodName: "GetConsent",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConsentRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetConsentResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConsentsUpsertConsentDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertConsent",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertConsentRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertConsentResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConsentsDeleteConsentDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteConsent",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteConsentRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteConsentResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConsentsDeleteConsentVersionDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteConsentVersion",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteConsentVersionRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteConsentVersionResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConsentsPublishConsentDesc: UnaryMethodDefinitionish = {
  methodName: "PublishConsent",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PublishConsentRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PublishConsentResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface StandaloneSurveys {
  GetStandaloneSurveys(
    request: DeepPartial<GetStandaloneSurveysRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneSurveysResponse>;
  GetStandaloneSurvey(
    request: DeepPartial<GetStandaloneSurveyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneSurveyResponse>;
  UpsertStandaloneSurvey(
    request: DeepPartial<UpsertStandaloneSurveyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertStandaloneSurveyResponse>;
  DeleteStandaloneSurvey(
    request: DeepPartial<DeleteStandaloneSurveyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteStandaloneSurveyResponse>;
}

export class StandaloneSurveysClientImpl implements StandaloneSurveys {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetStandaloneSurveys = this.GetStandaloneSurveys.bind(this);
    this.GetStandaloneSurvey = this.GetStandaloneSurvey.bind(this);
    this.UpsertStandaloneSurvey = this.UpsertStandaloneSurvey.bind(this);
    this.DeleteStandaloneSurvey = this.DeleteStandaloneSurvey.bind(this);
  }

  GetStandaloneSurveys(
    request: DeepPartial<GetStandaloneSurveysRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneSurveysResponse> {
    return this.rpc.unary(
      StandaloneSurveysGetStandaloneSurveysDesc,
      GetStandaloneSurveysRequest.fromPartial(request),
      metadata,
    );
  }

  GetStandaloneSurvey(
    request: DeepPartial<GetStandaloneSurveyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneSurveyResponse> {
    return this.rpc.unary(
      StandaloneSurveysGetStandaloneSurveyDesc,
      GetStandaloneSurveyRequest.fromPartial(request),
      metadata,
    );
  }

  UpsertStandaloneSurvey(
    request: DeepPartial<UpsertStandaloneSurveyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertStandaloneSurveyResponse> {
    return this.rpc.unary(
      StandaloneSurveysUpsertStandaloneSurveyDesc,
      UpsertStandaloneSurveyRequest.fromPartial(request),
      metadata,
    );
  }

  DeleteStandaloneSurvey(
    request: DeepPartial<DeleteStandaloneSurveyRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteStandaloneSurveyResponse> {
    return this.rpc.unary(
      StandaloneSurveysDeleteStandaloneSurveyDesc,
      DeleteStandaloneSurveyRequest.fromPartial(request),
      metadata,
    );
  }
}

export const StandaloneSurveysDesc = { serviceName: "proto.api.StandaloneSurveys" };

export const StandaloneSurveysGetStandaloneSurveysDesc: UnaryMethodDefinitionish = {
  methodName: "GetStandaloneSurveys",
  service: StandaloneSurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetStandaloneSurveysRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetStandaloneSurveysResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const StandaloneSurveysGetStandaloneSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "GetStandaloneSurvey",
  service: StandaloneSurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetStandaloneSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetStandaloneSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const StandaloneSurveysUpsertStandaloneSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertStandaloneSurvey",
  service: StandaloneSurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertStandaloneSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertStandaloneSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const StandaloneSurveysDeleteStandaloneSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteStandaloneSurvey",
  service: StandaloneSurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteStandaloneSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteStandaloneSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface StandaloneQuestionnaires {
  GetStandaloneQuestionnaires(
    request: DeepPartial<GetStandaloneQuestionnairesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneQuestionnairesResponse>;
  GetStandaloneQuestionnaire(
    request: DeepPartial<GetStandaloneQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneQuestionnaireResponse>;
  UpsertStandaloneQuestionnaire(
    request: DeepPartial<UpsertStandaloneQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertStandaloneQuestionnaireResponse>;
  DeleteStandaloneQuestionnaire(
    request: DeepPartial<DeleteStandaloneQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteStandaloneQuestionnaireResponse>;
}

export class StandaloneQuestionnairesClientImpl implements StandaloneQuestionnaires {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetStandaloneQuestionnaires = this.GetStandaloneQuestionnaires.bind(this);
    this.GetStandaloneQuestionnaire = this.GetStandaloneQuestionnaire.bind(this);
    this.UpsertStandaloneQuestionnaire = this.UpsertStandaloneQuestionnaire.bind(this);
    this.DeleteStandaloneQuestionnaire = this.DeleteStandaloneQuestionnaire.bind(this);
  }

  GetStandaloneQuestionnaires(
    request: DeepPartial<GetStandaloneQuestionnairesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneQuestionnairesResponse> {
    return this.rpc.unary(
      StandaloneQuestionnairesGetStandaloneQuestionnairesDesc,
      GetStandaloneQuestionnairesRequest.fromPartial(request),
      metadata,
    );
  }

  GetStandaloneQuestionnaire(
    request: DeepPartial<GetStandaloneQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetStandaloneQuestionnaireResponse> {
    return this.rpc.unary(
      StandaloneQuestionnairesGetStandaloneQuestionnaireDesc,
      GetStandaloneQuestionnaireRequest.fromPartial(request),
      metadata,
    );
  }

  UpsertStandaloneQuestionnaire(
    request: DeepPartial<UpsertStandaloneQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpsertStandaloneQuestionnaireResponse> {
    return this.rpc.unary(
      StandaloneQuestionnairesUpsertStandaloneQuestionnaireDesc,
      UpsertStandaloneQuestionnaireRequest.fromPartial(request),
      metadata,
    );
  }

  DeleteStandaloneQuestionnaire(
    request: DeepPartial<DeleteStandaloneQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<DeleteStandaloneQuestionnaireResponse> {
    return this.rpc.unary(
      StandaloneQuestionnairesDeleteStandaloneQuestionnaireDesc,
      DeleteStandaloneQuestionnaireRequest.fromPartial(request),
      metadata,
    );
  }
}

export const StandaloneQuestionnairesDesc = { serviceName: "proto.api.StandaloneQuestionnaires" };

export const StandaloneQuestionnairesGetStandaloneQuestionnairesDesc: UnaryMethodDefinitionish = {
  methodName: "GetStandaloneQuestionnaires",
  service: StandaloneQuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetStandaloneQuestionnairesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetStandaloneQuestionnairesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const StandaloneQuestionnairesGetStandaloneQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "GetStandaloneQuestionnaire",
  service: StandaloneQuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetStandaloneQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetStandaloneQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const StandaloneQuestionnairesUpsertStandaloneQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertStandaloneQuestionnaire",
  service: StandaloneQuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertStandaloneQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertStandaloneQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const StandaloneQuestionnairesDeleteStandaloneQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteStandaloneQuestionnaire",
  service: StandaloneQuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteStandaloneQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteStandaloneQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Uploads {
  GetSubjects(request: DeepPartial<GetSubjectsRequest>, metadata?: grpc.Metadata): Promise<GetSubjectsResponse>;
  GetSubjectData(
    request: DeepPartial<GetSubjectDataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetSubjectDataResponse>;
  GetSubjectResource(
    request: DeepPartial<GetSubjectResourceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetSubjectResourceResponse>;
  GetDownloadList(
    request: DeepPartial<GetDownloadListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetDownloadListResponse>;
  GetDownloadTicket(
    request: DeepPartial<GetDownloadTicketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetDownloadTicketResponse>;
  GetStatistics(request: DeepPartial<GetStatisticsRequest>, metadata?: grpc.Metadata): Promise<GetStatisticsResponse>;
}

export class UploadsClientImpl implements Uploads {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetSubjects = this.GetSubjects.bind(this);
    this.GetSubjectData = this.GetSubjectData.bind(this);
    this.GetSubjectResource = this.GetSubjectResource.bind(this);
    this.GetDownloadList = this.GetDownloadList.bind(this);
    this.GetDownloadTicket = this.GetDownloadTicket.bind(this);
    this.GetStatistics = this.GetStatistics.bind(this);
  }

  GetSubjects(request: DeepPartial<GetSubjectsRequest>, metadata?: grpc.Metadata): Promise<GetSubjectsResponse> {
    return this.rpc.unary(UploadsGetSubjectsDesc, GetSubjectsRequest.fromPartial(request), metadata);
  }

  GetSubjectData(
    request: DeepPartial<GetSubjectDataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetSubjectDataResponse> {
    return this.rpc.unary(UploadsGetSubjectDataDesc, GetSubjectDataRequest.fromPartial(request), metadata);
  }

  GetSubjectResource(
    request: DeepPartial<GetSubjectResourceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetSubjectResourceResponse> {
    return this.rpc.unary(UploadsGetSubjectResourceDesc, GetSubjectResourceRequest.fromPartial(request), metadata);
  }

  GetDownloadList(
    request: DeepPartial<GetDownloadListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetDownloadListResponse> {
    return this.rpc.unary(UploadsGetDownloadListDesc, GetDownloadListRequest.fromPartial(request), metadata);
  }

  GetDownloadTicket(
    request: DeepPartial<GetDownloadTicketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetDownloadTicketResponse> {
    return this.rpc.unary(UploadsGetDownloadTicketDesc, GetDownloadTicketRequest.fromPartial(request), metadata);
  }

  GetStatistics(request: DeepPartial<GetStatisticsRequest>, metadata?: grpc.Metadata): Promise<GetStatisticsResponse> {
    return this.rpc.unary(UploadsGetStatisticsDesc, GetStatisticsRequest.fromPartial(request), metadata);
  }
}

export const UploadsDesc = { serviceName: "proto.api.Uploads" };

export const UploadsGetSubjectsDesc: UnaryMethodDefinitionish = {
  methodName: "GetSubjects",
  service: UploadsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSubjectsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSubjectsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UploadsGetSubjectDataDesc: UnaryMethodDefinitionish = {
  methodName: "GetSubjectData",
  service: UploadsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSubjectDataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSubjectDataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UploadsGetSubjectResourceDesc: UnaryMethodDefinitionish = {
  methodName: "GetSubjectResource",
  service: UploadsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSubjectResourceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSubjectResourceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UploadsGetDownloadListDesc: UnaryMethodDefinitionish = {
  methodName: "GetDownloadList",
  service: UploadsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDownloadListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetDownloadListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UploadsGetDownloadTicketDesc: UnaryMethodDefinitionish = {
  methodName: "GetDownloadTicket",
  service: UploadsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDownloadTicketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetDownloadTicketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const UploadsGetStatisticsDesc: UnaryMethodDefinitionish = {
  methodName: "GetStatistics",
  service: UploadsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetStatisticsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetStatisticsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Images {
  GetImage(request: DeepPartial<GetImageRequest>, metadata?: grpc.Metadata): Promise<HttpBody>;
  UpsertImage(request: DeepPartial<UpsertImageRequest>, metadata?: grpc.Metadata): Promise<UpsertImageResponse>;
  DeleteImage(request: DeepPartial<DeleteImageRequest>, metadata?: grpc.Metadata): Promise<DeleteImageResponse>;
}

export class ImagesClientImpl implements Images {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetImage = this.GetImage.bind(this);
    this.UpsertImage = this.UpsertImage.bind(this);
    this.DeleteImage = this.DeleteImage.bind(this);
  }

  GetImage(request: DeepPartial<GetImageRequest>, metadata?: grpc.Metadata): Promise<HttpBody> {
    return this.rpc.unary(ImagesGetImageDesc, GetImageRequest.fromPartial(request), metadata);
  }

  UpsertImage(request: DeepPartial<UpsertImageRequest>, metadata?: grpc.Metadata): Promise<UpsertImageResponse> {
    return this.rpc.unary(ImagesUpsertImageDesc, UpsertImageRequest.fromPartial(request), metadata);
  }

  DeleteImage(request: DeepPartial<DeleteImageRequest>, metadata?: grpc.Metadata): Promise<DeleteImageResponse> {
    return this.rpc.unary(ImagesDeleteImageDesc, DeleteImageRequest.fromPartial(request), metadata);
  }
}

export const ImagesDesc = { serviceName: "proto.api.Images" };

export const ImagesGetImageDesc: UnaryMethodDefinitionish = {
  methodName: "GetImage",
  service: ImagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetImageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = HttpBody.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ImagesUpsertImageDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertImage",
  service: ImagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertImageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertImageResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ImagesDeleteImageDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteImage",
  service: ImagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteImageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteImageResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Clients {
  GetClients(request: DeepPartial<GetClientsRequest>, metadata?: grpc.Metadata): Promise<GetClientsResponse>;
  GetClient(request: DeepPartial<GetClientRequest>, metadata?: grpc.Metadata): Promise<GetClientResponse>;
  UpsertClient(request: DeepPartial<UpsertClientRequest>, metadata?: grpc.Metadata): Promise<UpsertClientResponse>;
  ExchangeToken(request: DeepPartial<ExchangeTokenRequest>, metadata?: grpc.Metadata): Promise<ExchangeTokenResponse>;
  DeleteClient(request: DeepPartial<DeleteClientRequest>, metadata?: grpc.Metadata): Promise<DeleteClientResponse>;
}

export class ClientsClientImpl implements Clients {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetClients = this.GetClients.bind(this);
    this.GetClient = this.GetClient.bind(this);
    this.UpsertClient = this.UpsertClient.bind(this);
    this.ExchangeToken = this.ExchangeToken.bind(this);
    this.DeleteClient = this.DeleteClient.bind(this);
  }

  GetClients(request: DeepPartial<GetClientsRequest>, metadata?: grpc.Metadata): Promise<GetClientsResponse> {
    return this.rpc.unary(ClientsGetClientsDesc, GetClientsRequest.fromPartial(request), metadata);
  }

  GetClient(request: DeepPartial<GetClientRequest>, metadata?: grpc.Metadata): Promise<GetClientResponse> {
    return this.rpc.unary(ClientsGetClientDesc, GetClientRequest.fromPartial(request), metadata);
  }

  UpsertClient(request: DeepPartial<UpsertClientRequest>, metadata?: grpc.Metadata): Promise<UpsertClientResponse> {
    return this.rpc.unary(ClientsUpsertClientDesc, UpsertClientRequest.fromPartial(request), metadata);
  }

  ExchangeToken(request: DeepPartial<ExchangeTokenRequest>, metadata?: grpc.Metadata): Promise<ExchangeTokenResponse> {
    return this.rpc.unary(ClientsExchangeTokenDesc, ExchangeTokenRequest.fromPartial(request), metadata);
  }

  DeleteClient(request: DeepPartial<DeleteClientRequest>, metadata?: grpc.Metadata): Promise<DeleteClientResponse> {
    return this.rpc.unary(ClientsDeleteClientDesc, DeleteClientRequest.fromPartial(request), metadata);
  }
}

export const ClientsDesc = { serviceName: "proto.api.Clients" };

export const ClientsGetClientsDesc: UnaryMethodDefinitionish = {
  methodName: "GetClients",
  service: ClientsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetClientsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetClientsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ClientsGetClientDesc: UnaryMethodDefinitionish = {
  methodName: "GetClient",
  service: ClientsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetClientRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetClientResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ClientsUpsertClientDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertClient",
  service: ClientsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertClientRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertClientResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ClientsExchangeTokenDesc: UnaryMethodDefinitionish = {
  methodName: "ExchangeToken",
  service: ClientsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ExchangeTokenRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ExchangeTokenResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ClientsDeleteClientDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteClient",
  service: ClientsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteClientRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteClientResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Messages {
  GetMessages(request: DeepPartial<GetMessagesRequest>, metadata?: grpc.Metadata): Promise<GetMessagesResponse>;
  GetMessage(request: DeepPartial<GetMessageRequest>, metadata?: grpc.Metadata): Promise<GetMessageResponse>;
  UpsertMessage(request: DeepPartial<UpsertMessageRequest>, metadata?: grpc.Metadata): Promise<UpsertMessageResponse>;
  DeleteMessage(request: DeepPartial<DeleteMessageRequest>, metadata?: grpc.Metadata): Promise<DeleteMessageResponse>;
  SendMessage(request: DeepPartial<SendMessageRequest>, metadata?: grpc.Metadata): Promise<SendMessageResponse>;
}

export class MessagesClientImpl implements Messages {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetMessages = this.GetMessages.bind(this);
    this.GetMessage = this.GetMessage.bind(this);
    this.UpsertMessage = this.UpsertMessage.bind(this);
    this.DeleteMessage = this.DeleteMessage.bind(this);
    this.SendMessage = this.SendMessage.bind(this);
  }

  GetMessages(request: DeepPartial<GetMessagesRequest>, metadata?: grpc.Metadata): Promise<GetMessagesResponse> {
    return this.rpc.unary(MessagesGetMessagesDesc, GetMessagesRequest.fromPartial(request), metadata);
  }

  GetMessage(request: DeepPartial<GetMessageRequest>, metadata?: grpc.Metadata): Promise<GetMessageResponse> {
    return this.rpc.unary(MessagesGetMessageDesc, GetMessageRequest.fromPartial(request), metadata);
  }

  UpsertMessage(request: DeepPartial<UpsertMessageRequest>, metadata?: grpc.Metadata): Promise<UpsertMessageResponse> {
    return this.rpc.unary(MessagesUpsertMessageDesc, UpsertMessageRequest.fromPartial(request), metadata);
  }

  DeleteMessage(request: DeepPartial<DeleteMessageRequest>, metadata?: grpc.Metadata): Promise<DeleteMessageResponse> {
    return this.rpc.unary(MessagesDeleteMessageDesc, DeleteMessageRequest.fromPartial(request), metadata);
  }

  SendMessage(request: DeepPartial<SendMessageRequest>, metadata?: grpc.Metadata): Promise<SendMessageResponse> {
    return this.rpc.unary(MessagesSendMessageDesc, SendMessageRequest.fromPartial(request), metadata);
  }
}

export const MessagesDesc = { serviceName: "proto.api.Messages" };

export const MessagesGetMessagesDesc: UnaryMethodDefinitionish = {
  methodName: "GetMessages",
  service: MessagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetMessagesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetMessagesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MessagesGetMessageDesc: UnaryMethodDefinitionish = {
  methodName: "GetMessage",
  service: MessagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetMessageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetMessageResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MessagesUpsertMessageDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertMessage",
  service: MessagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertMessageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertMessageResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MessagesDeleteMessageDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteMessage",
  service: MessagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteMessageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteMessageResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MessagesSendMessageDesc: UnaryMethodDefinitionish = {
  methodName: "SendMessage",
  service: MessagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SendMessageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SendMessageResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface DeviceTokens {
  GetTokens(request: DeepPartial<GetTokensRequest>, metadata?: grpc.Metadata): Promise<GetTokensResponse>;
  UpsertToken(request: DeepPartial<UpsertTokenRequest>, metadata?: grpc.Metadata): Promise<UpsertTokenResponse>;
  DeleteToken(request: DeepPartial<DeleteTokenRequest>, metadata?: grpc.Metadata): Promise<DeleteTokenResponse>;
}

export class DeviceTokensClientImpl implements DeviceTokens {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetTokens = this.GetTokens.bind(this);
    this.UpsertToken = this.UpsertToken.bind(this);
    this.DeleteToken = this.DeleteToken.bind(this);
  }

  GetTokens(request: DeepPartial<GetTokensRequest>, metadata?: grpc.Metadata): Promise<GetTokensResponse> {
    return this.rpc.unary(DeviceTokensGetTokensDesc, GetTokensRequest.fromPartial(request), metadata);
  }

  UpsertToken(request: DeepPartial<UpsertTokenRequest>, metadata?: grpc.Metadata): Promise<UpsertTokenResponse> {
    return this.rpc.unary(DeviceTokensUpsertTokenDesc, UpsertTokenRequest.fromPartial(request), metadata);
  }

  DeleteToken(request: DeepPartial<DeleteTokenRequest>, metadata?: grpc.Metadata): Promise<DeleteTokenResponse> {
    return this.rpc.unary(DeviceTokensDeleteTokenDesc, DeleteTokenRequest.fromPartial(request), metadata);
  }
}

export const DeviceTokensDesc = { serviceName: "proto.api.DeviceTokens" };

export const DeviceTokensGetTokensDesc: UnaryMethodDefinitionish = {
  methodName: "GetTokens",
  service: DeviceTokensDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetTokensRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetTokensResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DeviceTokensUpsertTokenDesc: UnaryMethodDefinitionish = {
  methodName: "UpsertToken",
  service: DeviceTokensDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpsertTokenRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpsertTokenResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DeviceTokensDeleteTokenDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteToken",
  service: DeviceTokensDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteTokenRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteTokenResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Checks {
  Liveness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse>;
  Readiness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse>;
}

export class ChecksClientImpl implements Checks {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Liveness = this.Liveness.bind(this);
    this.Readiness = this.Readiness.bind(this);
  }

  Liveness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse> {
    return this.rpc.unary(ChecksLivenessDesc, ChecksRequest.fromPartial(request), metadata);
  }

  Readiness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse> {
    return this.rpc.unary(ChecksReadinessDesc, ChecksRequest.fromPartial(request), metadata);
  }
}

export const ChecksDesc = { serviceName: "proto.api.Checks" };

export const ChecksLivenessDesc: UnaryMethodDefinitionish = {
  methodName: "Liveness",
  service: ChecksDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ChecksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ChecksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ChecksReadinessDesc: UnaryMethodDefinitionish = {
  methodName: "Readiness",
  service: ChecksDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ChecksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ChecksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
