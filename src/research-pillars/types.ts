// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.4
// source: research-pillars/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "../google/protobuf/struct";

export const protobufPackage = "proto";

export enum InputType {
  /** display - Default Types */
  display = 0,
  string = 1,
  text = 2,
  integer = 3,
  decimal = 4,
  date = 5,
  /** single_select - Mapped Types */
  single_select = 6,
  /** multi_select - coding */
  multi_select = 7,
  /** year - date */
  year = 8,
  /** scale_numeric - decimal */
  scale_numeric = 9,
  /** scale_ordinal - integer */
  scale_ordinal = 10,
  UNRECOGNIZED = -1,
}

export function inputTypeFromJSON(object: any): InputType {
  switch (object) {
    case 0:
    case "display":
      return InputType.display;
    case 1:
    case "string":
      return InputType.string;
    case 2:
    case "text":
      return InputType.text;
    case 3:
    case "integer":
      return InputType.integer;
    case 4:
    case "decimal":
      return InputType.decimal;
    case 5:
    case "date":
      return InputType.date;
    case 6:
    case "single_select":
      return InputType.single_select;
    case 7:
    case "multi_select":
      return InputType.multi_select;
    case 8:
    case "year":
      return InputType.year;
    case 9:
    case "scale_numeric":
      return InputType.scale_numeric;
    case 10:
    case "scale_ordinal":
      return InputType.scale_ordinal;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InputType.UNRECOGNIZED;
  }
}

export function inputTypeToJSON(object: InputType): string {
  switch (object) {
    case InputType.display:
      return "display";
    case InputType.string:
      return "string";
    case InputType.text:
      return "text";
    case InputType.integer:
      return "integer";
    case InputType.decimal:
      return "decimal";
    case InputType.date:
      return "date";
    case InputType.single_select:
      return "single_select";
    case InputType.multi_select:
      return "multi_select";
    case InputType.year:
      return "year";
    case InputType.scale_numeric:
      return "scale_numeric";
    case InputType.scale_ordinal:
      return "scale_ordinal";
    case InputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Operator {
  exists = 0,
  eq = 1,
  neq = 2,
  gt = 3,
  lt = 4,
  gteq = 5,
  lteq = 6,
  UNRECOGNIZED = -1,
}

export function operatorFromJSON(object: any): Operator {
  switch (object) {
    case 0:
    case "exists":
      return Operator.exists;
    case 1:
    case "eq":
      return Operator.eq;
    case 2:
    case "neq":
      return Operator.neq;
    case 3:
    case "gt":
      return Operator.gt;
    case 4:
    case "lt":
      return Operator.lt;
    case 5:
    case "gteq":
      return Operator.gteq;
    case 6:
    case "lteq":
      return Operator.lteq;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operator.UNRECOGNIZED;
  }
}

export function operatorToJSON(object: Operator): string {
  switch (object) {
    case Operator.exists:
      return "exists";
    case Operator.eq:
      return "eq";
    case Operator.neq:
      return "neq";
    case Operator.gt:
      return "gt";
    case Operator.lt:
      return "lt";
    case Operator.gteq:
      return "gteq";
    case Operator.lteq:
      return "lteq";
    case Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Role {
  viewer = 0,
  editor = 1,
  manager = 2,
  UNRECOGNIZED = -1,
}

export function roleFromJSON(object: any): Role {
  switch (object) {
    case 0:
    case "viewer":
      return Role.viewer;
    case 1:
    case "editor":
      return Role.editor;
    case 2:
    case "manager":
      return Role.manager;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role.UNRECOGNIZED;
  }
}

export function roleToJSON(object: Role): string {
  switch (object) {
    case Role.viewer:
      return "viewer";
    case Role.editor:
      return "editor";
    case Role.manager:
      return "manager";
    case Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CodeStatus {
  unused = 0,
  used = 1,
  UNRECOGNIZED = -1,
}

export function codeStatusFromJSON(object: any): CodeStatus {
  switch (object) {
    case 0:
    case "unused":
      return CodeStatus.unused;
    case 1:
    case "used":
      return CodeStatus.used;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CodeStatus.UNRECOGNIZED;
  }
}

export function codeStatusToJSON(object: CodeStatus): string {
  switch (object) {
    case CodeStatus.unused:
      return "unused";
    case CodeStatus.used:
      return "used";
    case CodeStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Questionnaire {
  name: string;
  version: string;
  title: { [key: string]: string };
  questions: Question[];
}

export interface Questionnaire_TitleEntry {
  key: string;
  value: string;
}

export interface Question {
  linkId: string;
  inputType: InputType;
  required: boolean;
  text: { [key: string]: string };
  answerset?: Answerset | undefined;
  config?: { [key: string]: any } | undefined;
  enableWhen: EnableWhen[];
  enableBehavior?: string | undefined;
}

export interface Question_TextEntry {
  key: string;
  value: string;
}

export interface Answerset {
  order: string;
  answers: Answer[];
}

export interface Answer {
  code: string;
  languages: { [key: string]: string };
}

export interface Answer_LanguagesEntry {
  key: string;
  value: string;
}

export interface EnableWhen {
  question: string;
  operator: Operator;
  answerCoding?: string | undefined;
  answerDecimal?: number | undefined;
  answerDate?: string | undefined;
}

export interface Diff {
  change?: { [key: string]: any } | undefined;
  timestamp: string;
  user?: User | undefined;
}

export interface User {
  email: string;
  name: string;
  isAdmin: boolean;
  programRoles: ProgramRole[];
}

export interface ProgramRole {
  userEmail: string;
  programName: string;
  role: Role;
}

export interface BlockedProgram {
  userEmail: string;
  programName: string;
  timestamp: string;
}

export interface ParticipantCode {
  code: string;
  status: CodeStatus;
}

export interface Client {
  name: string;
  programName: string;
  clientID: string;
  clientSecret: string;
}

function createBaseQuestionnaire(): Questionnaire {
  return { name: "", version: "", title: {}, questions: [] };
}

export const Questionnaire: MessageFns<Questionnaire> = {
  encode(message: Questionnaire, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    Object.entries(message.title).forEach(([key, value]) => {
      Questionnaire_TitleEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.questions) {
      Question.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Questionnaire {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionnaire();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Questionnaire_TitleEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.title[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.questions.push(Question.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Questionnaire {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      title: isObject(object.title)
        ? Object.entries(object.title).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      questions: globalThis.Array.isArray(object?.questions)
        ? object.questions.map((e: any) => Question.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Questionnaire): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.title) {
      const entries = Object.entries(message.title);
      if (entries.length > 0) {
        obj.title = {};
        entries.forEach(([k, v]) => {
          obj.title[k] = v;
        });
      }
    }
    if (message.questions?.length) {
      obj.questions = message.questions.map((e) => Question.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Questionnaire>, I>>(base?: I): Questionnaire {
    return Questionnaire.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Questionnaire>, I>>(object: I): Questionnaire {
    const message = createBaseQuestionnaire();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.title = Object.entries(object.title ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.questions = object.questions?.map((e) => Question.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuestionnaire_TitleEntry(): Questionnaire_TitleEntry {
  return { key: "", value: "" };
}

export const Questionnaire_TitleEntry: MessageFns<Questionnaire_TitleEntry> = {
  encode(message: Questionnaire_TitleEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Questionnaire_TitleEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionnaire_TitleEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Questionnaire_TitleEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Questionnaire_TitleEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Questionnaire_TitleEntry>, I>>(base?: I): Questionnaire_TitleEntry {
    return Questionnaire_TitleEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Questionnaire_TitleEntry>, I>>(object: I): Questionnaire_TitleEntry {
    const message = createBaseQuestionnaire_TitleEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQuestion(): Question {
  return {
    linkId: "",
    inputType: 0,
    required: false,
    text: {},
    answerset: undefined,
    config: undefined,
    enableWhen: [],
    enableBehavior: undefined,
  };
}

export const Question: MessageFns<Question> = {
  encode(message: Question, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linkId !== "") {
      writer.uint32(10).string(message.linkId);
    }
    if (message.inputType !== 0) {
      writer.uint32(16).int32(message.inputType);
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    Object.entries(message.text).forEach(([key, value]) => {
      Question_TextEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.answerset !== undefined) {
      Answerset.encode(message.answerset, writer.uint32(42).fork()).join();
    }
    if (message.config !== undefined) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(50).fork()).join();
    }
    for (const v of message.enableWhen) {
      EnableWhen.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.enableBehavior !== undefined) {
      writer.uint32(66).string(message.enableBehavior);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Question {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.linkId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Question_TextEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.text[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.answerset = Answerset.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.enableWhen.push(EnableWhen.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.enableBehavior = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Question {
    return {
      linkId: isSet(object.linkId) ? globalThis.String(object.linkId) : "",
      inputType: isSet(object.inputType) ? inputTypeFromJSON(object.inputType) : 0,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      text: isObject(object.text)
        ? Object.entries(object.text).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerset: isSet(object.answerset) ? Answerset.fromJSON(object.answerset) : undefined,
      config: isObject(object.config) ? object.config : undefined,
      enableWhen: globalThis.Array.isArray(object?.enableWhen)
        ? object.enableWhen.map((e: any) => EnableWhen.fromJSON(e))
        : [],
      enableBehavior: isSet(object.enableBehavior) ? globalThis.String(object.enableBehavior) : undefined,
    };
  },

  toJSON(message: Question): unknown {
    const obj: any = {};
    if (message.linkId !== "") {
      obj.linkId = message.linkId;
    }
    if (message.inputType !== 0) {
      obj.inputType = inputTypeToJSON(message.inputType);
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.text) {
      const entries = Object.entries(message.text);
      if (entries.length > 0) {
        obj.text = {};
        entries.forEach(([k, v]) => {
          obj.text[k] = v;
        });
      }
    }
    if (message.answerset !== undefined) {
      obj.answerset = Answerset.toJSON(message.answerset);
    }
    if (message.config !== undefined) {
      obj.config = message.config;
    }
    if (message.enableWhen?.length) {
      obj.enableWhen = message.enableWhen.map((e) => EnableWhen.toJSON(e));
    }
    if (message.enableBehavior !== undefined) {
      obj.enableBehavior = message.enableBehavior;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Question>, I>>(base?: I): Question {
    return Question.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Question>, I>>(object: I): Question {
    const message = createBaseQuestion();
    message.linkId = object.linkId ?? "";
    message.inputType = object.inputType ?? 0;
    message.required = object.required ?? false;
    message.text = Object.entries(object.text ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerset = (object.answerset !== undefined && object.answerset !== null)
      ? Answerset.fromPartial(object.answerset)
      : undefined;
    message.config = object.config ?? undefined;
    message.enableWhen = object.enableWhen?.map((e) => EnableWhen.fromPartial(e)) || [];
    message.enableBehavior = object.enableBehavior ?? undefined;
    return message;
  },
};

function createBaseQuestion_TextEntry(): Question_TextEntry {
  return { key: "", value: "" };
}

export const Question_TextEntry: MessageFns<Question_TextEntry> = {
  encode(message: Question_TextEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Question_TextEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestion_TextEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Question_TextEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Question_TextEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Question_TextEntry>, I>>(base?: I): Question_TextEntry {
    return Question_TextEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Question_TextEntry>, I>>(object: I): Question_TextEntry {
    const message = createBaseQuestion_TextEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnswerset(): Answerset {
  return { order: "", answers: [] };
}

export const Answerset: MessageFns<Answerset> = {
  encode(message: Answerset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== "") {
      writer.uint32(10).string(message.order);
    }
    for (const v of message.answers) {
      Answer.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answerset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswerset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.answers.push(Answer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answerset {
    return {
      order: isSet(object.order) ? globalThis.String(object.order) : "",
      answers: globalThis.Array.isArray(object?.answers) ? object.answers.map((e: any) => Answer.fromJSON(e)) : [],
    };
  },

  toJSON(message: Answerset): unknown {
    const obj: any = {};
    if (message.order !== "") {
      obj.order = message.order;
    }
    if (message.answers?.length) {
      obj.answers = message.answers.map((e) => Answer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Answerset>, I>>(base?: I): Answerset {
    return Answerset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Answerset>, I>>(object: I): Answerset {
    const message = createBaseAnswerset();
    message.order = object.order ?? "";
    message.answers = object.answers?.map((e) => Answer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnswer(): Answer {
  return { code: "", languages: {} };
}

export const Answer: MessageFns<Answer> = {
  encode(message: Answer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    Object.entries(message.languages).forEach(([key, value]) => {
      Answer_LanguagesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Answer_LanguagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.languages[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      languages: isObject(object.languages)
        ? Object.entries(object.languages).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Answer): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.languages) {
      const entries = Object.entries(message.languages);
      if (entries.length > 0) {
        obj.languages = {};
        entries.forEach(([k, v]) => {
          obj.languages[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Answer>, I>>(base?: I): Answer {
    return Answer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Answer>, I>>(object: I): Answer {
    const message = createBaseAnswer();
    message.code = object.code ?? "";
    message.languages = Object.entries(object.languages ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnswer_LanguagesEntry(): Answer_LanguagesEntry {
  return { key: "", value: "" };
}

export const Answer_LanguagesEntry: MessageFns<Answer_LanguagesEntry> = {
  encode(message: Answer_LanguagesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_LanguagesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_LanguagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_LanguagesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Answer_LanguagesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Answer_LanguagesEntry>, I>>(base?: I): Answer_LanguagesEntry {
    return Answer_LanguagesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Answer_LanguagesEntry>, I>>(object: I): Answer_LanguagesEntry {
    const message = createBaseAnswer_LanguagesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEnableWhen(): EnableWhen {
  return { question: "", operator: 0, answerCoding: undefined, answerDecimal: undefined, answerDate: undefined };
}

export const EnableWhen: MessageFns<EnableWhen> = {
  encode(message: EnableWhen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.question !== "") {
      writer.uint32(10).string(message.question);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    if (message.answerCoding !== undefined) {
      writer.uint32(26).string(message.answerCoding);
    }
    if (message.answerDecimal !== undefined) {
      writer.uint32(33).double(message.answerDecimal);
    }
    if (message.answerDate !== undefined) {
      writer.uint32(42).string(message.answerDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableWhen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableWhen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.answerCoding = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.answerDecimal = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.answerDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnableWhen {
    return {
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      operator: isSet(object.operator) ? operatorFromJSON(object.operator) : 0,
      answerCoding: isSet(object.answerCoding) ? globalThis.String(object.answerCoding) : undefined,
      answerDecimal: isSet(object.answerDecimal) ? globalThis.Number(object.answerDecimal) : undefined,
      answerDate: isSet(object.answerDate) ? globalThis.String(object.answerDate) : undefined,
    };
  },

  toJSON(message: EnableWhen): unknown {
    const obj: any = {};
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.operator !== 0) {
      obj.operator = operatorToJSON(message.operator);
    }
    if (message.answerCoding !== undefined) {
      obj.answerCoding = message.answerCoding;
    }
    if (message.answerDecimal !== undefined) {
      obj.answerDecimal = message.answerDecimal;
    }
    if (message.answerDate !== undefined) {
      obj.answerDate = message.answerDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnableWhen>, I>>(base?: I): EnableWhen {
    return EnableWhen.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnableWhen>, I>>(object: I): EnableWhen {
    const message = createBaseEnableWhen();
    message.question = object.question ?? "";
    message.operator = object.operator ?? 0;
    message.answerCoding = object.answerCoding ?? undefined;
    message.answerDecimal = object.answerDecimal ?? undefined;
    message.answerDate = object.answerDate ?? undefined;
    return message;
  },
};

function createBaseDiff(): Diff {
  return { change: undefined, timestamp: "", user: undefined };
}

export const Diff: MessageFns<Diff> = {
  encode(message: Diff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.change !== undefined) {
      Struct.encode(Struct.wrap(message.change), writer.uint32(10).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Diff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.change = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Diff {
    return {
      change: isObject(object.change) ? object.change : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: Diff): unknown {
    const obj: any = {};
    if (message.change !== undefined) {
      obj.change = message.change;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Diff>, I>>(base?: I): Diff {
    return Diff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Diff>, I>>(object: I): Diff {
    const message = createBaseDiff();
    message.change = object.change ?? undefined;
    message.timestamp = object.timestamp ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUser(): User {
  return { email: "", name: "", isAdmin: false, programRoles: [] };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isAdmin !== false) {
      writer.uint32(24).bool(message.isAdmin);
    }
    for (const v of message.programRoles) {
      ProgramRole.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAdmin = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.programRoles.push(ProgramRole.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isAdmin: isSet(object.isAdmin) ? globalThis.Boolean(object.isAdmin) : false,
      programRoles: globalThis.Array.isArray(object?.programRoles)
        ? object.programRoles.map((e: any) => ProgramRole.fromJSON(e))
        : [],
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isAdmin !== false) {
      obj.isAdmin = message.isAdmin;
    }
    if (message.programRoles?.length) {
      obj.programRoles = message.programRoles.map((e) => ProgramRole.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    message.isAdmin = object.isAdmin ?? false;
    message.programRoles = object.programRoles?.map((e) => ProgramRole.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProgramRole(): ProgramRole {
  return { userEmail: "", programName: "", role: 0 };
}

export const ProgramRole: MessageFns<ProgramRole> = {
  encode(message: ProgramRole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userEmail !== "") {
      writer.uint32(10).string(message.userEmail);
    }
    if (message.programName !== "") {
      writer.uint32(18).string(message.programName);
    }
    if (message.role !== 0) {
      writer.uint32(24).int32(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramRole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramRole {
    return {
      userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "",
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      role: isSet(object.role) ? roleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: ProgramRole): unknown {
    const obj: any = {};
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.role !== 0) {
      obj.role = roleToJSON(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgramRole>, I>>(base?: I): ProgramRole {
    return ProgramRole.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgramRole>, I>>(object: I): ProgramRole {
    const message = createBaseProgramRole();
    message.userEmail = object.userEmail ?? "";
    message.programName = object.programName ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseBlockedProgram(): BlockedProgram {
  return { userEmail: "", programName: "", timestamp: "" };
}

export const BlockedProgram: MessageFns<BlockedProgram> = {
  encode(message: BlockedProgram, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userEmail !== "") {
      writer.uint32(10).string(message.userEmail);
    }
    if (message.programName !== "") {
      writer.uint32(18).string(message.programName);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockedProgram {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockedProgram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockedProgram {
    return {
      userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "",
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: BlockedProgram): unknown {
    const obj: any = {};
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockedProgram>, I>>(base?: I): BlockedProgram {
    return BlockedProgram.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockedProgram>, I>>(object: I): BlockedProgram {
    const message = createBaseBlockedProgram();
    message.userEmail = object.userEmail ?? "";
    message.programName = object.programName ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseParticipantCode(): ParticipantCode {
  return { code: "", status: 0 };
}

export const ParticipantCode: MessageFns<ParticipantCode> = {
  encode(message: ParticipantCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParticipantCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipantCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParticipantCode {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      status: isSet(object.status) ? codeStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: ParticipantCode): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.status !== 0) {
      obj.status = codeStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParticipantCode>, I>>(base?: I): ParticipantCode {
    return ParticipantCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParticipantCode>, I>>(object: I): ParticipantCode {
    const message = createBaseParticipantCode();
    message.code = object.code ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseClient(): Client {
  return { name: "", programName: "", clientID: "", clientSecret: "" };
}

export const Client: MessageFns<Client> = {
  encode(message: Client, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.programName !== "") {
      writer.uint32(18).string(message.programName);
    }
    if (message.clientID !== "") {
      writer.uint32(26).string(message.clientID);
    }
    if (message.clientSecret !== "") {
      writer.uint32(34).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Client {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientID = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Client {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      clientID: isSet(object.clientID) ? globalThis.String(object.clientID) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
    };
  },

  toJSON(message: Client): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.clientID !== "") {
      obj.clientID = message.clientID;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Client>, I>>(base?: I): Client {
    return Client.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Client>, I>>(object: I): Client {
    const message = createBaseClient();
    message.name = object.name ?? "";
    message.programName = object.programName ?? "";
    message.clientID = object.clientID ?? "";
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
