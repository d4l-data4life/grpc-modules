// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.4
// source: research-pillars/static/static.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import { HttpBody } from "../../google/api/httpbody";
import { Struct } from "../../google/protobuf/struct";

export const protobufPackage = "proto.static";

export interface GetProgramsRequest {
}

export interface GetProgramsResponse {
  programs: { [key: string]: any }[];
}

export interface GetProgramRequest {
  name: string;
}

export interface GetProgramResponse {
  program?: { [key: string]: any } | undefined;
}

export interface GetProgramDataRequest {
  name: string;
}

export interface GetProgramDataResponse {
  program?: { [key: string]: any } | undefined;
  surveys: { [key: string]: any }[];
  questionnaires: { [key: string]: any }[];
  consents: { [key: string]: any }[];
  routines: { [key: string]: any }[];
  displays: { [key: string]: any }[];
}

export interface GetProgramUpdatedAtRequest {
  name: string;
}

export interface GetProgramUpdatedAtResponse {
  updatedAt: string;
}

export interface GetSurveysRequest {
  programName: string;
}

export interface GetSurveysResponse {
  surveys: { [key: string]: any }[];
}

export interface GetSurveyRequest {
  programName: string;
  name: string;
}

export interface GetSurveyResponse {
  survey?: { [key: string]: any } | undefined;
}

export interface GetQuestionnairesRequest {
  programName: string;
  language: string;
}

export interface GetQuestionnairesResponse {
  questionnaires: { [key: string]: any }[];
}

export interface GetQuestionnaireRequest {
  programName: string;
  name: string;
  language: string;
}

export interface GetQuestionnaireResponse {
  questionnaire?: { [key: string]: any } | undefined;
}

export interface GetRoutinesRequest {
  programName: string;
}

export interface GetRoutinesResponse {
  routines: { [key: string]: any }[];
}

export interface GetRoutineRequest {
  programName: string;
  name: string;
}

export interface GetRoutineResponse {
  routine?: { [key: string]: any } | undefined;
}

export interface GetDisplaysRequest {
  programName: string;
}

export interface GetDisplaysResponse {
  displays: { [key: string]: any }[];
}

export interface GetDisplayRequest {
  programName: string;
  name: string;
}

export interface GetDisplayResponse {
  display?: { [key: string]: any } | undefined;
}

export interface GetConsentsRequest {
  programName: string;
}

export interface GetConsentsResponse {
  consents: { [key: string]: any }[];
}

export interface GetConsentRequest {
  programName: string;
  name: string;
}

export interface GetConsentResponse {
  consents: { [key: string]: any }[];
}

export interface GetConsentVersionRequest {
  programName: string;
  name: string;
  version: number;
}

export interface GetConsentVersionResponse {
  consent?: { [key: string]: any } | undefined;
}

export interface ProxyRequest {
  target: string;
  params?: { [key: string]: any } | undefined;
  programName: string;
}

export interface ProxyResponse {
  body?: { [key: string]: any } | undefined;
}

export interface GetImageRequest {
  programName: string;
  name: string;
}

export interface ChecksRequest {
}

export interface ChecksResponse {
  response: string;
}

function createBaseGetProgramsRequest(): GetProgramsRequest {
  return {};
}

export const GetProgramsRequest: MessageFns<GetProgramsRequest> = {
  encode(_: GetProgramsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetProgramsRequest {
    return {};
  },

  toJSON(_: GetProgramsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramsRequest>, I>>(base?: I): GetProgramsRequest {
    return GetProgramsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramsRequest>, I>>(_: I): GetProgramsRequest {
    const message = createBaseGetProgramsRequest();
    return message;
  },
};

function createBaseGetProgramsResponse(): GetProgramsResponse {
  return { programs: [] };
}

export const GetProgramsResponse: MessageFns<GetProgramsResponse> = {
  encode(message: GetProgramsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.programs) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programs.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramsResponse {
    return { programs: globalThis.Array.isArray(object?.programs) ? [...object.programs] : [] };
  },

  toJSON(message: GetProgramsResponse): unknown {
    const obj: any = {};
    if (message.programs?.length) {
      obj.programs = message.programs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramsResponse>, I>>(base?: I): GetProgramsResponse {
    return GetProgramsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramsResponse>, I>>(object: I): GetProgramsResponse {
    const message = createBaseGetProgramsResponse();
    message.programs = object.programs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProgramRequest(): GetProgramRequest {
  return { name: "" };
}

export const GetProgramRequest: MessageFns<GetProgramRequest> = {
  encode(message: GetProgramRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProgramRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramRequest>, I>>(base?: I): GetProgramRequest {
    return GetProgramRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramRequest>, I>>(object: I): GetProgramRequest {
    const message = createBaseGetProgramRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProgramResponse(): GetProgramResponse {
  return { program: undefined };
}

export const GetProgramResponse: MessageFns<GetProgramResponse> = {
  encode(message: GetProgramResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== undefined) {
      Struct.encode(Struct.wrap(message.program), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.program = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramResponse {
    return { program: isObject(object.program) ? object.program : undefined };
  },

  toJSON(message: GetProgramResponse): unknown {
    const obj: any = {};
    if (message.program !== undefined) {
      obj.program = message.program;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramResponse>, I>>(base?: I): GetProgramResponse {
    return GetProgramResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramResponse>, I>>(object: I): GetProgramResponse {
    const message = createBaseGetProgramResponse();
    message.program = object.program ?? undefined;
    return message;
  },
};

function createBaseGetProgramDataRequest(): GetProgramDataRequest {
  return { name: "" };
}

export const GetProgramDataRequest: MessageFns<GetProgramDataRequest> = {
  encode(message: GetProgramDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramDataRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProgramDataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramDataRequest>, I>>(base?: I): GetProgramDataRequest {
    return GetProgramDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramDataRequest>, I>>(object: I): GetProgramDataRequest {
    const message = createBaseGetProgramDataRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProgramDataResponse(): GetProgramDataResponse {
  return { program: undefined, surveys: [], questionnaires: [], consents: [], routines: [], displays: [] };
}

export const GetProgramDataResponse: MessageFns<GetProgramDataResponse> = {
  encode(message: GetProgramDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== undefined) {
      Struct.encode(Struct.wrap(message.program), writer.uint32(10).fork()).join();
    }
    for (const v of message.surveys) {
      Struct.encode(Struct.wrap(v!), writer.uint32(18).fork()).join();
    }
    for (const v of message.questionnaires) {
      Struct.encode(Struct.wrap(v!), writer.uint32(26).fork()).join();
    }
    for (const v of message.consents) {
      Struct.encode(Struct.wrap(v!), writer.uint32(34).fork()).join();
    }
    for (const v of message.routines) {
      Struct.encode(Struct.wrap(v!), writer.uint32(42).fork()).join();
    }
    for (const v of message.displays) {
      Struct.encode(Struct.wrap(v!), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.program = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.surveys.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.questionnaires.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.consents.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.routines.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displays.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramDataResponse {
    return {
      program: isObject(object.program) ? object.program : undefined,
      surveys: globalThis.Array.isArray(object?.surveys) ? [...object.surveys] : [],
      questionnaires: globalThis.Array.isArray(object?.questionnaires) ? [...object.questionnaires] : [],
      consents: globalThis.Array.isArray(object?.consents) ? [...object.consents] : [],
      routines: globalThis.Array.isArray(object?.routines) ? [...object.routines] : [],
      displays: globalThis.Array.isArray(object?.displays) ? [...object.displays] : [],
    };
  },

  toJSON(message: GetProgramDataResponse): unknown {
    const obj: any = {};
    if (message.program !== undefined) {
      obj.program = message.program;
    }
    if (message.surveys?.length) {
      obj.surveys = message.surveys;
    }
    if (message.questionnaires?.length) {
      obj.questionnaires = message.questionnaires;
    }
    if (message.consents?.length) {
      obj.consents = message.consents;
    }
    if (message.routines?.length) {
      obj.routines = message.routines;
    }
    if (message.displays?.length) {
      obj.displays = message.displays;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramDataResponse>, I>>(base?: I): GetProgramDataResponse {
    return GetProgramDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramDataResponse>, I>>(object: I): GetProgramDataResponse {
    const message = createBaseGetProgramDataResponse();
    message.program = object.program ?? undefined;
    message.surveys = object.surveys?.map((e) => e) || [];
    message.questionnaires = object.questionnaires?.map((e) => e) || [];
    message.consents = object.consents?.map((e) => e) || [];
    message.routines = object.routines?.map((e) => e) || [];
    message.displays = object.displays?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProgramUpdatedAtRequest(): GetProgramUpdatedAtRequest {
  return { name: "" };
}

export const GetProgramUpdatedAtRequest: MessageFns<GetProgramUpdatedAtRequest> = {
  encode(message: GetProgramUpdatedAtRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramUpdatedAtRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramUpdatedAtRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramUpdatedAtRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProgramUpdatedAtRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramUpdatedAtRequest>, I>>(base?: I): GetProgramUpdatedAtRequest {
    return GetProgramUpdatedAtRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramUpdatedAtRequest>, I>>(object: I): GetProgramUpdatedAtRequest {
    const message = createBaseGetProgramUpdatedAtRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProgramUpdatedAtResponse(): GetProgramUpdatedAtResponse {
  return { updatedAt: "" };
}

export const GetProgramUpdatedAtResponse: MessageFns<GetProgramUpdatedAtResponse> = {
  encode(message: GetProgramUpdatedAtResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updatedAt !== "") {
      writer.uint32(10).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgramUpdatedAtResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgramUpdatedAtResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProgramUpdatedAtResponse {
    return { updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "" };
  },

  toJSON(message: GetProgramUpdatedAtResponse): unknown {
    const obj: any = {};
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProgramUpdatedAtResponse>, I>>(base?: I): GetProgramUpdatedAtResponse {
    return GetProgramUpdatedAtResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProgramUpdatedAtResponse>, I>>(object: I): GetProgramUpdatedAtResponse {
    const message = createBaseGetProgramUpdatedAtResponse();
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseGetSurveysRequest(): GetSurveysRequest {
  return { programName: "" };
}

export const GetSurveysRequest: MessageFns<GetSurveysRequest> = {
  encode(message: GetSurveysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveysRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetSurveysRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveysRequest>, I>>(base?: I): GetSurveysRequest {
    return GetSurveysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveysRequest>, I>>(object: I): GetSurveysRequest {
    const message = createBaseGetSurveysRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetSurveysResponse(): GetSurveysResponse {
  return { surveys: [] };
}

export const GetSurveysResponse: MessageFns<GetSurveysResponse> = {
  encode(message: GetSurveysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.surveys) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.surveys.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveysResponse {
    return { surveys: globalThis.Array.isArray(object?.surveys) ? [...object.surveys] : [] };
  },

  toJSON(message: GetSurveysResponse): unknown {
    const obj: any = {};
    if (message.surveys?.length) {
      obj.surveys = message.surveys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveysResponse>, I>>(base?: I): GetSurveysResponse {
    return GetSurveysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveysResponse>, I>>(object: I): GetSurveysResponse {
    const message = createBaseGetSurveysResponse();
    message.surveys = object.surveys?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSurveyRequest(): GetSurveyRequest {
  return { programName: "", name: "" };
}

export const GetSurveyRequest: MessageFns<GetSurveyRequest> = {
  encode(message: GetSurveyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveyRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetSurveyRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveyRequest>, I>>(base?: I): GetSurveyRequest {
    return GetSurveyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveyRequest>, I>>(object: I): GetSurveyRequest {
    const message = createBaseGetSurveyRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetSurveyResponse(): GetSurveyResponse {
  return { survey: undefined };
}

export const GetSurveyResponse: MessageFns<GetSurveyResponse> = {
  encode(message: GetSurveyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.survey !== undefined) {
      Struct.encode(Struct.wrap(message.survey), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSurveyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSurveyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.survey = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSurveyResponse {
    return { survey: isObject(object.survey) ? object.survey : undefined };
  },

  toJSON(message: GetSurveyResponse): unknown {
    const obj: any = {};
    if (message.survey !== undefined) {
      obj.survey = message.survey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSurveyResponse>, I>>(base?: I): GetSurveyResponse {
    return GetSurveyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSurveyResponse>, I>>(object: I): GetSurveyResponse {
    const message = createBaseGetSurveyResponse();
    message.survey = object.survey ?? undefined;
    return message;
  },
};

function createBaseGetQuestionnairesRequest(): GetQuestionnairesRequest {
  return { programName: "", language: "" };
}

export const GetQuestionnairesRequest: MessageFns<GetQuestionnairesRequest> = {
  encode(message: GetQuestionnairesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnairesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnairesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnairesRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: GetQuestionnairesRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnairesRequest>, I>>(base?: I): GetQuestionnairesRequest {
    return GetQuestionnairesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnairesRequest>, I>>(object: I): GetQuestionnairesRequest {
    const message = createBaseGetQuestionnairesRequest();
    message.programName = object.programName ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseGetQuestionnairesResponse(): GetQuestionnairesResponse {
  return { questionnaires: [] };
}

export const GetQuestionnairesResponse: MessageFns<GetQuestionnairesResponse> = {
  encode(message: GetQuestionnairesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.questionnaires) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnairesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnairesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionnaires.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnairesResponse {
    return { questionnaires: globalThis.Array.isArray(object?.questionnaires) ? [...object.questionnaires] : [] };
  },

  toJSON(message: GetQuestionnairesResponse): unknown {
    const obj: any = {};
    if (message.questionnaires?.length) {
      obj.questionnaires = message.questionnaires;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnairesResponse>, I>>(base?: I): GetQuestionnairesResponse {
    return GetQuestionnairesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnairesResponse>, I>>(object: I): GetQuestionnairesResponse {
    const message = createBaseGetQuestionnairesResponse();
    message.questionnaires = object.questionnaires?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetQuestionnaireRequest(): GetQuestionnaireRequest {
  return { programName: "", name: "", language: "" };
}

export const GetQuestionnaireRequest: MessageFns<GetQuestionnaireRequest> = {
  encode(message: GetQuestionnaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.language !== "") {
      writer.uint32(26).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnaireRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: GetQuestionnaireRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnaireRequest>, I>>(base?: I): GetQuestionnaireRequest {
    return GetQuestionnaireRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnaireRequest>, I>>(object: I): GetQuestionnaireRequest {
    const message = createBaseGetQuestionnaireRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseGetQuestionnaireResponse(): GetQuestionnaireResponse {
  return { questionnaire: undefined };
}

export const GetQuestionnaireResponse: MessageFns<GetQuestionnaireResponse> = {
  encode(message: GetQuestionnaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionnaire !== undefined) {
      Struct.encode(Struct.wrap(message.questionnaire), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionnaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionnaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionnaire = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionnaireResponse {
    return { questionnaire: isObject(object.questionnaire) ? object.questionnaire : undefined };
  },

  toJSON(message: GetQuestionnaireResponse): unknown {
    const obj: any = {};
    if (message.questionnaire !== undefined) {
      obj.questionnaire = message.questionnaire;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionnaireResponse>, I>>(base?: I): GetQuestionnaireResponse {
    return GetQuestionnaireResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionnaireResponse>, I>>(object: I): GetQuestionnaireResponse {
    const message = createBaseGetQuestionnaireResponse();
    message.questionnaire = object.questionnaire ?? undefined;
    return message;
  },
};

function createBaseGetRoutinesRequest(): GetRoutinesRequest {
  return { programName: "" };
}

export const GetRoutinesRequest: MessageFns<GetRoutinesRequest> = {
  encode(message: GetRoutinesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutinesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutinesRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetRoutinesRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutinesRequest>, I>>(base?: I): GetRoutinesRequest {
    return GetRoutinesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutinesRequest>, I>>(object: I): GetRoutinesRequest {
    const message = createBaseGetRoutinesRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetRoutinesResponse(): GetRoutinesResponse {
  return { routines: [] };
}

export const GetRoutinesResponse: MessageFns<GetRoutinesResponse> = {
  encode(message: GetRoutinesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routines) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutinesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutinesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routines.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutinesResponse {
    return { routines: globalThis.Array.isArray(object?.routines) ? [...object.routines] : [] };
  },

  toJSON(message: GetRoutinesResponse): unknown {
    const obj: any = {};
    if (message.routines?.length) {
      obj.routines = message.routines;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutinesResponse>, I>>(base?: I): GetRoutinesResponse {
    return GetRoutinesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutinesResponse>, I>>(object: I): GetRoutinesResponse {
    const message = createBaseGetRoutinesResponse();
    message.routines = object.routines?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRoutineRequest(): GetRoutineRequest {
  return { programName: "", name: "" };
}

export const GetRoutineRequest: MessageFns<GetRoutineRequest> = {
  encode(message: GetRoutineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutineRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetRoutineRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutineRequest>, I>>(base?: I): GetRoutineRequest {
    return GetRoutineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutineRequest>, I>>(object: I): GetRoutineRequest {
    const message = createBaseGetRoutineRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetRoutineResponse(): GetRoutineResponse {
  return { routine: undefined };
}

export const GetRoutineResponse: MessageFns<GetRoutineResponse> = {
  encode(message: GetRoutineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routine !== undefined) {
      Struct.encode(Struct.wrap(message.routine), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoutineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoutineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routine = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoutineResponse {
    return { routine: isObject(object.routine) ? object.routine : undefined };
  },

  toJSON(message: GetRoutineResponse): unknown {
    const obj: any = {};
    if (message.routine !== undefined) {
      obj.routine = message.routine;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRoutineResponse>, I>>(base?: I): GetRoutineResponse {
    return GetRoutineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRoutineResponse>, I>>(object: I): GetRoutineResponse {
    const message = createBaseGetRoutineResponse();
    message.routine = object.routine ?? undefined;
    return message;
  },
};

function createBaseGetDisplaysRequest(): GetDisplaysRequest {
  return { programName: "" };
}

export const GetDisplaysRequest: MessageFns<GetDisplaysRequest> = {
  encode(message: GetDisplaysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplaysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplaysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplaysRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetDisplaysRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplaysRequest>, I>>(base?: I): GetDisplaysRequest {
    return GetDisplaysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplaysRequest>, I>>(object: I): GetDisplaysRequest {
    const message = createBaseGetDisplaysRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetDisplaysResponse(): GetDisplaysResponse {
  return { displays: [] };
}

export const GetDisplaysResponse: MessageFns<GetDisplaysResponse> = {
  encode(message: GetDisplaysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.displays) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplaysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplaysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displays.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplaysResponse {
    return { displays: globalThis.Array.isArray(object?.displays) ? [...object.displays] : [] };
  },

  toJSON(message: GetDisplaysResponse): unknown {
    const obj: any = {};
    if (message.displays?.length) {
      obj.displays = message.displays;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplaysResponse>, I>>(base?: I): GetDisplaysResponse {
    return GetDisplaysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplaysResponse>, I>>(object: I): GetDisplaysResponse {
    const message = createBaseGetDisplaysResponse();
    message.displays = object.displays?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDisplayRequest(): GetDisplayRequest {
  return { programName: "", name: "" };
}

export const GetDisplayRequest: MessageFns<GetDisplayRequest> = {
  encode(message: GetDisplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplayRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetDisplayRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplayRequest>, I>>(base?: I): GetDisplayRequest {
    return GetDisplayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplayRequest>, I>>(object: I): GetDisplayRequest {
    const message = createBaseGetDisplayRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetDisplayResponse(): GetDisplayResponse {
  return { display: undefined };
}

export const GetDisplayResponse: MessageFns<GetDisplayResponse> = {
  encode(message: GetDisplayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.display !== undefined) {
      Struct.encode(Struct.wrap(message.display), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.display = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplayResponse {
    return { display: isObject(object.display) ? object.display : undefined };
  },

  toJSON(message: GetDisplayResponse): unknown {
    const obj: any = {};
    if (message.display !== undefined) {
      obj.display = message.display;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDisplayResponse>, I>>(base?: I): GetDisplayResponse {
    return GetDisplayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDisplayResponse>, I>>(object: I): GetDisplayResponse {
    const message = createBaseGetDisplayResponse();
    message.display = object.display ?? undefined;
    return message;
  },
};

function createBaseGetConsentsRequest(): GetConsentsRequest {
  return { programName: "" };
}

export const GetConsentsRequest: MessageFns<GetConsentsRequest> = {
  encode(message: GetConsentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentsRequest {
    return { programName: isSet(object.programName) ? globalThis.String(object.programName) : "" };
  },

  toJSON(message: GetConsentsRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentsRequest>, I>>(base?: I): GetConsentsRequest {
    return GetConsentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentsRequest>, I>>(object: I): GetConsentsRequest {
    const message = createBaseGetConsentsRequest();
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseGetConsentsResponse(): GetConsentsResponse {
  return { consents: [] };
}

export const GetConsentsResponse: MessageFns<GetConsentsResponse> = {
  encode(message: GetConsentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.consents) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consents.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentsResponse {
    return { consents: globalThis.Array.isArray(object?.consents) ? [...object.consents] : [] };
  },

  toJSON(message: GetConsentsResponse): unknown {
    const obj: any = {};
    if (message.consents?.length) {
      obj.consents = message.consents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentsResponse>, I>>(base?: I): GetConsentsResponse {
    return GetConsentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentsResponse>, I>>(object: I): GetConsentsResponse {
    const message = createBaseGetConsentsResponse();
    message.consents = object.consents?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetConsentRequest(): GetConsentRequest {
  return { programName: "", name: "" };
}

export const GetConsentRequest: MessageFns<GetConsentRequest> = {
  encode(message: GetConsentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetConsentRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentRequest>, I>>(base?: I): GetConsentRequest {
    return GetConsentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentRequest>, I>>(object: I): GetConsentRequest {
    const message = createBaseGetConsentRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetConsentResponse(): GetConsentResponse {
  return { consents: [] };
}

export const GetConsentResponse: MessageFns<GetConsentResponse> = {
  encode(message: GetConsentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.consents) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consents.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentResponse {
    return { consents: globalThis.Array.isArray(object?.consents) ? [...object.consents] : [] };
  },

  toJSON(message: GetConsentResponse): unknown {
    const obj: any = {};
    if (message.consents?.length) {
      obj.consents = message.consents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentResponse>, I>>(base?: I): GetConsentResponse {
    return GetConsentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentResponse>, I>>(object: I): GetConsentResponse {
    const message = createBaseGetConsentResponse();
    message.consents = object.consents?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetConsentVersionRequest(): GetConsentVersionRequest {
  return { programName: "", name: "", version: 0 };
}

export const GetConsentVersionRequest: MessageFns<GetConsentVersionRequest> = {
  encode(message: GetConsentVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentVersionRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: GetConsentVersionRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentVersionRequest>, I>>(base?: I): GetConsentVersionRequest {
    return GetConsentVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentVersionRequest>, I>>(object: I): GetConsentVersionRequest {
    const message = createBaseGetConsentVersionRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseGetConsentVersionResponse(): GetConsentVersionResponse {
  return { consent: undefined };
}

export const GetConsentVersionResponse: MessageFns<GetConsentVersionResponse> = {
  encode(message: GetConsentVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consent !== undefined) {
      Struct.encode(Struct.wrap(message.consent), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsentVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsentVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consent = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsentVersionResponse {
    return { consent: isObject(object.consent) ? object.consent : undefined };
  },

  toJSON(message: GetConsentVersionResponse): unknown {
    const obj: any = {};
    if (message.consent !== undefined) {
      obj.consent = message.consent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsentVersionResponse>, I>>(base?: I): GetConsentVersionResponse {
    return GetConsentVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsentVersionResponse>, I>>(object: I): GetConsentVersionResponse {
    const message = createBaseGetConsentVersionResponse();
    message.consent = object.consent ?? undefined;
    return message;
  },
};

function createBaseProxyRequest(): ProxyRequest {
  return { target: "", params: undefined, programName: "" };
}

export const ProxyRequest: MessageFns<ProxyRequest> = {
  encode(message: ProxyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(18).fork()).join();
    }
    if (message.programName !== "") {
      writer.uint32(26).string(message.programName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProxyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyRequest {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      params: isObject(object.params) ? object.params : undefined,
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
    };
  },

  toJSON(message: ProxyRequest): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProxyRequest>, I>>(base?: I): ProxyRequest {
    return ProxyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProxyRequest>, I>>(object: I): ProxyRequest {
    const message = createBaseProxyRequest();
    message.target = object.target ?? "";
    message.params = object.params ?? undefined;
    message.programName = object.programName ?? "";
    return message;
  },
};

function createBaseProxyResponse(): ProxyResponse {
  return { body: undefined };
}

export const ProxyResponse: MessageFns<ProxyResponse> = {
  encode(message: ProxyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined) {
      Struct.encode(Struct.wrap(message.body), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProxyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyResponse {
    return { body: isObject(object.body) ? object.body : undefined };
  },

  toJSON(message: ProxyResponse): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProxyResponse>, I>>(base?: I): ProxyResponse {
    return ProxyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProxyResponse>, I>>(object: I): ProxyResponse {
    const message = createBaseProxyResponse();
    message.body = object.body ?? undefined;
    return message;
  },
};

function createBaseGetImageRequest(): GetImageRequest {
  return { programName: "", name: "" };
}

export const GetImageRequest: MessageFns<GetImageRequest> = {
  encode(message: GetImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programName !== "") {
      writer.uint32(10).string(message.programName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImageRequest {
    return {
      programName: isSet(object.programName) ? globalThis.String(object.programName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetImageRequest): unknown {
    const obj: any = {};
    if (message.programName !== "") {
      obj.programName = message.programName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetImageRequest>, I>>(base?: I): GetImageRequest {
    return GetImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetImageRequest>, I>>(object: I): GetImageRequest {
    const message = createBaseGetImageRequest();
    message.programName = object.programName ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChecksRequest(): ChecksRequest {
  return {};
}

export const ChecksRequest: MessageFns<ChecksRequest> = {
  encode(_: ChecksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChecksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChecksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ChecksRequest {
    return {};
  },

  toJSON(_: ChecksRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ChecksRequest>, I>>(base?: I): ChecksRequest {
    return ChecksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChecksRequest>, I>>(_: I): ChecksRequest {
    const message = createBaseChecksRequest();
    return message;
  },
};

function createBaseChecksResponse(): ChecksResponse {
  return { response: "" };
}

export const ChecksResponse: MessageFns<ChecksResponse> = {
  encode(message: ChecksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChecksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChecksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChecksResponse {
    return { response: isSet(object.response) ? globalThis.String(object.response) : "" };
  },

  toJSON(message: ChecksResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChecksResponse>, I>>(base?: I): ChecksResponse {
    return ChecksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChecksResponse>, I>>(object: I): ChecksResponse {
    const message = createBaseChecksResponse();
    message.response = object.response ?? "";
    return message;
  },
};

export interface Programs {
  GetPrograms(request: DeepPartial<GetProgramsRequest>, metadata?: grpc.Metadata): Promise<GetProgramsResponse>;
  GetProgram(request: DeepPartial<GetProgramRequest>, metadata?: grpc.Metadata): Promise<GetProgramResponse>;
  GetProgramData(
    request: DeepPartial<GetProgramDataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramDataResponse>;
  GetProgramUpdatedAt(
    request: DeepPartial<GetProgramUpdatedAtRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramUpdatedAtResponse>;
}

export class ProgramsClientImpl implements Programs {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetPrograms = this.GetPrograms.bind(this);
    this.GetProgram = this.GetProgram.bind(this);
    this.GetProgramData = this.GetProgramData.bind(this);
    this.GetProgramUpdatedAt = this.GetProgramUpdatedAt.bind(this);
  }

  GetPrograms(request: DeepPartial<GetProgramsRequest>, metadata?: grpc.Metadata): Promise<GetProgramsResponse> {
    return this.rpc.unary(ProgramsGetProgramsDesc, GetProgramsRequest.fromPartial(request), metadata);
  }

  GetProgram(request: DeepPartial<GetProgramRequest>, metadata?: grpc.Metadata): Promise<GetProgramResponse> {
    return this.rpc.unary(ProgramsGetProgramDesc, GetProgramRequest.fromPartial(request), metadata);
  }

  GetProgramData(
    request: DeepPartial<GetProgramDataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramDataResponse> {
    return this.rpc.unary(ProgramsGetProgramDataDesc, GetProgramDataRequest.fromPartial(request), metadata);
  }

  GetProgramUpdatedAt(
    request: DeepPartial<GetProgramUpdatedAtRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetProgramUpdatedAtResponse> {
    return this.rpc.unary(ProgramsGetProgramUpdatedAtDesc, GetProgramUpdatedAtRequest.fromPartial(request), metadata);
  }
}

export const ProgramsDesc = { serviceName: "proto.static.Programs" };

export const ProgramsGetProgramsDesc: UnaryMethodDefinitionish = {
  methodName: "GetPrograms",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsGetProgramDesc: UnaryMethodDefinitionish = {
  methodName: "GetProgram",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsGetProgramDataDesc: UnaryMethodDefinitionish = {
  methodName: "GetProgramData",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramDataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramDataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramsGetProgramUpdatedAtDesc: UnaryMethodDefinitionish = {
  methodName: "GetProgramUpdatedAt",
  service: ProgramsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetProgramUpdatedAtRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetProgramUpdatedAtResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Surveys {
  GetSurveys(request: DeepPartial<GetSurveysRequest>, metadata?: grpc.Metadata): Promise<GetSurveysResponse>;
  GetSurvey(request: DeepPartial<GetSurveyRequest>, metadata?: grpc.Metadata): Promise<GetSurveyResponse>;
}

export class SurveysClientImpl implements Surveys {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetSurveys = this.GetSurveys.bind(this);
    this.GetSurvey = this.GetSurvey.bind(this);
  }

  GetSurveys(request: DeepPartial<GetSurveysRequest>, metadata?: grpc.Metadata): Promise<GetSurveysResponse> {
    return this.rpc.unary(SurveysGetSurveysDesc, GetSurveysRequest.fromPartial(request), metadata);
  }

  GetSurvey(request: DeepPartial<GetSurveyRequest>, metadata?: grpc.Metadata): Promise<GetSurveyResponse> {
    return this.rpc.unary(SurveysGetSurveyDesc, GetSurveyRequest.fromPartial(request), metadata);
  }
}

export const SurveysDesc = { serviceName: "proto.static.Surveys" };

export const SurveysGetSurveysDesc: UnaryMethodDefinitionish = {
  methodName: "GetSurveys",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSurveysRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSurveysResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SurveysGetSurveyDesc: UnaryMethodDefinitionish = {
  methodName: "GetSurvey",
  service: SurveysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSurveyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetSurveyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Questionnaires {
  GetQuestionnaires(
    request: DeepPartial<GetQuestionnairesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnairesResponse>;
  GetQuestionnaire(
    request: DeepPartial<GetQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnaireResponse>;
}

export class QuestionnairesClientImpl implements Questionnaires {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetQuestionnaires = this.GetQuestionnaires.bind(this);
    this.GetQuestionnaire = this.GetQuestionnaire.bind(this);
  }

  GetQuestionnaires(
    request: DeepPartial<GetQuestionnairesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnairesResponse> {
    return this.rpc.unary(QuestionnairesGetQuestionnairesDesc, GetQuestionnairesRequest.fromPartial(request), metadata);
  }

  GetQuestionnaire(
    request: DeepPartial<GetQuestionnaireRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetQuestionnaireResponse> {
    return this.rpc.unary(QuestionnairesGetQuestionnaireDesc, GetQuestionnaireRequest.fromPartial(request), metadata);
  }
}

export const QuestionnairesDesc = { serviceName: "proto.static.Questionnaires" };

export const QuestionnairesGetQuestionnairesDesc: UnaryMethodDefinitionish = {
  methodName: "GetQuestionnaires",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetQuestionnairesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetQuestionnairesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuestionnairesGetQuestionnaireDesc: UnaryMethodDefinitionish = {
  methodName: "GetQuestionnaire",
  service: QuestionnairesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetQuestionnaireRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetQuestionnaireResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Routines {
  GetRoutines(request: DeepPartial<GetRoutinesRequest>, metadata?: grpc.Metadata): Promise<GetRoutinesResponse>;
  GetRoutine(request: DeepPartial<GetRoutineRequest>, metadata?: grpc.Metadata): Promise<GetRoutineResponse>;
}

export class RoutinesClientImpl implements Routines {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetRoutines = this.GetRoutines.bind(this);
    this.GetRoutine = this.GetRoutine.bind(this);
  }

  GetRoutines(request: DeepPartial<GetRoutinesRequest>, metadata?: grpc.Metadata): Promise<GetRoutinesResponse> {
    return this.rpc.unary(RoutinesGetRoutinesDesc, GetRoutinesRequest.fromPartial(request), metadata);
  }

  GetRoutine(request: DeepPartial<GetRoutineRequest>, metadata?: grpc.Metadata): Promise<GetRoutineResponse> {
    return this.rpc.unary(RoutinesGetRoutineDesc, GetRoutineRequest.fromPartial(request), metadata);
  }
}

export const RoutinesDesc = { serviceName: "proto.static.Routines" };

export const RoutinesGetRoutinesDesc: UnaryMethodDefinitionish = {
  methodName: "GetRoutines",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetRoutinesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetRoutinesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RoutinesGetRoutineDesc: UnaryMethodDefinitionish = {
  methodName: "GetRoutine",
  service: RoutinesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetRoutineRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetRoutineResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Displays {
  GetDisplays(request: DeepPartial<GetDisplaysRequest>, metadata?: grpc.Metadata): Promise<GetDisplaysResponse>;
  GetDisplay(request: DeepPartial<GetDisplayRequest>, metadata?: grpc.Metadata): Promise<GetDisplayResponse>;
}

export class DisplaysClientImpl implements Displays {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetDisplays = this.GetDisplays.bind(this);
    this.GetDisplay = this.GetDisplay.bind(this);
  }

  GetDisplays(request: DeepPartial<GetDisplaysRequest>, metadata?: grpc.Metadata): Promise<GetDisplaysResponse> {
    return this.rpc.unary(DisplaysGetDisplaysDesc, GetDisplaysRequest.fromPartial(request), metadata);
  }

  GetDisplay(request: DeepPartial<GetDisplayRequest>, metadata?: grpc.Metadata): Promise<GetDisplayResponse> {
    return this.rpc.unary(DisplaysGetDisplayDesc, GetDisplayRequest.fromPartial(request), metadata);
  }
}

export const DisplaysDesc = { serviceName: "proto.static.Displays" };

export const DisplaysGetDisplaysDesc: UnaryMethodDefinitionish = {
  methodName: "GetDisplays",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDisplaysRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetDisplaysResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const DisplaysGetDisplayDesc: UnaryMethodDefinitionish = {
  methodName: "GetDisplay",
  service: DisplaysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDisplayRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetDisplayResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Consents {
  GetConsents(request: DeepPartial<GetConsentsRequest>, metadata?: grpc.Metadata): Promise<GetConsentsResponse>;
  GetConsent(request: DeepPartial<GetConsentRequest>, metadata?: grpc.Metadata): Promise<GetConsentResponse>;
  GetConsentVersion(
    request: DeepPartial<GetConsentVersionRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetConsentVersionResponse>;
}

export class ConsentsClientImpl implements Consents {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetConsents = this.GetConsents.bind(this);
    this.GetConsent = this.GetConsent.bind(this);
    this.GetConsentVersion = this.GetConsentVersion.bind(this);
  }

  GetConsents(request: DeepPartial<GetConsentsRequest>, metadata?: grpc.Metadata): Promise<GetConsentsResponse> {
    return this.rpc.unary(ConsentsGetConsentsDesc, GetConsentsRequest.fromPartial(request), metadata);
  }

  GetConsent(request: DeepPartial<GetConsentRequest>, metadata?: grpc.Metadata): Promise<GetConsentResponse> {
    return this.rpc.unary(ConsentsGetConsentDesc, GetConsentRequest.fromPartial(request), metadata);
  }

  GetConsentVersion(
    request: DeepPartial<GetConsentVersionRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetConsentVersionResponse> {
    return this.rpc.unary(ConsentsGetConsentVersionDesc, GetConsentVersionRequest.fromPartial(request), metadata);
  }
}

export const ConsentsDesc = { serviceName: "proto.static.Consents" };

export const ConsentsGetConsentsDesc: UnaryMethodDefinitionish = {
  methodName: "GetConsents",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConsentsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetConsentsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConsentsGetConsentDesc: UnaryMethodDefinitionish = {
  methodName: "GetConsent",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConsentRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetConsentResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConsentsGetConsentVersionDesc: UnaryMethodDefinitionish = {
  methodName: "GetConsentVersion",
  service: ConsentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConsentVersionRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetConsentVersionResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Utilities {
  Proxy(request: DeepPartial<ProxyRequest>, metadata?: grpc.Metadata): Promise<ProxyResponse>;
}

export class UtilitiesClientImpl implements Utilities {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Proxy = this.Proxy.bind(this);
  }

  Proxy(request: DeepPartial<ProxyRequest>, metadata?: grpc.Metadata): Promise<ProxyResponse> {
    return this.rpc.unary(UtilitiesProxyDesc, ProxyRequest.fromPartial(request), metadata);
  }
}

export const UtilitiesDesc = { serviceName: "proto.static.Utilities" };

export const UtilitiesProxyDesc: UnaryMethodDefinitionish = {
  methodName: "Proxy",
  service: UtilitiesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProxyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProxyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Images {
  GetImage(request: DeepPartial<GetImageRequest>, metadata?: grpc.Metadata): Promise<HttpBody>;
}

export class ImagesClientImpl implements Images {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetImage = this.GetImage.bind(this);
  }

  GetImage(request: DeepPartial<GetImageRequest>, metadata?: grpc.Metadata): Promise<HttpBody> {
    return this.rpc.unary(ImagesGetImageDesc, GetImageRequest.fromPartial(request), metadata);
  }
}

export const ImagesDesc = { serviceName: "proto.static.Images" };

export const ImagesGetImageDesc: UnaryMethodDefinitionish = {
  methodName: "GetImage",
  service: ImagesDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetImageRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = HttpBody.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface Checks {
  Liveness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse>;
  Readiness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse>;
}

export class ChecksClientImpl implements Checks {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Liveness = this.Liveness.bind(this);
    this.Readiness = this.Readiness.bind(this);
  }

  Liveness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse> {
    return this.rpc.unary(ChecksLivenessDesc, ChecksRequest.fromPartial(request), metadata);
  }

  Readiness(request: DeepPartial<ChecksRequest>, metadata?: grpc.Metadata): Promise<ChecksResponse> {
    return this.rpc.unary(ChecksReadinessDesc, ChecksRequest.fromPartial(request), metadata);
  }
}

export const ChecksDesc = { serviceName: "proto.static.Checks" };

export const ChecksLivenessDesc: UnaryMethodDefinitionish = {
  methodName: "Liveness",
  service: ChecksDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ChecksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ChecksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ChecksReadinessDesc: UnaryMethodDefinitionish = {
  methodName: "Readiness",
  service: ChecksDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ChecksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ChecksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
